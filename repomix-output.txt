This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-13T16:46:25.423Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.dev/
  Dockerfile
.github/
  workflows/
    build-shared.yml
    build-static.yml
  FUNDING.yml
cmake/
  clang_format.cmake
  clang_tidy.cmake
  compiler_options.cmake
  cpack.cmake
  cppcheck.cmake
  dependencies.cmake
project/
  HC-MC/
    include/
      HC-MC.hpp
    tests/
      pt_tests.cpp
    CMakeLists.txt
    main.cpp
    oldmaincpp.txt
  CMakeLists.txt
.clang-format
.clang-tidy
.dockerignore
.gitignore
.gitmodules
.repomixignore
AAA.cpp
AAA.hpp
build.sh
CMakeLists.txt
cppcheck_suppressions.txt
mpreal.h
README.md
vcpkg.json

================================================================
Repository Files
================================================================

================
File: .dev/Dockerfile
================
FROM ubuntu:24.04

# Define Conan and CMake versions
ARG CONAN_VERSION=2.6.0
ARG CMAKE_VERSION=3.30.1

# Define User ID and Group ID
ARG USER_ID=1000
ARG GROUP_ID=1000

WORKDIR /project

# Define Labels
LABEL maintainer="Michele Adduci <adduci@tutanota.com>" \
      description="Docker image for C++ development with Conan and CMake" \
      cmake.version="${CMAKE_VERSION}" \
      conan.version="${CONAN_VERSION}" 

# Install basic tooling
RUN apt-get update && \
    apt-get install -y \
        build-essential \
        curl \
        gcc \
        cppcheck \
        clang-format && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Install Conan and CMake from GitHub Releases
RUN curl -fsSL https://github.com/conan-io/conan/releases/download/${CONAN_VERSION}/conan-${CONAN_VERSION}-amd64.deb -o /tmp/conan.deb && \
    dpkg -i /tmp/conan.deb && \
    curl -fsSL https://github.com/Kitware/CMake/releases/download/v${CMAKE_VERSION}/cmake-${CMAKE_VERSION}-linux-x86_64.tar.gz -o /tmp/cmake.tar.gz && \
    mkdir -p /opt/cmake && \
    tar -xzf /tmp/cmake.tar.gz -C /opt/cmake/ --strip-components=1 && \
    chmod +x /opt/cmake/bin/* && \
    ln -sf /opt/cmake/bin/cmake /usr/bin/cmake && \
    ln -sf /opt/cmake/bin/ctest /usr/bin/ctest && \
    ln -sf /opt/cmake/bin/cpack /usr/bin/cpack && \
    ln -sf /opt/cmake/bin/ccmake /usr/bin/ccmake && \
    rm -rf /tmp/*

# Create non-root user to run container with less privileges
USER ${USER_ID}

# Run Conan profile detection as non-root user
RUN conan profile detect

================
File: .github/workflows/build-shared.yml
================
name: Build-Shared

on:
  push:
  pull_request:

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]

    runs-on: ${{ matrix.os }}
    
    env:
      CONAN_USER_HOME: "${{ github.workspace }}/release"
      CONAN_USER_HOME_SHORT: "${{ github.workspace }}/release/short"
      INSTALL_DIR: ${{ github.workspace }}/install/
      
    steps:
      - name: Perform checkout
        uses: actions/checkout@v4
        
      - name: Install Python environment 
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
        
      - name: Install conan
        run: |
            pip install conan --upgrade
            conan profile detect --force
                    
      - name: Linux build
        if: matrix.os == 'ubuntu-latest'
        run: |
            mkdir -p build && cd build
            conan install .. --output-folder=. --build=missing
            cmake .. -DBUILD_TESTING=TRUE -DBUILD_SHARED_LIBS=TRUE -DCMAKE_BUILD_TYPE=Release
            cmake --build . --config Release --target install
            
      - name: Mac build
        if: matrix.os == 'macos-latest'
        run: |
            mkdir -p build && cd build
            conan install .. --output-folder=. --build=missing
            cmake .. -DBUILD_TESTING=TRUE -DBUILD_SHARED_LIBS=TRUE -DCMAKE_BUILD_TYPE=Release
            cmake --build . --config Release --target install
            
      - name: Windows build
        if: matrix.os == 'windows-latest'
        run: |
            md build && cd build
            conan install .. --output-folder=. --build=missing
            cmake .. -DBUILD_TESTING=TRUE -DBUILD_SHARED_LIBS=TRUE -DCMAKE_BUILD_TYPE=Release
            cmake --build . --config Release --target install

================
File: .github/workflows/build-static.yml
================
name: Build-Static

on:
  push:
  pull_request:

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]

    runs-on: ${{ matrix.os }}
    
    env:
      CONAN_USER_HOME: "${{ github.workspace }}/release"
      CONAN_USER_HOME_SHORT: "${{ github.workspace }}/release/short"
      INSTALL_DIR: ${{ github.workspace }}/install/
      
    steps:
      - name: Perform checkout
        uses: actions/checkout@v4
        
      - name: Install Python environment 
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
        
      - name: Install conan
        run: |
            pip install conan --upgrade
            conan profile detect --force
                    
      - name: Linux build
        if: matrix.os == 'ubuntu-latest'
        run: |
            mkdir -p build && cd build
            conan install .. --output-folder=. --build=missing
            cmake .. -DBUILD_TESTING=TRUE -DBUILD_SHARED_LIBS=FALSE -DCMAKE_BUILD_TYPE=Release
            cmake --build . --config Release --target install
            
      - name: Mac build
        if: matrix.os == 'macos-latest'
        run: |
            mkdir -p build && cd build
            conan install .. --output-folder=. --build=missing
            cmake .. -DBUILD_TESTING=TRUE -DBUILD_SHARED_LIBS=FALSE -DCMAKE_BUILD_TYPE=Release
            cmake --build . --config Release --target install
            
      - name: Windows build
        if: matrix.os == 'windows-latest'
        run: |
            md build && cd build
            conan install .. --output-folder=. --build=missing
            cmake .. -DBUILD_TESTING=TRUE -DBUILD_SHARED_LIBS=FALSE -DCMAKE_BUILD_TYPE=Release
            cmake --build . --config Release --target install

================
File: .github/FUNDING.yml
================
# These are supported funding model platforms

github: madduci

================
File: cmake/clang_format.cmake
================
# MIT License 
# Copyright (c) 2018-Today Michele Adduci <adduci@tutanota.com>
#
# Clang-Format instructions

find_program(CLANG_FORMAT_BIN NAMES clang-format)

if(CLANG_FORMAT_BIN)
  message(STATUS "Found: clang-format")
  
  file(GLOB_RECURSE ALL_SOURCE_FILES 
    ${PROJECT_SOURCE_DIR}/project/*.cpp
    ${PROJECT_SOURCE_DIR}/project/*.h
    ${PROJECT_SOURCE_DIR}/project/*.hpp
  )

  add_custom_target(
    format
    COMMAND ${CLANG_FORMAT_BIN}
    -i
    --style=file
    ${ALL_SOURCE_FILES}
  )

  add_custom_target(
    format-check
    COMMAND ${CLANG_FORMAT_BIN}
    --style=file
    --dry-run
    --Werror
    ${ALL_SOURCE_FILE}
  )

  add_custom_target(
    format-all
    COMMAND ${CMAKE_COMMAND} --build ${CMAKE_BINARY_DIR} --target format
    COMMENT "Running clang-format on all source files"
  )
else()
  message(STATUS "clang-format not found. Formatting targets will not be available.")
endif()

================
File: cmake/clang_tidy.cmake
================
# Find clang-tidy executable
find_program(CLANG_TIDY_BIN NAMES clang-tidy)

if(CLANG_TIDY_BIN)
    message(STATUS "Found: clang-tidy")
    
    # Don't set CMAKE_CXX_CLANG_TIDY - we don't want it running on every build
    
    # Get all source files
    file(GLOB_RECURSE ALL_SOURCE_FILES 
        ${PROJECT_SOURCE_DIR}/project/*.cpp
        ${PROJECT_SOURCE_DIR}/project/*.h
        ${PROJECT_SOURCE_DIR}/project/*.hpp
    )

    # Create a custom target for running clang-tidy
    add_custom_target(
        tidy
        COMMAND ${CLANG_TIDY_BIN}
            -p=${CMAKE_BINARY_DIR}
            ${ALL_SOURCE_FILES}
            > ${CMAKE_BINARY_DIR}/clang-tidy-report.txt
        COMMENT "Running clang-tidy and generating report..."
        VERBATIM
    )

    # Add a target to show the report
    add_custom_target(
        tidy-report
        COMMAND ${CMAKE_COMMAND} -E cat ${CMAKE_BINARY_DIR}/clang-tidy-report.txt
        DEPENDS tidy
        COMMENT "Showing clang-tidy report..."
    )
else()
    message(STATUS "clang-tidy not found. Tidy targets will not be available.")
endif()

================
File: cmake/compiler_options.cmake
================
# MIT License 
# Copyright (c) 2018-Today Michele Adduci <adduci@tutanota.com>
#
# Compiler options with hardening flags

if(MSVC)
    list(APPEND compiler_options 
        /W4
        /WX
        /permissive-
        $<$<CONFIG:RELEASE>:/O2 /Ob2 >
        $<$<CONFIG:MINSIZEREL>:/O1 /Ob1>
        $<$<CONFIG:RELWITHDEBINFO>:/Zi /O2 /Ob1>
        $<$<CONFIG:DEBUG>:/Zi /Ob0 /Od /RTC1>)

    list(APPEND compiler_definitions
        _UNICODE
        WINDOWS
        $<$<OR:$<CONFIG:RELEASE>,$<CONFIG:RELWITHDEBINFO>,$<CONFIG:MINSIZEREL>>:NDEBUG>
        $<$<CONFIG:DEBUG>:_DEBUG>)

    list(APPEND linker_flags
        $<$<BOOL:${BUILD_SHARED_LIBS}>:/LTCG>
    )

    set(MSVC_RUNTIME_TYPE $<IF:$<BOOL:${BUILD_WITH_MT}>,MultiThreaded$<$<CONFIG:Debug>:Debug>,MultiThreaded$<$<CONFIG:Debug>:Debug>>DLL)

else(MSVC)
    # Enhanced warning flags for GCC/Clang
    list(APPEND compiler_options 
        -Wall
        -Wextra
        -Wpedantic
        -Werror=return-type
        -Werror=uninitialized
        -Werror=maybe-uninitialized
        -Wconversion
        -Wsign-conversion
        -Wcast-align
        -Wcast-qual
        -Wdisabled-optimization
        -Wformat=2
        -Winit-self
        -Wlogical-op
        -Wmissing-include-dirs
        -Wnoexcept
        -Wold-style-cast
        -Woverloaded-virtual
        -Wredundant-decls
        -Wshadow
        -Wsign-promo
        -Wstrict-null-sentinel
        -Wstrict-overflow=5
        -Wswitch-default
        -Wundef
        $<$<CXX_COMPILER_ID:GNU>:-Wuseless-cast>
        -Wno-unknown-pragmas
        $<$<CONFIG:DEBUG>:-fno-omit-frame-pointer>
        $<$<CONFIG:DEBUG>:-O0 -g3>
        $<$<CONFIG:RELEASE>:-O3>
    )

    # Enhanced security flags
    list(APPEND compiler_definitions
        $<$<OR:$<CONFIG:RELEASE>,$<CONFIG:MINSIZEREL>>:_FORTIFY_SOURCE=2>
    )
 
    list(APPEND linker_flags
        $<$<NOT:$<CXX_COMPILER_ID:AppleClang>>:-Wl,-z,defs>
        $<$<NOT:$<CXX_COMPILER_ID:AppleClang>>:-Wl,-z,now>
        $<$<NOT:$<CXX_COMPILER_ID:AppleClang>>:-Wl,-z,relro>
        $<$<AND:$<NOT:$<CXX_COMPILER_ID:AppleClang>>,$<NOT:$<CXX_COMPILER_ID:Clang>>,$<NOT:$<BOOL:${BUILD_SHARED_LIBS}>>>:-Wl,-pie>
        $<$<AND:$<NOT:$<CXX_COMPILER_ID:AppleClang>>,$<NOT:$<CXX_COMPILER_ID:Clang>>,$<NOT:$<BOOL:${BUILD_SHARED_LIBS}>>>:-fpie>
        $<$<AND:$<NOT:$<CXX_COMPILER_ID:AppleClang>>,$<NOT:$<CXX_COMPILER_ID:Clang>>,$<NOT:$<BOOL:${BUILD_SHARED_LIBS}>>>:-pipe>
        $<$<AND:$<NOT:$<CXX_COMPILER_ID:AppleClang>>,$<NOT:$<CXX_COMPILER_ID:Clang>>,$<NOT:$<BOOL:${BUILD_SHARED_LIBS}>>>:-static-libstdc++>
        $<$<CONFIG:DEBUG>:-fno-omit-frame-pointer>
        $<$<CONFIG:DEBUG>:-fsanitize=address>
        $<$<CONFIG:DEBUG>:-fsanitize=leak>
        $<$<CONFIG:DEBUG>:-fsanitize=undefined>
        $<$<AND:$<NOT:$<CXX_COMPILER_ID:AppleClang>>,$<NOT:$<CXX_COMPILER_ID:Clang>>>:-fstack-clash-protection>
        $<$<AND:$<NOT:$<CXX_COMPILER_ID:AppleClang>>,$<NOT:$<CXX_COMPILER_ID:Clang>>>:-fbounds-check>
        -fstack-protector
        -fPIC
    )

endif()

# Make sure the options are actually applied to targets
function(target_enable_warnings target_name)
    if(MSVC)
        target_compile_options(${target_name} PRIVATE ${compiler_options})
    else()
        target_compile_options(${target_name} PRIVATE ${compiler_options})
    endif()
endfunction()

================
File: cmake/cpack.cmake
================
# MIT License 
# Copyright (c) 2018-Today Michele Adduci <adduci@tutanota.com>
#
# Packaging instructios

set(CPACK_PACKAGE_VENDOR "Michele Adduci <adduci@tutanota.com>")
set(CPACK_PACKAGE_VERSION_MAJOR "${CMAKE_PROJECT_VERSION_MAJOR}")
set(CPACK_PACKAGE_VERSION_MINOR "${CMAKE_PROJECT_VERSION_MINOR}")
set(CPACK_PACKAGE_VERSION_PATCH "${CMAKE_PROJECT_VERSION_PATCH}")
set(CPACK_GENERATOR "ZIP;TGZ")
set(CPACK_STRIP_FILES "TRUE")

include(CPack)

================
File: cmake/cppcheck.cmake
================
# Find clang-tidy executable
find_program(CPPCHECK_BIN NAMES cppcheck)

if(CPPCHECK_BIN)
    message(STATUS "Found: cppcheck")
    
    # Existing configuration for build-time checks
    list(
        APPEND CMAKE_CXX_CPPCHECK 
            "${CPPCHECK_BIN}"
            "--enable=all"
            "--enable=warning,performance,portability,information,missingInclude"
            "--inconclusive"
            "--check-config"
            "--force" 
            "--inline-suppr"
            "--suppressions-list=${CMAKE_SOURCE_DIR}/cppcheck_suppressions.txt"
            "--xml"
            "--output-file=${CMAKE_BINARY_DIR}/cppcheck.xml"
    )

    # Add custom target for explicit cppcheck runs
    add_custom_target(
        cppcheck-analysis
        COMMAND ${CPPCHECK_BIN}
            --enable=all
            --enable=missingInclude
            --std=c++17
            --error-exitcode=1
            --suppress=missingInclude
            -i${CMAKE_SOURCE_DIR}/build
            ${PROJECT_SOURCE_DIR}/project
        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
        COMMENT "Running cppcheck analysis"
    )

else()
    message(STATUS "cppcheck not found. Analysis targets will not be available.")
endif()

================
File: cmake/dependencies.cmake
================
# MIT License 
# Copyright (c) 2018-Today Michele Adduci <adduci@tutanota.com>
#
# Dependencies

# Required for Testing
if(BUILD_TESTING)
  find_package(doctest REQUIRED)
endif()

# Optional Dependency, doesn't trigger error if missing
find_package(OpenSSL)

================
File: project/HC-MC/include/HC-MC.hpp
================
#pragma once

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Weverything"
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wall"
#pragma GCC diagnostic ignored "-Wextra"
#pragma GCC diagnostic ignored "-Wold-style-cast"
#pragma GCC diagnostic ignored "-Wsign-conversion"
#pragma GCC diagnostic ignored "-Wundef"
#pragma GCC diagnostic ignored "-Wuseless-cast"
#pragma GCC diagnostic ignored "-Wunused-parameter"

// Add more GCC-specific warnings you want to ignore here
#endif

#include <Eigen/Dense>
#include <cppad/cppad.hpp>
#include <cppad/example/cppad_eigen.hpp>  // Add this line

#ifdef __clang__
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#endif

#include <iomanip>
#include <iostream>
#include <optional>
#include <random>
#include <string>

// Type aliases to improve readability
template <typename Base>
using AD = CppAD::AD<Base>;
using ADDouble = AD<double>;

template <typename T>
using Vector = Eigen::Matrix<T, Eigen::Dynamic, 1>;
template <typename T>
using Matrix = Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>;

using ADVector = Vector<ADDouble>;
using DoubleVector = Vector<double>;

// Helper type trait to get base type
template <typename T>
struct BaseType {
  using type = T;
};

template <typename Base>
struct BaseType<AD<Base>> {
  using type = Base;
};

// Configuration and result structures
struct SolveOptions {
  bool debug = false;
  double tolerance = 1e-12;
  int maxIterations = 100;
  int maxSteps = 1000;
  double initialStepSize = 0.01;
  bool verifyDerivatives = false;
};

struct SolveResult {
  ADVector solution;
  double residualNorm;
  int iterations;
  bool success;
  std::string message;
};

inline Eigen::VectorXd toDoubleVector(const ADVector& ad_vec) {
  Eigen::VectorXd vec(ad_vec.size());
  for (auto i = 0; i < ad_vec.size(); ++i) {
    vec(i) = CppAD::Value(ad_vec(i));
  }
  return vec;
}

namespace detail {
// Helper function to convert any type to double
template <typename T>
double toDouble(const T& x) {
  if constexpr (std::is_same_v<T, ADDouble>) {
    return CppAD::Value(x);
  } else {
    return x;
  }
}

// Random vector generator in [-1,1]
template <typename T>
Vector<T> randomVector(int size) {
  static std::random_device rd;
  static std::mt19937 gen(rd());
  static std::uniform_real_distribution<double> dis(-1.0, 1.0);

  Vector<T> result(size);
  for (auto i = 0; i < size; ++i) {
    result(i) = T(dis(gen));
  }
  return result;
}

// Helper to evaluate vector function and get sizes
template <typename Func>
std::pair<int, int> getFunctionDimensions(const Func& F,
                                          const ADVector& x_test) {
  // Use the provided test vector to evaluate F
  auto y = F(x_test);
  return {x_test.size(), y.size()};
}

// Compute finite difference Jacobian for verification
template <typename F>
Matrix<double> finiteDiffJacobian(const F& func, const ADVector& x,
                                  double eps = 1e-8) {
  auto n = x.size();
  ADVector x_plus = x;
  auto f0 = func(x);
  auto m = f0.size();
  Matrix<double> jac(m, n);

  for (int j = 0; j < n; ++j) {
    x_plus = x;
    x_plus(j) += eps;
    auto f1 = func(x_plus);

    for (int i = 0; i < m; ++i) {
      jac(i, j) = (toDouble(f1(i)) - toDouble(f0(i))) / eps;
    }
  }
  return jac;
}

// Compare Jacobians with detailed output
inline bool compareJacobians(const Matrix<double>& J1, const Matrix<double>& J2,
                             const std::string& context, double tol = 1e-6) {
  double max_diff = 0.0;
  int max_i = 0;
  int max_j = 0;

  for (int i = 0; i < J1.rows(); ++i) {
    for (int j = 0; j < J1.cols(); ++j) {
      const double diff = std::abs(J1(i, j) - J2(i, j));
      if (diff > max_diff) {
        max_diff = diff;
        max_i = i;
        max_j = j;
      }
      if (diff > tol) {
        std::cout << context << ": Large difference at (" << i << "," << j
                  << "):\n"
                  << "AD: " << J1(i, j) << "\n"
                  << "FD: " << J2(i, j) << "\n"
                  << "Diff: " << diff << "\n";
        return false;
      }
    }
  }

  if (max_diff > 0) {
    std::cout << context << ": Maximum difference: " << max_diff << " at ("
              << max_i << "," << max_j << ")\n";
  }
  return true;
}
}  // namespace detail

template <typename FuncF, typename FuncG>
class HFunction {
 public:
  HFunction(const FuncF& F_in, const FuncG& G_in) : F(F_in), G(G_in) {}

  template <typename T>
  Vector<T> operator()(const Vector<T>& X, const T& t) const {
    auto f_val = F(X);
    auto g_val = G(X);
    return (T(1.0) - t) * g_val + t * f_val;
  }

  template <typename T>
  [[nodiscard]] Vector<T> dH_dt(const Vector<T>& X) const {
    return F(X) - G(X);
  }

 private:
  const FuncF& F;
  const FuncG& G;
};

template <typename FuncF, typename FuncG>
class PathTracker {
 public:
  PathTracker(const FuncF& f, const FuncG& g, const SolveOptions& options_pack)
      : F(f), G(g), H_func(F, G), options(options_pack) {}

  std::optional<SolveResult> track(const ADVector& X_in,
                                   const ADDouble& t_start,
                                   const ADDouble& t_end,
                                   const ADDouble& dt_init) {
    ADVector X = X_in;
    ADDouble t = t_start;
    ADDouble dt = dt_init;
    const double min_dt = detail::toDouble(dt_init) * 1e-8;  // TODO (orebas)
                                                             // magic number
    int total_iterations = 0;

    while (detail::toDouble(t) < detail::toDouble(t_end) &&
           total_iterations < options.maxSteps) {
      // Adjust step size if we're close to the end
      ADDouble dt_current = dt;
      if (detail::toDouble(t + dt) > detail::toDouble(t_end)) {
        dt_current = t_end - t;
      }

      const ADDouble t_new = t + dt_current;
      // Predictor step: Compute dX/dt
      const ADVector H_t = H_func.dH_dt(X);
      const Eigen::MatrixXd JH = computeJacobian(X, t);

      // Convert H_t to Eigen::VectorXd
      const Eigen::VectorXd H_t_double = toDoubleVector(H_t);

      // Solve for dX_dt
      const Eigen::VectorXd dX_dt = -JH.fullPivLu().solve(H_t_double);

      // Predictor: X_pred = X + dt_current * dX_dt
      const ADVector X_pred = X + (dt_current * dX_dt).cast<ADDouble>();

      // Corrector step: Refine X_pred at t_new
      auto X_corrected_opt = correctPrediction(X_pred, t_new);
      if (!X_corrected_opt.has_value()) {
        // Reduce step size and retry
        dt *= 0.5;
        if (detail::toDouble(dt) < min_dt) {
          if (options.debug) {
            std::cerr << "Step size too small. Terminating.\n";
          }
          break;
        }
        continue;
      }

      // Update X and t
      X = X_corrected_opt.value();
      t = t_new;
      total_iterations++;

      // Increase step size for next iteration
      dt = std::min(dt * 1.2, ADDouble(options.initialStepSize));

      if (options.debug) {
        std::cout << "Step " << total_iterations << ": t = " << t
                  << ", Residual norm = "
                  << detail::toDouble(H_func(X, t).norm()) << "\n";
      }
    }

    // Check if we reached the end
    if (detail::toDouble(t) < detail::toDouble(t_end)) {
      return std::nullopt;
    }

    SolveResult result;
    result.solution = X;
    result.residualNorm = detail::toDouble(F(X).norm());
    result.iterations = total_iterations;
    result.success = true;
    result.message = "Solution found";

    return result;
  }

 private:
  const FuncF& F;
  const FuncG& G;
  HFunction<FuncF, FuncG> H_func;
  SolveOptions options;

  Eigen::MatrixXd computeJacobian(const ADVector& X, const ADDouble& t) {
    using namespace CppAD;
    const long n = X.size();

    ADVector X_ad = X;  // Eigen::Matrix<ADDouble>

    // Declare independent variables
    Independent(X_ad);

    const ADVector H_X = H_func(X_ad, t);

    // Create the function object
    ADFun<double> func(X_ad, H_X);

    // Evaluate Jacobian at the current point
    std::vector<double> x_vec(n);
    for (long i = 0; i < n; ++i) {
      x_vec[i] = Value(X[i]);  // Use CppAD::Value to extract double
    }

    std::vector<double> jac_vec = func.Jacobian(x_vec);

    // Fill the EigenMatrix with the Jacobian values
    Eigen::MatrixXd jac(H_X.size(), n);
    for (long i = 0; i < H_X.size(); ++i) {
      for (long j = 0; j < n; ++j) {
        jac(i, j) = jac_vec[i * n + j];
      }
    }

    // Optional: Verify derivatives
    if (options.verifyDerivatives) {
      // Create a lambda that captures the current t value
      auto H_at_t = [this, t](const ADVector& X_) {
        return this->H_func(X_, t);
      };

      auto fd_jac = detail::finiteDiffJacobian(H_at_t, X);

      // Convert AD Jacobian to double for comparison
      const Eigen::MatrixXd jac_double = jac;

      std::stringstream context;
      context << "Jacobian verification at t=" << Value(t);
      detail::compareJacobians(jac_double, fd_jac, context.str());
    }

    return jac;
  }
  std::optional<ADVector> correctPrediction(const ADVector& X_pred,
                                            const ADDouble& t_new) {
    ADVector X = X_pred;
    for (int iter = 0; iter < options.maxIterations; ++iter) {
      const ADVector H_X = H_func(X, t_new);
      const double residual = detail::toDouble(H_X.norm());

      if (residual < options.tolerance) {
        return X;
      }

      // Compute Jacobian
      const Eigen::MatrixXd JH = computeJacobian(X, t_new);

      // Convert H_X to Eigen::VectorXd
      const Eigen::VectorXd H_X_double = toDoubleVector(H_X);

      // Solve for update
      const Eigen::VectorXd delta_X = -JH.fullPivLu().solve(H_X_double);

      // Update X
      X = X + delta_X.cast<ADDouble>();

      if (options.debug) {
        std::cout << "Corrector Iter " << iter << ": Residual = " << residual
                  << "\n";
      }

      if (delta_X.norm() < options.tolerance) {
        return X;
      }
    }

    // Did not converge
    return std::nullopt;
  }
};
// Main solve function
template <typename Func>
std::optional<SolveResult> solve(const Func& F,
                                 int input_dim,  // New parameter
                                 const SolveOptions& options = SolveOptions{}) {
  // Generate random starting point with correct dimension
  const ADVector X0 = detail::randomVector<ADDouble>(input_dim);

  // Get output dimension
  auto [n_in, n_out] = detail::getFunctionDimensions(F, X0);

  // Verify dimensions match
  if (n_in != input_dim) {
    throw std::invalid_argument("Function input dimension mismatch");
  }

  // Create G(x) = F(x) - F(X0)
  auto F_X0 = F(X0);
  auto G = [&F, &F_X0](const ADVector& x) -> ADVector { return F(x) - F_X0; };

  // Create the path tracker
  PathTracker<Func, decltype(G)> tracker(F, G, options);

  // Track from t=0 (G) to t=1 (F)
  return tracker.track(X0, ADDouble(0.0), ADDouble(1.0),
                       ADDouble(options.initialStepSize));
}

// Overload without explicit dimension - try to deduce from a test evaluation
template <typename Func>
std::optional<SolveResult> solve(const Func& F,
                                 const SolveOptions& options = SolveOptions{}) {
  // Try with dimension 1 first
  try {
    const ADVector x_test = detail::randomVector<ADDouble>(1);
    auto y = F(x_test);
    return solve(F, 1, options);
  } catch (...) {
    // Try with dimension 2 if that fails
    try {
      const ADVector x_test = detail::randomVector<ADDouble>(2);
      auto y = F(x_test);
      return solve(F, 2, options);
    } catch (...) {
      // If both fail, require explicit dimension
      throw std::invalid_argument(
          "Could not automatically determine function dimension. "
          "Please provide input dimension explicitly using solve(F, dimension, "
          "options).");
    }
  }
}

template <typename Func>
std::optional<SolveResult> solve_newton(
    const Func& F, int input_dim,
    const SolveOptions& options = SolveOptions{}) {
  // Generate random starting point with correct dimension
  const ADVector X0 = detail::randomVector<ADDouble>(input_dim);

  // Get output dimension
  auto [n_in, n_out] = detail::getFunctionDimensions(F, X0);

  // Verify dimensions match
  if (n_in != input_dim) {
    throw std::invalid_argument("Function input dimension mismatch");
  }

  ADVector X = X0;
  int iterations = 0;

  while (iterations < options.maxIterations) {
    // Evaluate function at current point
    const ADVector F_X = F(X);
    const double residual_norm = detail::toDouble(F_X.norm());

    if (residual_norm < options.tolerance) {
      SolveResult result;
      result.solution = X;
      result.residualNorm = residual_norm;
      result.iterations = iterations;
      result.success = true;
      result.message = "Converged successfully";
      return result;
    }

    // Compute Jacobian using CppAD
    using namespace CppAD;
    const long n = X.size();

    ADVector X_ad = X;
    Independent(X_ad);
    const ADVector F_X_ad = F(X_ad);
    ADFun<double> func(X_ad, F_X_ad);

    // Convert current point to std::vector<double>
    std::vector<double> x_vec(n);
    for (long i = 0; i < n; ++i) {
      x_vec[i] = Value(X[i]);
    }

    // Evaluate Jacobian
    std::vector<double> jac_vec = func.Jacobian(x_vec);

    // Convert Jacobian to Eigen matrix
    Eigen::MatrixXd J(F_X.size(), n);
    for (long i = 0; i < F_X.size(); ++i) {
      for (long j = 0; j < n; ++j) {
        J(i, j) = jac_vec[i * n + j];
      }
    }

    // Optional derivative verification
    if (options.verifyDerivatives) {
      auto fd_jac = detail::finiteDiffJacobian(F, X);
      std::stringstream context;
      context << "Newton iteration " << iterations;
      detail::compareJacobians(J, fd_jac, context.str());
    }

    // Solve linear system for Newton step
    const Eigen::VectorXd F_X_double = toDoubleVector(F_X);
    const Eigen::VectorXd delta = -J.fullPivLu().solve(F_X_double);

    // Update X
    X = X + delta.cast<ADDouble>();

    if (options.debug) {
      std::cout << "Newton iteration " << iterations
                << ": Residual = " << residual_norm << "\n";
    }

    // Check if step size is small enough to declare convergence
    if (delta.norm() < options.tolerance) {
      SolveResult result;
      result.solution = X;
      result.residualNorm = residual_norm;
      result.iterations = iterations;
      result.success = true;
      result.message = "Converged via small step size";
      return result;
    }

    ++iterations;
  }

  // Failed to converge
  SolveResult result;
  result.solution = X;
  result.residualNorm = detail::toDouble(F(X).norm());
  result.iterations = iterations;
  result.success = false;
  result.message = "Failed to converge within maximum iterations";
  return result;
}

// Overload without explicit dimension - try to deduce from a test evaluation
template <typename Func>
std::optional<SolveResult> solve_newton(
    const Func& F, const SolveOptions& options = SolveOptions{}) {
  // Try with dimension 1 first
  try {
    const ADVector x_test = detail::randomVector<ADDouble>(1);
    auto y = F(x_test);
    return solve_newton(F, 1, options);
  } catch (...) {
    // Try with dimension 2 if that fails
    try {
      const ADVector x_test = detail::randomVector<ADDouble>(2);
      auto y = F(x_test);
      return solve_newton(F, 2, options);
    } catch (...) {
      // If both fail, require explicit dimension
      throw std::invalid_argument(
          "Could not automatically determine function dimension. "
          "Please provide input dimension explicitly using solve_newton(F, "
          "dimension, options).");
    }
  }
}

================
File: project/HC-MC/tests/pt_tests.cpp
================
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include <doctest/doctest.h>

#include <Eigen/Dense>
#include <cmath>
#include <iostream>
#include <string>

#include "HC-MC.hpp"

// Helper function to print vectors nicely
void print_vector(const ADVector& v, const std::string& name) {
  std::cout << name << " = [";
  for (int i = 0; i < v.size(); ++i) {
    std::cout << std::setprecision(15) << CppAD::Value(v(i));
    if (i < v.size() - 1) {
      std::cout << ", ";
    }
  }
  std::cout << "]" << "\n";
}

TEST_CASE("Circle-Line Intersection") {
  auto F = [](const ADVector& X) {
    ADVector result(2);
    result(0) = X(0) * X(0) + X(1) * X(1) - 4.0;  // Circle of radius 2
    result(1) = X(0) + X(1) - 1.0;                // Line x + y = 1
    return result;
  };

  SolveOptions options;
  options.debug = true;
  options.tolerance = 1e-10;

  auto result = solve(F, options);
  REQUIRE(result.has_value());

  const auto& solve_result = *result;
  REQUIRE(solve_result.success);
  REQUIRE(solve_result.residualNorm < 1e-8);

  // Verify the solution satisfies the system
  const auto& X = solve_result.solution;
  auto F_X = F(X);
  print_vector(X, "Solution");
  print_vector(F_X, "F(solution)");

  // Check both equations are satisfied
  REQUIRE(std::abs(CppAD::Value(F_X(0))) < 1e-8);  // Circle equation
  REQUIRE(std::abs(CppAD::Value(F_X(1))) < 1e-8);  // Line equation

  // Verify solution matches one of the two expected points
  double x = CppAD::Value(X(0));
  double y = CppAD::Value(X(1));
  bool matches_solution =
      (std::abs(x + y - 1.0) < 1e-8) &&        // Line equation
      (std::abs(x * x + y * y - 4.0) < 1e-8);  // Circle equation

  REQUIRE(matches_solution);
}

TEST_CASE("Parabola-Line Intersection") {
  auto F = [](const ADVector& X) {
    ADVector result(2);
    result(0) = X(0) * X(0) - X(1);  // Parabola y = x^2
    result(1) = X(1) - 4.0;          // Line y = 4
    return result;
  };

  SolveOptions options;
  options.debug = false;

  auto result = solve(F);
  REQUIRE(result.has_value());

  const auto& solve_result = *result;
  REQUIRE(solve_result.success);
  REQUIRE(solve_result.residualNorm < 1e-8);

  // Verify solution satisfies both equations
  const auto& X = solve_result.solution;
  double x = CppAD::Value(X(0));
  double y = CppAD::Value(X(1));

  REQUIRE(std::abs(x * x - y) < 1e-8);  // Parabola equation
  REQUIRE(std::abs(y - 4.0) < 1e-8);    // Line equation

  // The solution should be either (2,4) or (-2,4)
  bool is_valid_solution =
      (std::abs(std::abs(x) - 2.0) < 1e-8) && (std::abs(y - 4.0) < 1e-8);
  REQUIRE(is_valid_solution);
}

TEST_CASE("3D Sphere-Plane-Line Intersection") {
  auto F = [](const ADVector& X) {
    ADVector result(3);
    result(0) =
        X(0) * X(0) + X(1) * X(1) + X(2) * X(2) - 4.0;  // Sphere radius 2
    result(1) = X(0) + X(1) + X(2) - 1.0;               // Plane x+y+z=1
    result(2) = X(0) - X(1);                            // Line x=y
    return result;
  };

  SolveOptions options;
  options.debug = false;
  options.tolerance = 1e-10;

  auto result = solve(F);
  REQUIRE(result.has_value());

  const auto& solve_result = *result;
  REQUIRE(solve_result.success);
  REQUIRE(solve_result.residualNorm < 1e-8);

  // Verify solution satisfies all equations
  const auto& X = solve_result.solution;
  const double x = CppAD::Value(X(0));
  const double y = CppAD::Value(X(1));
  const double z = CppAD::Value(X(2));

  REQUIRE(std::abs(x * x + y * y + z * z - 4.0) < 1e-8);  // Sphere
  REQUIRE(std::abs(x + y + z - 1.0) < 1e-8);              // Plane
  REQUIRE(std::abs(x - y) < 1e-8);                        // Line
}

TEST_CASE("System with Transcendental Functions") {
  auto F = [](const ADVector& X) {
    ADVector result(2);
    result(0) = CppAD::cos(X(0)) - X(1);  // cos(x) = y
    result(1) = X(0) * X(1) - 0.5;        // xy = 0.5
    return result;
  };

  SolveOptions options;
  options.debug = false;
  options.verifyDerivatives = true;  // Test derivative computation

  auto result = solve(F);
  REQUIRE(result.has_value());

  const auto& solve_result = *result;
  REQUIRE(solve_result.success);
  REQUIRE(solve_result.residualNorm < 1e-8);

  // Verify solution satisfies both equations
  const auto& X = solve_result.solution;
  const double x = CppAD::Value(X(0));
  const double y = CppAD::Value(X(1));

  REQUIRE(std::abs(std::cos(x) - y) < 1e-8);
  REQUIRE(std::abs(x * y - 0.5) < 1e-8);
}

TEST_CASE("Higher Dimensional System") {
  auto F = [](const ADVector& X) {
    ADVector result(4);
    result(0) = X(0) * X(0) * X(0) + CppAD::sin(X(1)) - 1.0;
    result(1) = X(0) * X(0) + X(1) * X(1) + X(2) * X(2) + X(3) * X(3) - 5.0;
    result(2) = X(0) + X(1) + X(2) + CppAD::pow(X(3), 5) + 2.5;
    result(3) = CppAD::sin(X(0)) + CppAD::exp(X(1)) +
                CppAD::cos(X(1)) * X(2) * X(2) * X(2) + 2.0;
    return result;
  };

  SolveOptions options;
  options.debug = true;
  options.maxIterations = 200;  // This system might need more iterations

  auto result = solve(F);
  REQUIRE(result.has_value());

  const auto& solve_result = *result;
  REQUIRE(solve_result.success);
  REQUIRE(solve_result.residualNorm < 1e-8);

  // Verify each equation is satisfied
  const auto& X = solve_result.solution;
  auto F_X = F(X);
  for (int i = 0; i < F_X.size(); ++i) {
    REQUIRE(std::abs(CppAD::Value(F_X(i))) < 1e-8);
  }
}

int unused_main(int argc, char** argv) {
  doctest::Context context;
  context.applyCommandLine(argc, argv);

  const int result = context.run();

  if (context.shouldExit()) {
    return result;
  }

  return result;
}

================
File: project/HC-MC/CMakeLists.txt
================
cmake_minimum_required(VERSION 3.15)
project(HC-MC)

#####################################
# Define Target Information
#####################################
set(TARGET_NAME HC-MC)
set(TARGET_INCLUDE_FOLDER ${CMAKE_CURRENT_SOURCE_DIR}/include)

# Find dependencies
find_package(PkgConfig REQUIRED)
find_package(doctest CONFIG REQUIRED)

# Locate CppAD using pkg-config
pkg_check_modules(CPPAD REQUIRED cppad)

# Header-only library target
add_library(${TARGET_NAME} INTERFACE)
target_include_directories(${TARGET_NAME} 
    INTERFACE 
        ${TARGET_INCLUDE_FOLDER}
        ${CPPAD_INCLUDE_DIRS}
)

# Link against required dependencies
target_link_libraries(${TARGET_NAME} 
    INTERFACE 
        Eigen3::Eigen
        ${CPPAD_LIBRARIES}
)

#####################################
# Add Main Executable
#####################################
add_executable(${TARGET_NAME}_main
    main.cpp
)

# Enable warnings for the executable
target_enable_warnings(${TARGET_NAME}_main)

# Link main executable with the library and required dependencies
target_link_libraries(${TARGET_NAME}_main
    PRIVATE
        ${TARGET_NAME}
        Eigen3::Eigen
        ${CPPAD_LIBRARIES}
)

#####################################
# Tests
#####################################
if(BUILD_TESTING)
    # Create test executable
    add_executable(${TARGET_NAME}_tests 
        tests/pt_tests.cpp
    )
    
    # Enable warnings for the test executable
    target_enable_warnings(${TARGET_NAME}_tests)
    
    # Link against our library and doctest
    target_link_libraries(${TARGET_NAME}_tests 
        PRIVATE 
            ${TARGET_NAME}
            doctest::doctest
    )
    
    # Add to CTest
    add_test(
        NAME ${TARGET_NAME}_tests 
        COMMAND ${TARGET_NAME}_tests
    )
endif()

================
File: project/HC-MC/main.cpp
================
#include <boost/numeric/odeint.hpp>
#include <functional>
#include <iostream>
#include <vector>

#include "HC-MC.hpp"

using namespace boost::numeric::odeint;

template <typename T>
using Vector = Eigen::Matrix<T, Eigen::Dynamic, 1>;

// Define AD types as used in HC-MC.hpp
using ADDouble = CppAD::AD<double>;
using ADVector = Vector<ADDouble>;

// Template the state type and system for AD compatibility
template <typename T>
using state_vector = std::vector<T>;
template <typename T>
using parameter_vector = std::vector<T>;
template <typename T>
using observable_vector = std::vector<T>;

// ODE system class
template <typename T, typename StateFunctionType,
          typename ObservationFunctionType>
class ODESystem {
 public:
  // using StateFunction =
  //     std::function<void(const state_vector<T>&, state_vector<T>&, const
  //     T&)>;
  // using ObservationFunction =
  //     std::function<void(const state_vector<T>&, observable_vector<T>&)>;

  // Constructors
  ODESystem(const parameter_vector<T>& params, StateFunctionType& state_func,
            ObservationFunctionType& obs_func)
      : parameters(params),
        state_equations(state_func),
        observation_function(obs_func),
        parameter_size(params.size()),
        state_size(0),
        observable_size(0)  // Will be set when observation function is called
  {}

  // Accessors
  const parameter_vector<T>& getParameters() const { return parameters; }
  size_t getParameterSize() const { return parameter_size; }
  size_t getStateSize() const { return state_size; }
  size_t getObservableSize() const { return observable_size; }

  // Setters
  void setInitialState(const state_vector<T>& initial_state_param) {
    this->initial_state = initial_state_param;
    state_size = initial_state_param.size();
  }

  // State equations and observation function
  void operator()(const state_vector<T>& x, state_vector<T>& dxdt,
                  const T& t) const {
    state_equations(x, dxdt, parameters, t);
  }

  void operator()(const state_vector<T>& x, state_vector<T>& dxdt,
                  const parameter_vector<T>& p, const T& t) const {
    parameters = p;
    state_equations(x, dxdt, parameters, t);
  }

  void observe(const state_vector<T>& x, observable_vector<T>& y) const {
    observation_function(x, y);
    if (observable_size == 0) {
      observable_size = y.size();  // Set observable size on first call
    }
  }

  // Initial state
  const state_vector<T>& getInitialState() const { return initial_state; }

 private:
  parameter_vector<T> parameters;
  StateFunctionType state_equations;
  ObservationFunctionType observation_function;

  state_vector<T> initial_state;
  size_t parameter_size;
  size_t state_size;
  mutable size_t observable_size;
};

// Function to integrate and observe
template <typename T, typename F1, typename F2>
std::vector<observable_vector<T>> integrate_and_observe(
    const ODESystem<T, F1, F2>& system, const std::vector<T>& time_values) {
  state_vector<T> state = system.getInitialState();
  std::vector<observable_vector<T>> observables;

  auto observer = [&](const state_vector<T>& x, const T& /* t */) {
    observable_vector<T> y;
    system.observe(x, y);
    observables.push_back(y);
  };

  typedef runge_kutta4<state_vector<T>, T, state_vector<T>, T> stepper_type;
  integrate_times(stepper_type(), system, state, time_values.begin(),
                  time_values.end(), T(0.01), observer);
  return observables;
}

int main() {
  // Define the time points at which we observe the system
  std::vector<double> time_values = {0.0, 0.5, 1.0, 1.5, 2.0};

  // True parameters and initial state
  parameter_vector<double> true_params = {1.3, 1.8};
  state_vector<double> true_initial_state = {1.0, 0.5};

  // Define the state equations function
  auto state_equations =
      [](const state_vector<double>& x, state_vector<double>& dxdt,
         const parameter_vector<double>& p, const double& /* t */) {
        dxdt.resize(2);
        dxdt[0] = p[0] * x[0];
        dxdt[1] = p[1] * x[1];
      };

  // Define the observation function
  auto observation_function = [](const state_vector<double>& x,
                                 observable_vector<double>& y) {
    y.resize(2);
    y[0] = x[0];
    y[1] = x[1];
  };

  // Create the ODESystem instance
  ODESystem<double, decltype(state_equations), decltype(observation_function)>
      true_system(true_params, state_equations, observation_function);
  true_system.setInitialState(true_initial_state);

  // Generate ground truth observables
  auto ground_truth = integrate_and_observe(true_system, time_values);

  // Display ground truth data
  for (size_t i = 0; i < time_values.size(); ++i) {
    std::cout << "t = " << time_values[i] << ", Observables: ";
    for (const auto& val : ground_truth[i]) {
      std::cout << val << " ";
    }
    std::cout << "\n";
  }

  using T = ADDouble;

  // Objective function for parameter estimation
  auto parameter_objective =
      [time_values, &ground_truth](const ADVector& params) -> ADVector {
    // Extract parameters and initial state
    size_t param_size = 2;
    size_t state_size = 2;
    parameter_vector<T> p(params.data(), params.data() + param_size);
    state_vector<T> initial_state(params.data() + param_size,
                                  params.data() + param_size + state_size);

    // Define the state equations function
    auto state_equations = [](const state_vector<T>& x, state_vector<T>& dxdt,
                              const parameter_vector<T>& lp, const T& /* t */) {
      dxdt.resize(2);
      dxdt[0] = lp[0] * x[0];
      dxdt[1] = lp[1] * x[1];  //+ x[0] * T(0.1);
    };

    // Define the observation function
    auto observation_function = [](const state_vector<T>& x,
                                   observable_vector<T>& y) {
      y.resize(2);
      y[0] = x[0];
      y[1] = x[1];
    };

    // Create the ODESystem instance
    ODESystem<T, decltype(state_equations), decltype(observation_function)>
        system(p, state_equations, observation_function);
    system.setInitialState(initial_state);

    // Simulate the system
    std::vector<T> ad_time_values(time_values.begin(), time_values.end());
    auto simulated_observables = integrate_and_observe(system, ad_time_values);

    // Display current interation observations

    for (size_t i = 0; i < time_values.size(); ++i) {
      std::cout << "t = " << time_values[i] << ", Observables: ";
      for (const auto& val : simulated_observables[i]) {
        std::cout << val << " ";
      }
      std::cout << "\n";
    }

    // Calculate residuals

    auto observable_length = simulated_observables[0].size();
    // size_t total_residuals =
    //     simulated_observables.size() * 2;  // observable_size = 2
    ADVector residuals(observable_length * 2);

    size_t observable_count = simulated_observables.size();
    size_t midpoint = observable_count / 2;

    size_t idx = 0;
    size_t i = 0;
    for (size_t j = 0; j < simulated_observables[i].size(); ++j) {
      residuals[idx++] = simulated_observables[i][j] - T(ground_truth[i][j]);
    }
    i = midpoint;
    for (size_t j = 0; j < simulated_observables[i].size(); ++j) {
      residuals[idx++] = simulated_observables[i][j] - T(ground_truth[i][j]);
    }

    return residuals;
  };

  // Set solver options
  SolveOptions options;
  options.debug = true;
  options.tolerance = 1e-6;
  options.maxIterations = 50;
  options.initialStepSize = 0.1;
  options.verifyDerivatives = true;

  // Initial guess for parameters and initial state
  ADVector initial_params(4);
  initial_params[0] = 1.0;  // Guess for parameter p[0]
  initial_params[1] = 1.0;  // Guess for parameter p[1]
  initial_params[2] = 1.0;  // Guess for initial_state[0]
  initial_params[3] = 0.5;  // Guess for initial_state[1]

  // Solve the parameter estimation problem
  auto result = solve(parameter_objective, 4,  // initial_params,
                      options);

  if (result) {
    std::cout << "\nSolution found!\n";
    std::cout << "Estimated parameters: ";
    for (size_t i = 0; i < 2; ++i) {  // parameter_size = 2
      std::cout << CppAD::Value(result->solution[i]) << " ";
    }
    std::cout << "\nEstimated initial state: ";
    for (size_t i = 2; i < 4; ++i) {  // state_size = 2
      std::cout << CppAD::Value(result->solution[i]) << " ";
    }
    std::cout << "\nResidual norm: " << result->residualNorm << "\n";
    std::cout << "Iterations: " << result->iterations << "\n";
  } else {
    std::cout << "Failed to find solution\n";
  }

  return 0;
}

================
File: project/HC-MC/oldmaincpp.txt
================
#include <iomanip>
#include <iostream>

#include "HC-MC.hpp"

// Helper function to print solutions nicely
void print_solution(const SolveResult& result, const std::string& system_name) {
  std::cout << "\n=== " << system_name << " ===\n";
  std::cout << "Success: " << (result.success ? "Yes" : "No") << "\n";
  std::cout << "Residual norm: " << result.residualNorm << "\n";
  std::cout << "Iterations: " << result.iterations << "\n";
  std::cout << "Solution: [";
  for (int i = 0; i < result.solution.size(); ++i) {
    std::cout << std::setprecision(8) << CppAD::Value(result.solution(i));
    if (i < result.solution.size() - 1) std::cout << ", ";
  }
  std::cout << "]\n";
}

template <typename Func>
int run_solver(const Func& F, int dim, const std::string& system_name,
               bool newton = false) {
  // Set some solver options
  SolveOptions options;
  options.debug = false;        // Print debug information
  options.tolerance = 1e-8;     // Tight convergence tolerance
  options.maxIterations = 100;  // Maximum Newton iterations
  options.verifyDerivatives = true;

  try {
    // Solve the circle-line system with explicit dimension
    if (!newton) {
      auto result1 = solve(F, dim, options);  // 2D input
      if (result1) {
        print_solution(*result1, system_name);
      } else {
        std::cout << "No Solution!\n";
      }
    } else {
      auto result1 = solve_newton(F, dim, options);  // 2D input
      if (result1) {
        print_solution(*result1, system_name);
      } else {
        std::cout << "No Solution!\n";
      }
    }

  } catch (const std::exception& e) {
    std::cerr << "Error: " << e.what() << std::endl;
    return 1;
  }

  return 0;
}

int main() {
  std::cout << "HC-MC Example: Solving Nonlinear Systems\n";
  std::cout << "========================================\n";

  // Example 1: Circle-Line intersection
  // System: { x^2 + y^2 = 1  (unit circle)
  //        { x + y = 1     (line)
  auto circle_line = [](const ADVector& X) {
    ADVector result(2);
    result(0) = X(0) * X(0) + X(1) * X(1) - 1.0;  // Circle equation
    result(1) = X(0) + X(1) - 1.0;                // Line equation
    return result;
  };

  // Example 2: Chemical equilibrium
  // A simple chemical equilibrium problem:
  // System: { xy = K     (equilibrium constant)
  //        { x + y = 1   (mass balance)
  auto chemical_eq = [](const ADVector& X) {
    const double K = 0.1;  // equilibrium constant
    ADVector result(2);
    result(0) = X(0) * X(1) - K;    // equilibrium equation
    result(1) = X(0) + X(1) - 1.0;  // mass balance
    return result;
  };

  auto quadratic = [](const ADVector& X) {
    ADVector result(1);
    result(0) = 4.0 * X(0) * X(0) + 2 * X(0) - 1.0;
    return result;
  };

  auto quartic = [](const ADVector& X) {
    ADVector result(1);
    const auto& z = X(0);
    result(0) = 4.0 * z * z * z * z - 25.0 * z * z * z + z * z - z + 3.0;
    return result;
  };

  auto parabola_line = [](const ADVector& X) {
    ADVector result(2);
    result(0) = X(0) * X(0) - X(1);  // Parabola y = x^2
    result(1) = X(1) - 4.0;          // Line y = 4
    return result;
  };

  auto higher_dim = [](const ADVector& X) {
    ADVector result(4);
    result(0) = X(0) * X(0) * X(0) + CppAD::sin(X(1)) - 1.0;
    result(1) = X(0) * X(0) + X(1) * X(1) + X(2) * X(2) + X(3) * X(3) - 5.0;
    result(2) = X(0) + X(1) + X(2) + CppAD::pow(X(3), 5) + 2.5;
    result(3) = CppAD::sin(X(0)) + CppAD::exp(X(1)) +
                CppAD::cos(X(1)) * X(2) * X(2) * X(2) + 2.0;
    return result;
  };

  run_solver(quadratic, 1, "Quadratic", true);
  run_solver(circle_line, 2, "Circle/Line Intersection", true);
  run_solver(chemical_eq, 2, "Chemical Equilibrium,", true);
  run_solver(quartic, 1, "Quartic,", true);
  run_solver(parabola_line, 2, "Parabola/Line Intersection,", true);
  run_solver(higher_dim, 4, "Higher Dimensional System,", true);
  /*
  run_solver(quadratic, 1, "Quadratic");
  run_solver(circle_line, 2, "Circle/Line Intersection");
  run_solver(chemical_eq, 2, "Chemical Equilibrium,");
  run_solver(quartic, 1, "Quartic,");
  run_solver(parabola_line, 2, "Parabola/Line Intersection,");
  run_solver(higher_dim, 4, "Higher Dimensional System,");
  */
}

================
File: project/CMakeLists.txt
================
# MIT License 
# Copyright (c) 2018-Today Michele Adduci <adduci@tutanota.com>
#
# Project-related instructions

# Activate Testing, if given
if(BUILD_TESTING)
  enable_testing()
endif()

#####################################
# Define Targets
#####################################
#add_subdirectory(hellolib)
add_subdirectory(HC-MC)

#####################################
# Define Install Targets
#####################################
install(TARGETS
 # hellolib
  HC-MC
  RUNTIME DESTINATION bin
  LIBRARY DESTINATION lib
  ARCHIVE DESTINATION lib
  PUBLIC_HEADER DESTINATION include
)

install(
  FILES 
    ${CMAKE_SOURCE_DIR}/project/HC-MC/include/HC-MC.h 
    #${CMAKE_BINARY_DIR}/exports/hellolib_export.h
  DESTINATION 
    include/hellolib)

install(FILES  
  ${CMAKE_SOURCE_DIR}/LICENSE
DESTINATION .)

================
File: .clang-format
================
---
Language:        Cpp
BasedOnStyle:    Google
ColumnLimit:     80
IndentWidth:     2
Standard:        c++17

================
File: .clang-tidy
================
# Configure clang-tidy for modern C++ development
Checks: '
    *,
    -abseil-*,
    -altera-*,
    -android-*,
    -fuchsia-*,
  #  -google-*,
    -llvm*,
    -modernize-use-trailing-return-type,
    -zircon-*,
    -readability-else-after-return,
    -readability-static-accessed-through-instance,
    -readability-avoid-const-params-in-decls,
    -cppcoreguidelines-non-private-member-variables-in-classes,
    -misc-non-private-member-variables-in-classes,
    -cppcoreguidelines-avoid-magic-numbers,
    -readability-magic-numbers,
    -cppcoreguidelines-pro-type-vararg,
    -hicpp-vararg,
    -cppcoreguidelines-pro-bounds-pointer-arithmetic,
    -cppcoreguidelines-avoid-c-arrays,
    -modernize-avoid-c-arrays,
    -hicpp-avoid-c-arrays,
    -cppcoreguidelines-pro-bounds-array-to-pointer-decay,
    -hicpp-no-array-decay,
    -readability-identifier-length,
    -misc-include-cleaner,
    -readability-function-cognitive-complexity,
    '
WarningsAsErrors: ''
HeaderFilterRegex: 'project/HC-MC/.*'
FormatStyle: 'file'

# Disable specific checks in specific files
CheckOptions:
  - key: readability-function-cognitive-complexity.Threshold
    value: '25'
  - key: readability-function-size.LineThreshold
    value: '100'

================
File: .dockerignore
================
*.yml
.travis/
README.md
.git
.gitignore

================
File: .gitignore
================
build/
*.pyc
.vscode
CMakeUserPresets.json

================
File: .gitmodules
================
[submodule "external/vcpkg"]
	path = external/vcpkg
	url = https://github.com/Microsoft/vcpkg.git

================
File: .repomixignore
================
vcpkg/
build/
LICENSE

================
File: AAA.cpp
================
#include "AAA.hpp"
#include "mpreal.h"
#include <complex>
#include <iostream>
#include <vector>

template<typename T>
T
Func(const T &x) {
    // return (T(1.0) / T(x - 0.1)) * std::abs(x - T(0.5)) * std::exp(std::sin(20.0 * x));
    return (exp(x)) * sqrt(x + 0.1) + abs(x - 0.1234567);
}

int
main() {
    using mpfr::mpreal;


    // Required precision of computations in decimal digits
    // Play with it to check different precisions
    const int digits = 50;

    // Setup default precision for all subsequent computations
    // MPFR accepts precision in bits - so we do the conversion
    mpreal::set_default_prec(mpfr::digits2bits(digits));

    mpreal r = 0;


    // Sample points (Z) and function values (F)


    using Scalar = mpreal;
    //    using Complex = std::complex<Scalar>;

    using Complex = Scalar;

    std::vector<Scalar> Z;
    std::vector<Scalar> F;

    // Example: Approximate the function f(z) = exp(z) on the interval [0, 1]
    size_t N = 203; // Reduced number of points for brevity
    for (size_t i = 0; i < N; ++i) {
        Scalar x = Scalar(i) / (N - 1); // Points between 0 and 1
        Scalar z = x;
        Z.push_back(z);
        F.push_back(Func(z));
    }

    // Create AAA approximant
    AAA<Scalar> approximant;
    approximant.fit(Z, F);

    // Evaluate at new points
    std::vector<Scalar> Z_eval;
    for (size_t i = 0; i < N; ++i) {
        Scalar x = Scalar(i) / (N - 1) + 0.001; // Shifted points
        Z_eval.push_back(x);
    }

    std::vector<Scalar> F_approx = approximant(Z_eval);

    // Compare with exact values
    for (size_t i = 0; i < Z_eval.size(); ++i) {
        Scalar f_exact = Func(Z_eval[i]);
        Scalar f_approx = F_approx[i];
        Scalar error = abs(f_exact - f_approx);
        std::cout << "z = " << Z_eval[i] << ", Exact = " << f_exact << ", Approx = " << f_approx
                  << ", Error = " << error << std::endl;
    }

    return 0;
}

================
File: AAA.hpp
================
#ifndef AAA_HPP
#define AAA_HPP

#include <Eigen/Dense>
#include <algorithm>
#include <cmath>
#include <complex>
#include <iostream> // For debug output
#include <limits>
#include <numeric>
#include <vector>

template<typename Scalar>
class AAA {
  public:
    using Complex = std::complex<Scalar>;
    using VectorX = Eigen::Matrix<Scalar, Eigen::Dynamic, 1>;

    AAA() = default;

    /**
     * Fit the AAA approximant to the data points (Z, F).
     *
     * @param Z     Vector of sample points in the Scalar plane.
     * @param F     Vector of function values at the points in Z.
     * @param tol   Relative tolerance for convergence (default: 1e-13).
     * @param mmax  Maximum number of iterations (default: 150).
     */
    void fit(const std::vector<Scalar> &Z, const std::vector<Scalar> &F, Scalar tol = Scalar(1e-13), size_t mmax = 150);

    /**
     * Evaluate the AAA approximant at a given point z.
     *
     * @param z  Point at which to evaluate the approximant.
     * @return   Approximated function value at z.
     */
    Scalar operator()(const Scalar &z) const;

    /**
     * Evaluate the AAA approximant at multiple points.
     *
     * @param Z_eval  Vector of points at which to evaluate the approximant.
     * @return        Vector of approximated function values.
     */
    std::vector<Scalar> operator()(const std::vector<Scalar> &Z_eval) const;

    /**
     * Get the support points used in the approximation.
     */
    const std::vector<Scalar> &support_points() const { return z_; }

    /**
     * Get the weights used in the approximation.
     */
    const std::vector<Scalar> &weights() const { return w_; }

    /**
     * Get the function values at the support points.
     */
    const std::vector<Scalar> &function_values() const { return f_; }

  private:
    std::vector<Scalar> z_; // Support points
    std::vector<Scalar> f_; // Function values at support points
    std::vector<Scalar> w_; // Barycentric weights

    // Helper function to compute the barycentric weights
    void compute_weights(const Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic> &A, const std::vector<size_t> &J);

    // Helper function to evaluate the approximant at a point
    Scalar evaluate(const Scalar &z) const;

    // Helper function to remove Froissart doublets (spurious poles)
    void remove_froissart_doublets(const std::vector<Scalar> &Z, const std::vector<Scalar> &F);

    // Error vector to track convergence
    std::vector<Scalar> error_history_;
};

template<typename Scalar>
void
AAA<Scalar>::fit(const std::vector<Scalar> &Z, const std::vector<Scalar> &F, Scalar tol, size_t mmax) {
    size_t M = Z.size();
    if (M != F.size()) { throw std::invalid_argument("Z and F must be of the same length."); }

    // Initialize variables
    std::vector<size_t> J(M);
    std::iota(J.begin(), J.end(), 0); // Indices of unused points

    z_.clear();
    f_.clear();
    w_.clear();
    error_history_.clear();

    // Initial approximation is the mean of F
    Scalar meanF = std::accumulate(F.begin(), F.end(), Scalar(0)) / Scalar(M);
    VectorX R = VectorX::Constant(M, meanF);

    // Compute initial error over all points
    Scalar error = 0;
    for (size_t idx : J) {
        Scalar e = abs(F[idx] - R(idx));
        if (e > error) { error = e; }
    }
    error_history_.push_back(error);

    using EMatrixType = Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic>;
    using EVectorType = Eigen::Matrix<Scalar, 1, Eigen::Dynamic>;


    EMatrixType C = EMatrixType::Zero(M, 0); // Cauchy matrix
    EMatrixType A = EMatrixType::Zero(M, 0); // Loewner matrix

    size_t m = 0;
    while (error > tol && m < mmax && !J.empty()) {
        // Find the index with maximum error
        size_t j = J[0];
        Scalar max_error = abs(F[j] - R(j));
        for (size_t idx : J) {
            Scalar e = abs(F[idx] - R(idx));
            if (e > max_error) {
                max_error = e;
                j = idx;
            }
        }

        // Add new support point
        z_.push_back(Z[j]);
        f_.push_back(F[j]);
        m++;

        // Remove index j from J
        J.erase(std::remove(J.begin(), J.end(), j), J.end());

        // Update Cauchy matrix
        C.conservativeResize(Eigen::NoChange, m);
        for (size_t i = 0; i < M; ++i) { C(i, m - 1) = Scalar(1) / (Z[i] - Z[j]); }

        // Update Loewner matrix
        A.conservativeResize(Eigen::NoChange, m);
        for (size_t i = 0; i < M; ++i) { A(i, m - 1) = (F[i] - F[j]) * C(i, m - 1); }

        // Compute weights
        compute_weights(A, J);

        // Evaluate rational approximant at unused points
        // Set R at support points to exact values
        R = Eigen::Map<const VectorX>(F.data(), M);

        for (size_t idx : J) { R(idx) = evaluate(Z[idx]); }

        // Compute error over indices J (non-support points)
        error = 0;
        for (size_t idx : J) {
            Scalar e = abs(F[idx] - R(idx));
            if (e > error) { error = e; }
        }
        error_history_.push_back(error);

        // Debug output
        std::cout << "Iteration " << m << ", error = " << error << std::endl;

        if (isnan(error) || isinf(error)) {
            std::cerr << "Error became NaN or Inf. Stopping iteration." << std::endl;
            break;
        }
    }

    // Remove spurious poles
    // remove_froissart_doublets(Z, F); // Not implemented yet
}

template<typename Scalar>
void
AAA<Scalar>::compute_weights(const Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic> &A,
                             const std::vector<size_t> &J) {
    size_t m = A.cols();
    size_t n = J.size();

    if (m == 0) {
        // No weights to compute
        w_.clear();
        return;
    }

    if (m == 1) {
        // Only one support point
        w_.assign(1, Scalar(1.0));
        return;
    }
    using EMatrixType = Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic>;
    using EVectorType = Eigen::Matrix<Scalar, 1, Eigen::Dynamic>;

    if (n >= m) {
        // The usual tall-skinny case
        EMatrixType A_sub(n, m);
        for (size_t i = 0; i < n; ++i) { A_sub.row(i) = A.row(J[i]); }
        Eigen::JacobiSVD<EMatrixType> svd(A_sub, Eigen::ComputeThinV);
        EVectorType w = svd.matrixV().col(svd.matrixV().cols() - 1);
        w_ = std::vector<Scalar>(w.data(), w.data() + w.size());
    } else if (n >= 1) {
        // Fewer rows than columns
        EMatrixType A_sub(n, m);
        for (size_t i = 0; i < n; ++i) { A_sub.row(i) = A.row(J[i]); }
        Eigen::FullPivLU<EMatrixType> lu_decomp(A_sub);
        EMatrixType null_space = lu_decomp.kernel();
        if (null_space.cols() > 0) {
            EMatrixType w = null_space.col(0);
            w_ = std::vector<Scalar>(w.data(), w.data() + w.size());
        } else {
            // Should not happen
            std::cerr << "Warning: Null space computation failed. Using default weights." << std::endl;
            w_.assign(m, Scalar(1.0));
        }
    } else {
        // No rows at all
        w_.assign(m, Scalar(1.0) / sqrt(Scalar(m)));
    }
}

template<typename Scalar>
Scalar
AAA<Scalar>::operator()(const Scalar &z) const {
    return evaluate(z);
}

template<typename Scalar>
std::vector<Scalar>
AAA<Scalar>::operator()(const std::vector<Scalar> &Z_eval) const {
    std::vector<Scalar> result;
    result.reserve(Z_eval.size());
    for (const auto &z : Z_eval) { result.push_back(evaluate(z)); }
    return result;
}
template<typename Scalar>
Scalar
AAA<Scalar>::evaluate(const Scalar &z) const {
    if (z_.empty()) {
        std::cerr << "Error: No support points available for evaluation." << std::endl;
        return Scalar(std::numeric_limits<Scalar>::quiet_NaN());
    }

    if (z_.size() == 1) { return f_[0]; }

    Scalar tol = Scalar(1e-13);
    Scalar tol_quarter = pow(tol, Scalar(0.25));

    Scalar numerator = 0;
    Scalar denominator = 0;

    bool breakflag = false;
    size_t breakindex = std::numeric_limits<size_t>::max();

    for (size_t j = 0; j < z_.size(); ++j) {
        Scalar diff = z - z_[j];
        Scalar abs_diff = abs(diff);
        if (abs_diff < tol_quarter) {
            breakflag = true;
            breakindex = j;
            break;
        }
        Scalar term = w_[j] / diff;
        numerator += term * f_[j];
        denominator += term;
    }

    if (breakflag) {
        numerator = 0;
        denominator = 0;
        for (size_t j = 0; j < z_.size(); ++j) {
            if (j == breakindex) continue;
            Scalar diff = z - z_[j];
            Scalar term = w_[j] / diff;
            numerator += term * f_[j];
            denominator += term;
        }
        Scalar m = z - z_[breakindex];
        Scalar fz = (w_[breakindex] * f_[breakindex] + m * numerator) / (w_[breakindex] + m * denominator);
        return fz;
    } else {
        if (denominator == Scalar(0)) {
            std::cerr << "Warning: Denominator is zero at z = " << z << std::endl;
            return Scalar(std::numeric_limits<Scalar>::quiet_NaN());
        }
        return numerator / denominator;
    }
}


#endif // AAA_HPP

================
File: build.sh
================
#!/bin/bash
set -e  # Exit on any error

# Parse command line arguments
BUILD_TYPE="Debug"  # Default to Debug
COMPILER="gcc"      # Default to gcc
COMPILER_VERSION="" # Optional version specifier

print_usage() {
    echo "Usage: $0 [options]"
    echo "Options:"
    echo "  --debug                Build with debug symbols (default)"
    echo "  --release              Build with optimizations"
    echo "  --compiler=<name>      Use specific compiler (gcc|clang)"
    echo "  --compiler-version=<v> Use specific compiler version (e.g., 13, 15)"
    echo "  --help                 Show this help message"
    echo
    echo "Examples:"
    echo "  $0 --compiler=clang --compiler-version=15 --release"
    echo "  $0 --compiler=gcc --compiler-version=13"
}

while [[ $# -gt 0 ]]; do
    case $1 in
        --release)
            BUILD_TYPE="Release"
            shift
            ;;
        --debug)
            BUILD_TYPE="Debug"
            shift
            ;;
        --compiler=*)
            COMPILER="${1#*=}"
            shift
            ;;
        --compiler-version=*)
            COMPILER_VERSION="${1#*=}"
            shift
            ;;
        --help)
            print_usage
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            print_usage
            exit 1
            ;;
    esac
done

# Set up compiler environment variables
setup_compiler() {
    local compiler_name="$1"
    local version="$2"
    
    # Clear any existing compiler variables
    unset CC CXX
    
    case $compiler_name in
        gcc)
            if [ -n "$version" ]; then
                export CC="gcc-${version}"
                export CXX="g++-${version}"
            else
                export CC="gcc"
                export CXX="g++"
            fi
            ;;
            
        clang)
            if [ -n "$version" ]; then
                export CC="clang-${version}"
                export CXX="clang++-${version}"
            else
                export CC="clang"
                export CXX="clang++"
            fi
            ;;
            
        *)
            echo "Unsupported compiler: $compiler_name"
            exit 1
            ;;
    esac
    
    # Verify compiler exists
    if ! command -v "$CC" >/dev/null 2>&1; then
        echo "Error: Compiler $CC not found"
        exit 1
    fi
    
    if ! command -v "$CXX" >/dev/null 2>&1; then
        echo "Error: Compiler $CXX not found"
        exit 1
    fi
    
    echo "Using C compiler: $CC ($(command -v "$CC"))"
    echo "Using C++ compiler: $CXX ($(command -v "$CXX"))"
}

# Set up the compiler
setup_compiler "$COMPILER" "$COMPILER_VERSION"

# Clone vcpkg if it doesn't exist
if [ ! -d "external/vcpkg" ]; then
    echo "Cloning vcpkg..."
    git clone https://github.com/Microsoft/vcpkg.git external/vcpkg
    external/vcpkg/bootstrap-vcpkg.sh
fi

# Set VCPKG_ROOT to the submodule path
export VCPKG_ROOT=$(pwd)/external/vcpkg

# Clean build directory
rm -rf build

echo "Configuring for ${BUILD_TYPE} build using ${CXX}..."

# Configure the project with CMake and vcpkg
cmake -B build -S . \
    -DCMAKE_TOOLCHAIN_FILE="$VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake" \
    -DVCPKG_TARGET_TRIPLET=x64-linux \
    -DBUILD_TESTING=ON \
    -DCMAKE_BUILD_TYPE=${BUILD_TYPE} \
    -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
    -DCMAKE_C_COMPILER="$CC" \
    -DCMAKE_CXX_COMPILER="$CXX"

# Build the project
echo "Building..."
cmake --build build

# Optional: Run tests after building
echo "Running tests..."
ctest --test-dir build --output-on-failure

echo "Build complete. Type: ${BUILD_TYPE}"
if [ "$BUILD_TYPE" = "Debug" ]; then
    echo "Debug symbols are enabled. You can use gdb/lldb for debugging."
fi

# Print compiler version information
$CXX --version

================
File: CMakeLists.txt
================
cmake_minimum_required(VERSION 3.15.0 FATAL_ERROR)
set(CMAKE_TOOLCHAIN_FILE "${CMAKE_CURRENT_SOURCE_DIR}/external/vcpkg/scripts/buildsystems/vcpkg.cmake" CACHE STRING "Vcpkg toolchain file")


project(moderncpp_project 
    VERSION 1.1.2
    LANGUAGES CXX
    DESCRIPTION "HC-MC is a testbed for homotopy continuation methods."
)

# Set required C++ Standard
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED TRUE)
set(CMAKE_EXPORT_COMPILE_COMMANDS TRUE)

# Configure the visibility of symbols in targets
set(CMAKE_CXX_VISIBILITY_PRESET hidden)
set(CMAKE_VISIBILITY_INLINES_HIDDEN 1)

#####################################
# Define Options
#####################################
option(BUILD_TESTING "Build tests" FALSE)
option(BUILD_SHARED_LIBS "Build shared libraries" FALSE)
option(BUILD_WITH_MT "Build libraries as MultiThreaded DLL (Windows Only)" FALSE)

#####################################
# Find Dependencies - vcpkg handles the heavy lifting
#####################################
find_package(Eigen3 CONFIG REQUIRED)

# Use pkg-config to locate cppad
find_package(PkgConfig REQUIRED)
pkg_check_modules(CPPAD REQUIRED cppad)

# Add the cppad include directories and libraries
include_directories(${CPPAD_INCLUDE_DIRS})
link_directories(${CPPAD_LIBRARY_DIRS})

# Add testing dependencies if enabled
if(BUILD_TESTING)
    find_package(doctest CONFIG REQUIRED)
    enable_testing()
endif()

#####################################
# Define CMake Module Imports
#####################################
include(GNUInstallDirs)
include(CMakePackageConfigHelpers)
include(GenerateExportHeader)
include(${CMAKE_SOURCE_DIR}/cmake/compiler_options.cmake)
include(${CMAKE_SOURCE_DIR}/cmake/cpack.cmake)
include(${CMAKE_SOURCE_DIR}/cmake/cppcheck.cmake)
include(${CMAKE_SOURCE_DIR}/cmake/clang_format.cmake)
include(${CMAKE_SOURCE_DIR}/cmake/clang_tidy.cmake)

#####################################
# Define Targets
#####################################
add_subdirectory(project/HC-MC)

#####################################
# Define Install Targets
#####################################
install(TARGETS
    HC-MC
    RUNTIME DESTINATION bin
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
    PUBLIC_HEADER DESTINATION include
)

install(FILES  
    ${CMAKE_SOURCE_DIR}/LICENSE
    DESTINATION .
)

================
File: cppcheck_suppressions.txt
================
missingIncludeSystem

================
File: mpreal.h
================
/*
    MPFR C++: Multi-precision floating point number class for C++.
    Based on MPFR library:    http://mpfr.org

    Project homepage:    http://www.holoborodko.com/pavel/mpfr
    Contact e-mail:      pavel@holoborodko.com

    Copyright (c) 2008-2024 Pavel Holoborodko

    Contributors:
    Dmitriy Gubanov, Konstantin Holoborodko, Brian Gladman,
    Helmut Jarausch, Fokko Beekhof, Ulrich Mutze, Heinz van Saanen,
    Pere Constans, Peter van Hoof, Gael Guennebaud, Tsai Chia Cheng,
    Alexei Zubanov, Jauhien Piatlicki, Victor Berger, John Westwood,
    Petr Aleksandrov, Orion Poplawski, Charles Karney, Arash Partow,
    Rodney James, Jorge Leitao, Jerome Benoit, Michal Maly,
    Abhinav Natarajan, Valerio Di Lecce, Luca Vandelli.

    Licensing:
    (A) MPFR C++ is under GNU General Public License ("GPL").

    (B) Non-free licenses may also be purchased from the author, for users who
        do not want their programs protected by the GPL.

        The non-free licenses are for users that wish to use MPFR C++ in
        their products but are unwilling to release their software
        under the GPL (which would require them to release source code
        and allow free redistribution).

        Such users can purchase an unlimited-use license from the author.
        Contact us for more details.

    GNU General Public License ("GPL") copyright permissions statement:
    **************************************************************************
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef __MPREAL_H__
#define __MPREAL_H__

#include <algorithm>
#include <cfloat>
#include <cmath>
#include <complex>
#include <cstring>
#include <iostream>
#include <limits>
#include <sstream>
#include <stdexcept>
#include <stdint.h>
#include <string>

// Options
#define MPREAL_HAVE_MSVC_DEBUGVIEW             // Enable Debugger Visualizer for "Debug" builds in MSVC.
#define MPREAL_HAVE_DYNAMIC_STD_NUMERIC_LIMITS // Enable extended std::numeric_limits<mpfr::mpreal> specialization.
                                               // Meaning that "digits", "round_style" and similar members are defined
                                               // as functions, not constants. See std::numeric_limits<mpfr::mpreal> at
                                               // the end of the file for more information.

// Library version
#define MPREAL_VERSION_MAJOR 3
#define MPREAL_VERSION_MINOR 7
#define MPREAL_VERSION_PATCHLEVEL 1
#define MPREAL_VERSION_STRING "3.7.1"

// Detect compiler using signatures from http://predef.sourceforge.net/
#if defined(__GNUC__) && defined(__INTEL_COMPILER)
#define MPREAL_IS_INF(x) isinf(x) // Intel ICC compiler on Linux

#elif defined(_MSC_VER) // Microsoft Visual C++
#define MPREAL_IS_INF(x) (!_finite(x))

#else
#define MPREAL_IS_INF(x) std::isinf(x) // GNU C/C++ (and/or other compilers), just hope for C99 conformance
#endif

// A Clang feature extension to determine compiler features.
#ifndef __has_feature
#define __has_feature(x) 0
#endif

// Detect support for r-value references (move semantic).
// Move semantic should be enabled with great care in multi-threading environments,
// especially if MPFR uses custom memory allocators.
// Everything should be thread-safe and support passing ownership over thread boundary.
#if (__has_feature(cxx_rvalue_references) || defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103L ||          \
     (defined(_MSC_VER) && _MSC_VER >= 1600) && !defined(MPREAL_DISABLE_MOVE_SEMANTIC))

#define MPREAL_HAVE_MOVE_SUPPORT

// Use fields in mpfr_t structure to check if it was initialized / set dummy initialization
#define mpfr_is_initialized(x) (0 != (x)->_mpfr_d)
#define mpfr_set_uninitialized(x) ((x)->_mpfr_d = 0)
#endif

// Detect support for explicit converters.
#if (__has_feature(cxx_explicit_conversions) || (defined(__GXX_EXPERIMENTAL_CXX0X__) && __GNUC_MINOR >= 5) ||          \
     __cplusplus >= 201103L || (defined(_MSC_VER) && _MSC_VER >= 1800) ||                                              \
     (defined(__INTEL_COMPILER) && __INTEL_COMPILER >= 1300))

#define MPREAL_HAVE_EXPLICIT_CONVERTERS
#endif

#if defined(MPREAL_HAVE_MSVC_DEBUGVIEW) && defined(_MSC_VER) && defined(_DEBUG)
#define MPREAL_MSVC_DEBUGVIEW_CODE DebugView = toString();
#define MPREAL_MSVC_DEBUGVIEW_DATA std::string DebugView;
#else
#define MPREAL_MSVC_DEBUGVIEW_CODE
#define MPREAL_MSVC_DEBUGVIEW_DATA
#endif

// Check if mpfr.h was included earlier (and with compatible settings).
#if defined(__MPFR_H) && !(defined(MPFR_USE_NO_MACRO) && defined(MPFR_USE_INTMAX_T))
#error The MPFR_USE_NO_MACRO and MPFR_USE_INTMAX_T must be defined for proper use of mpfr.h/mpreal.h
#else
#ifndef MPFR_USE_INTMAX_T
#define MPFR_USE_INTMAX_T // Enable 64-bit integer types - should be defined before mpfr.h
#endif
#ifndef MPFR_USE_NO_MACRO
#define MPFR_USE_NO_MACRO // Avoid name clash with MPFR, introduced in MPFR 4.2.0
#endif
#include <mpfr.h>
#endif

#if (MPFR_VERSION < MPFR_VERSION_NUM(3, 0, 0))
#include <cstdlib> // Needed for random()
#endif

// Less important options
#define MPREAL_DOUBLE_BITS_OVERFLOW                                                                                    \
    -1 // Triggers overflow exception during conversion to double if mpreal
       // cannot fit in MPREAL_DOUBLE_BITS_OVERFLOW bits
       // = -1 disables overflow checks (default)

// Fast replacement for mpfr_set_zero(x, +1):
// (a) uses low-level data members, might not be forward compatible
// (b) sign is not set, add (x)->_mpfr_sign = 1;
#define mpfr_set_zero_fast(x) ((x)->_mpfr_exp = __MPFR_EXP_ZERO)

#if defined(__GNUC__)
#define MPREAL_PERMISSIVE_EXPR __extension__
#else
#define MPREAL_PERMISSIVE_EXPR
#endif

namespace mpfr {

class mpreal {
  private:
    mpfr_t mp;

  public:
    // Get default rounding mode & precision
    inline static mp_rnd_t get_default_rnd() { return (mp_rnd_t)(mpfr_get_default_rounding_mode()); }
    inline static mp_prec_t get_default_prec() { return (mpfr_get_default_prec)(); }

    // Constructors && type conversions
    mpreal();
    mpreal(const mpreal &u);
    mpreal(const mpf_t u);
    mpreal(const mpz_t u, mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());
    mpreal(const mpq_t u, mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());
    mpreal(const double u, mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());
    mpreal(const long double u, mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());
    mpreal(const unsigned long long int u,
           mp_prec_t prec = mpreal::get_default_prec(),
           mp_rnd_t mode = mpreal::get_default_rnd());
    mpreal(const long long int u,
           mp_prec_t prec = mpreal::get_default_prec(),
           mp_rnd_t mode = mpreal::get_default_rnd());
    mpreal(const unsigned long int u,
           mp_prec_t prec = mpreal::get_default_prec(),
           mp_rnd_t mode = mpreal::get_default_rnd());
    mpreal(const unsigned int u,
           mp_prec_t prec = mpreal::get_default_prec(),
           mp_rnd_t mode = mpreal::get_default_rnd());
    mpreal(const long int u, mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());
    mpreal(const int u, mp_prec_t prec = mpreal::get_default_prec(), mp_rnd_t mode = mpreal::get_default_rnd());

    // Construct mpreal from mpfr_t structure.
    // shared = true allows to avoid deep copy, so that mpreal and 'u' share the same data & pointers.
    mpreal(const mpfr_t u, bool shared = false);

    mpreal(const char *s,
           mp_prec_t prec = mpreal::get_default_prec(),
           int base = 10,
           mp_rnd_t mode = mpreal::get_default_rnd());
    mpreal(const std::string &s,
           mp_prec_t prec = mpreal::get_default_prec(),
           int base = 10,
           mp_rnd_t mode = mpreal::get_default_rnd());

    ~mpreal();

#ifdef MPREAL_HAVE_MOVE_SUPPORT
    mpreal &operator=(mpreal &&v);
    mpreal(mpreal &&u);
#endif

    // Operations
    // =
    // +, -, *, /, ++, --, <<, >>
    // *=, +=, -=, /=,
    // <, >, ==, <=, >=

    // =
    mpreal &operator=(const mpreal &v);
    mpreal &operator=(const mpf_t v);
    mpreal &operator=(const mpz_t v);
    mpreal &operator=(const mpq_t v);
    mpreal &operator=(const long double v);
    mpreal &operator=(const double v);
    mpreal &operator=(const unsigned long int v);
    mpreal &operator=(const unsigned long long int v);
    mpreal &operator=(const long long int v);
    mpreal &operator=(const unsigned int v);
    mpreal &operator=(const long int v);
    mpreal &operator=(const int v);
    mpreal &operator=(const char *s);
    mpreal &operator=(const std::string &s);
    template<typename real_t>
    mpreal &operator=(const std::complex<real_t> &z);

    // +
    mpreal &operator+=(const mpreal &v);
    mpreal &operator+=(const mpf_t v);
    mpreal &operator+=(const mpz_t v);
    mpreal &operator+=(const mpq_t v);
    mpreal &operator+=(const long double u);
    mpreal &operator+=(const double u);
    mpreal &operator+=(const unsigned long int u);
    mpreal &operator+=(const unsigned int u);
    mpreal &operator+=(const long int u);
    mpreal &operator+=(const int u);

    mpreal &operator+=(const long long int u);
    mpreal &operator+=(const unsigned long long int u);
    mpreal &operator-=(const long long int u);
    mpreal &operator-=(const unsigned long long int u);
    mpreal &operator*=(const long long int u);
    mpreal &operator*=(const unsigned long long int u);
    mpreal &operator/=(const long long int u);
    mpreal &operator/=(const unsigned long long int u);

    const mpreal operator+() const;
    mpreal &operator++();
    const mpreal operator++(int);

    // -
    mpreal &operator-=(const mpreal &v);
    mpreal &operator-=(const mpz_t v);
    mpreal &operator-=(const mpq_t v);
    mpreal &operator-=(const long double u);
    mpreal &operator-=(const double u);
    mpreal &operator-=(const unsigned long int u);
    mpreal &operator-=(const unsigned int u);
    mpreal &operator-=(const long int u);
    mpreal &operator-=(const int u);
    const mpreal operator-() const;
    friend const mpreal operator-(const unsigned long int b, const mpreal &a);
    friend const mpreal operator-(const unsigned int b, const mpreal &a);
    friend const mpreal operator-(const long int b, const mpreal &a);
    friend const mpreal operator-(const int b, const mpreal &a);
    friend const mpreal operator-(const double b, const mpreal &a);
    mpreal &operator--();
    const mpreal operator--(int);

    // *
    mpreal &operator*=(const mpreal &v);
    mpreal &operator*=(const mpz_t v);
    mpreal &operator*=(const mpq_t v);
    mpreal &operator*=(const long double v);
    mpreal &operator*=(const double v);
    mpreal &operator*=(const unsigned long int v);
    mpreal &operator*=(const unsigned int v);
    mpreal &operator*=(const long int v);
    mpreal &operator*=(const int v);

    // /
    mpreal &operator/=(const mpreal &v);
    mpreal &operator/=(const mpz_t v);
    mpreal &operator/=(const mpq_t v);
    mpreal &operator/=(const long double v);
    mpreal &operator/=(const double v);
    mpreal &operator/=(const unsigned long int v);
    mpreal &operator/=(const unsigned int v);
    mpreal &operator/=(const long int v);
    mpreal &operator/=(const int v);
    friend const mpreal operator/(const unsigned long int b, const mpreal &a);
    friend const mpreal operator/(const unsigned int b, const mpreal &a);
    friend const mpreal operator/(const long int b, const mpreal &a);
    friend const mpreal operator/(const int b, const mpreal &a);
    friend const mpreal operator/(const double b, const mpreal &a);

    //<<= Fast Multiplication by 2^u
    mpreal &operator<<=(const unsigned long int u);
    mpreal &operator<<=(const unsigned int u);
    mpreal &operator<<=(const long int u);
    mpreal &operator<<=(const int u);

    //>>= Fast Division by 2^u
    mpreal &operator>>=(const unsigned long int u);
    mpreal &operator>>=(const unsigned int u);
    mpreal &operator>>=(const long int u);
    mpreal &operator>>=(const int u);

    // Type Conversion operators
    bool toBool() const;
    long toLong(mp_rnd_t mode = GMP_RNDZ) const;
    unsigned long toULong(mp_rnd_t mode = GMP_RNDZ) const;
    long long toLLong(mp_rnd_t mode = GMP_RNDZ) const;
    unsigned long long toULLong(mp_rnd_t mode = GMP_RNDZ) const;
    float toFloat(mp_rnd_t mode = GMP_RNDN) const;
    double toDouble(mp_rnd_t mode = GMP_RNDN) const;
    long double toLDouble(mp_rnd_t mode = GMP_RNDN) const;

#if defined(MPREAL_HAVE_EXPLICIT_CONVERTERS)
    explicit operator bool() const { return toBool(); }
    explicit operator signed char() const { return (signed char)toLong(); }
    explicit operator unsigned char() const { return (unsigned char)toULong(); }
    explicit operator short() const { return (short)toLong(); }
    explicit operator unsigned short() const { return (unsigned short)toULong(); }
    explicit operator int() const { return (int)toLong(); }
    explicit operator unsigned int() const { return (unsigned int)toULong(); }
    explicit operator long() const { return toLong(); }
    explicit operator unsigned long() const { return toULong(); }
    explicit operator long long() const { return toLLong(); }
    explicit operator unsigned long long() const { return toULLong(); }
    explicit operator float() const { return toFloat(); }
    explicit operator double() const { return toDouble(); }
    explicit operator long double() const { return toLDouble(); }
#endif

    // Get raw pointers so that mpreal can be directly used in raw mpfr_* functions
    ::mpfr_ptr mpfr_ptr();
    ::mpfr_srcptr mpfr_ptr() const;
    ::mpfr_srcptr mpfr_srcptr() const;

    // Convert mpreal to string with n significant digits in base b
    // n = -1 -> convert with the maximum available digits
    std::string toString(int n = -1, int b = 10, mp_rnd_t mode = mpreal::get_default_rnd()) const;

#if (MPFR_VERSION >= MPFR_VERSION_NUM(2, 4, 0))
    std::string toString(const std::string &format) const;
#endif

    std::ostream &output(std::ostream &os) const;

    // Math Functions
    friend const mpreal sqr(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal sqrt(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal sqrt(const unsigned long int v, mp_rnd_t rnd_mode);
    friend const mpreal cbrt(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal root(const mpreal &v, unsigned long int k, mp_rnd_t rnd_mode);
    friend const mpreal pow(const mpreal &a, const mpreal &b, mp_rnd_t rnd_mode);
    friend const mpreal pow(const mpreal &a, const mpz_t b, mp_rnd_t rnd_mode);
    friend const mpreal pow(const mpreal &a, const unsigned long int b, mp_rnd_t rnd_mode);
    friend const mpreal pow(const mpreal &a, const long int b, mp_rnd_t rnd_mode);
    friend const mpreal pow(const unsigned long int a, const mpreal &b, mp_rnd_t rnd_mode);
    friend const mpreal pow(const unsigned long int a, const unsigned long int b, mp_rnd_t rnd_mode);
    friend const mpreal fabs(const mpreal &v, mp_rnd_t rnd_mode);

    friend const mpreal abs(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal dim(const mpreal &a, const mpreal &b, mp_rnd_t rnd_mode);
    friend inline const mpreal mul_2ui(const mpreal &v, unsigned long int k, mp_rnd_t rnd_mode);
    friend inline const mpreal mul_2si(const mpreal &v, long int k, mp_rnd_t rnd_mode);
    friend inline const mpreal div_2ui(const mpreal &v, unsigned long int k, mp_rnd_t rnd_mode);
    friend inline const mpreal div_2si(const mpreal &v, long int k, mp_rnd_t rnd_mode);
    friend int cmpabs(const mpreal &a, const mpreal &b);

    friend const mpreal log(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal log2(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal logb(const mpreal &v, mp_rnd_t rnd_mode);
    friend mp_exp_t ilogb(const mpreal &v);
    friend const mpreal log10(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal exp(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal exp2(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal exp10(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal log1p(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal expm1(const mpreal &v, mp_rnd_t rnd_mode);

    friend const mpreal nextpow2(const mpreal &v, mp_rnd_t rnd_mode);

    friend const mpreal cos(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal sin(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal tan(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal sec(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal csc(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal cot(const mpreal &v, mp_rnd_t rnd_mode);
    friend int sin_cos(mpreal &s, mpreal &c, const mpreal &v, mp_rnd_t rnd_mode);

    friend const mpreal acos(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal asin(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal atan(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal atan2(const mpreal &y, const mpreal &x, mp_rnd_t rnd_mode);
    friend const mpreal acot(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal asec(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal acsc(const mpreal &v, mp_rnd_t rnd_mode);

    friend const mpreal cosh(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal sinh(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal tanh(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal sech(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal csch(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal coth(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal acosh(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal asinh(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal atanh(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal acoth(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal asech(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal acsch(const mpreal &v, mp_rnd_t rnd_mode);

    friend const mpreal hypot(const mpreal &x, const mpreal &y, mp_rnd_t rnd_mode);

    friend const mpreal fac_ui(unsigned long int v, mp_prec_t prec, mp_rnd_t rnd_mode);
    friend const mpreal eint(const mpreal &v, mp_rnd_t rnd_mode);

    friend const mpreal gamma(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal tgamma(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal lngamma(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal lgamma(const mpreal &v, int *signp, mp_rnd_t rnd_mode);
    friend const mpreal zeta(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal erf(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal erfc(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal besselj0(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal besselj1(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal besseljn(long n, const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal bessely0(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal bessely1(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal besselyn(long n, const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal fma(const mpreal &v1, const mpreal &v2, const mpreal &v3, mp_rnd_t rnd_mode);
    friend const mpreal fms(const mpreal &v1, const mpreal &v2, const mpreal &v3, mp_rnd_t rnd_mode);
    friend const mpreal agm(const mpreal &v1, const mpreal &v2, mp_rnd_t rnd_mode);
    friend const mpreal sum(const mpreal tab[], const unsigned long int n, int &status, mp_rnd_t rnd_mode);
    friend int sgn(const mpreal &v);

// MPFR 2.4.0 Specifics
#if (MPFR_VERSION >= MPFR_VERSION_NUM(2, 4, 0))
    friend int sinh_cosh(mpreal &s, mpreal &c, const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal li2(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal fmod(const mpreal &x, const mpreal &y, mp_rnd_t rnd_mode);
    friend const mpreal rec_sqrt(const mpreal &v, mp_rnd_t rnd_mode);

    // MATLAB's semantic equivalents
    friend const mpreal rem(const mpreal &x, const mpreal &y, mp_rnd_t rnd_mode); // Remainder after division
    friend const mpreal mod(const mpreal &x, const mpreal &y, mp_rnd_t rnd_mode); // Modulus after division
#endif

#if (MPFR_VERSION >= MPFR_VERSION_NUM(3, 0, 0))
    friend const mpreal digamma(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal ai(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal urandom(
      gmp_randstate_t &state,
      mp_rnd_t rnd_mode); // use gmp_randinit_default() to init state, gmp_randclear() to clear
#endif

#if (MPFR_VERSION >= MPFR_VERSION_NUM(3, 1, 0))
    friend const mpreal grandom(
      gmp_randstate_t &state,
      mp_rnd_t rnd_mode); // use gmp_randinit_default() to init state, gmp_randclear() to clear
    friend const mpreal grandom(unsigned int seed);
#endif

    // Uniformly distributed random number generation in [0,1] using
    // Mersenne-Twister algorithm by default.
    // Use parameter to setup seed, e.g.: random((unsigned)time(NULL))
    // Check urandom() for more precise control.
    friend const mpreal random(unsigned int seed);

    // Splits mpreal value into fractional and integer parts.
    // Returns fractional part and stores integer part in n.
    friend const mpreal modf(const mpreal &v, mpreal &n);

    // Constants
    // don't forget to call mpfr_free_cache() for every thread where you are using const-functions
    friend const mpreal const_log2(mp_prec_t prec, mp_rnd_t rnd_mode);
    friend const mpreal const_pi(mp_prec_t prec, mp_rnd_t rnd_mode);
    friend const mpreal const_euler(mp_prec_t prec, mp_rnd_t rnd_mode);
    friend const mpreal const_catalan(mp_prec_t prec, mp_rnd_t rnd_mode);

    // returns +inf iff sign>=0 otherwise -inf
    friend const mpreal const_infinity(int sign, mp_prec_t prec);

    // Output/ Input
    friend std::ostream &operator<<(std::ostream &os, const mpreal &v);
    friend std::istream &operator>>(std::istream &is, mpreal &v);

    // Integer Related Functions
    friend const mpreal rint(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal ceil(const mpreal &v);
    friend const mpreal floor(const mpreal &v);
    friend const mpreal round(const mpreal &v);
    friend long lround(const mpreal &v);
    friend long long llround(const mpreal &v);
    friend const mpreal trunc(const mpreal &v);
    friend const mpreal rint_ceil(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal rint_floor(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal rint_round(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal rint_trunc(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal frac(const mpreal &v, mp_rnd_t rnd_mode);
    friend const mpreal remainder(const mpreal &x, const mpreal &y, mp_rnd_t rnd_mode);
    friend const mpreal remquo(const mpreal &x, const mpreal &y, int *q, mp_rnd_t rnd_mode);

    // Miscellaneous Functions
    friend const mpreal nexttoward(const mpreal &x, const mpreal &y);
    friend const mpreal nextabove(const mpreal &x);
    friend const mpreal nextbelow(const mpreal &x);

    // use gmp_randinit_default() to init state, gmp_randclear() to clear
    friend const mpreal urandomb(gmp_randstate_t &state);

// MPFR < 2.4.2 Specifics
#if (MPFR_VERSION <= MPFR_VERSION_NUM(2, 4, 2))
    friend const mpreal random2(mp_size_t size, mp_exp_t exp);
#endif

    // Instance Checkers
    friend bool isnan(const mpreal &v);
    friend bool isinf(const mpreal &v);
    friend bool isfinite(const mpreal &v);

    friend bool isnum(const mpreal &v);
    friend bool iszero(const mpreal &v);
    friend bool isint(const mpreal &v);

#if (MPFR_VERSION >= MPFR_VERSION_NUM(3, 0, 0))
    friend bool isregular(const mpreal &v);
#endif

    // Set/Get instance properties
    inline mp_prec_t get_prec() const;
    inline void set_prec(mp_prec_t prec, mp_rnd_t rnd_mode = get_default_rnd()); // Change precision with rounding mode

    // Aliases for get_prec(), set_prec() - needed for compatibility with std::complex<mpreal> interface
    inline mpreal &setPrecision(int Precision, mp_rnd_t RoundingMode = get_default_rnd());
    inline int getPrecision() const;

    // Set mpreal to +/- inf, NaN, +/-0
    mpreal &setInf(int Sign = +1);
    mpreal &setNan();
    mpreal &setZero(int Sign = +1);
    mpreal &setSign(int Sign, mp_rnd_t RoundingMode = get_default_rnd());

    // Exponent
    mp_exp_t get_exp() const;
    int set_exp(mp_exp_t e);
    int check_range(int t, mp_rnd_t rnd_mode = get_default_rnd());
    int subnormalize(int t, mp_rnd_t rnd_mode = get_default_rnd());

    // Inexact conversion from float
    inline bool fits_in_bits(double x, int n);

    // Set/Get global properties
    static void set_default_prec(mp_prec_t prec);
    static void set_default_rnd(mp_rnd_t rnd_mode);

    static mp_exp_t get_emin(void);
    static mp_exp_t get_emax(void);
    static mp_exp_t get_emin_min(void);
    static mp_exp_t get_emin_max(void);
    static mp_exp_t get_emax_min(void);
    static mp_exp_t get_emax_max(void);
    static int set_emin(mp_exp_t exp);
    static int set_emax(mp_exp_t exp);

    // Efficient swapping of two mpreal values - needed for std algorithms
    friend void swap(mpreal &x, mpreal &y);

    friend const mpreal fmax(const mpreal &x, const mpreal &y, mp_rnd_t rnd_mode);
    friend const mpreal fmin(const mpreal &x, const mpreal &y, mp_rnd_t rnd_mode);

  private:
    // Human friendly Debug Preview in Visual Studio.
    // Put one of these lines:
    //
    // mpfr::mpreal=<DebugView>                              ; Show value only
    // mpfr::mpreal=<DebugView>, <mp[0]._mpfr_prec,u>bits    ; Show value & precision
    //
    // at the beginning of
    // [Visual Studio Installation Folder]\Common7\Packages\Debugger\autoexp.dat
    MPREAL_MSVC_DEBUGVIEW_DATA

    // "Smart" resources deallocation. Checks if instance initialized before deletion.
    void clear(::mpfr_ptr);
};

//////////////////////////////////////////////////////////////////////////
// Exceptions
class conversion_overflow : public std::exception {
  public:
    std::string why() { return "inexact conversion from floating point"; }
};

//////////////////////////////////////////////////////////////////////////
// Constructors & converters
// Default constructor: creates mp number and initializes it to 0.
inline mpreal::mpreal() {
    mpfr_init2(mpfr_ptr(), mpreal::get_default_prec());
    mpfr_set_zero_fast(mpfr_ptr());

    MPREAL_MSVC_DEBUGVIEW_CODE;
}

inline mpreal::mpreal(const mpreal &u) {
    mpfr_init2(mpfr_ptr(), mpfr_get_prec(u.mpfr_srcptr()));
    mpfr_set(mpfr_ptr(), u.mpfr_srcptr(), mpreal::get_default_rnd());

    MPREAL_MSVC_DEBUGVIEW_CODE;
}

#ifdef MPREAL_HAVE_MOVE_SUPPORT
inline mpreal::mpreal(mpreal &&other) {
    mpfr_set_uninitialized(mpfr_ptr()); // make sure "other" holds null-pointer (in uninitialized state)
    mpfr_swap(mpfr_ptr(), other.mpfr_ptr());

    MPREAL_MSVC_DEBUGVIEW_CODE;
}

inline mpreal &
mpreal::operator=(mpreal &&other) {
    if (this != &other) {
        mpfr_swap(mpfr_ptr(), other.mpfr_ptr()); // destructor for "other" will be called just afterwards
        MPREAL_MSVC_DEBUGVIEW_CODE;
    }
    return *this;
}
#endif

inline mpreal::mpreal(const mpfr_t u, bool shared) {
    if (shared) {
        std::memcpy(mpfr_ptr(), u, sizeof(mpfr_t));
    } else {
        mpfr_init2(mpfr_ptr(), mpfr_get_prec(u));
        mpfr_set(mpfr_ptr(), u, mpreal::get_default_rnd());
    }

    MPREAL_MSVC_DEBUGVIEW_CODE;
}

inline mpreal::mpreal(const mpf_t u) {
    mpfr_init2(mpfr_ptr(), (mp_prec_t)mpf_get_prec(u)); // (gmp: mp_bitcnt_t) unsigned long -> long (mpfr: mp_prec_t)
    mpfr_set_f(mpfr_ptr(), u, mpreal::get_default_rnd());

    MPREAL_MSVC_DEBUGVIEW_CODE;
}

inline mpreal::mpreal(const mpz_t u, mp_prec_t prec, mp_rnd_t mode) {
    mpfr_init2(mpfr_ptr(), prec);
    mpfr_set_z(mpfr_ptr(), u, mode);

    MPREAL_MSVC_DEBUGVIEW_CODE;
}

inline mpreal::mpreal(const mpq_t u, mp_prec_t prec, mp_rnd_t mode) {
    mpfr_init2(mpfr_ptr(), prec);
    mpfr_set_q(mpfr_ptr(), u, mode);

    MPREAL_MSVC_DEBUGVIEW_CODE;
}

inline mpreal::mpreal(const double u, mp_prec_t prec, mp_rnd_t mode) {
    mpfr_init2(mpfr_ptr(), prec);

#if (MPREAL_DOUBLE_BITS_OVERFLOW > -1)
    if (fits_in_bits(u, MPREAL_DOUBLE_BITS_OVERFLOW)) {
        mpfr_set_d(mpfr_ptr(), u, mode);
    } else
        throw conversion_overflow();
#else
    mpfr_set_d(mpfr_ptr(), u, mode);
#endif

    MPREAL_MSVC_DEBUGVIEW_CODE;
}

inline mpreal::mpreal(const long double u, mp_prec_t prec, mp_rnd_t mode) {
    mpfr_init2(mpfr_ptr(), prec);
    mpfr_set_ld(mpfr_ptr(), u, mode);

    MPREAL_MSVC_DEBUGVIEW_CODE;
}

inline mpreal::mpreal(const unsigned long long int u, mp_prec_t prec, mp_rnd_t mode) {
    mpfr_init2(mpfr_ptr(), prec);
    mpfr_set_uj(mpfr_ptr(), u, mode);

    MPREAL_MSVC_DEBUGVIEW_CODE;
}

inline mpreal::mpreal(const long long int u, mp_prec_t prec, mp_rnd_t mode) {
    mpfr_init2(mpfr_ptr(), prec);
    mpfr_set_sj(mpfr_ptr(), u, mode);

    MPREAL_MSVC_DEBUGVIEW_CODE;
}

inline mpreal::mpreal(const unsigned long int u, mp_prec_t prec, mp_rnd_t mode) {
    mpfr_init2(mpfr_ptr(), prec);
    mpfr_set_ui(mpfr_ptr(), u, mode);

    MPREAL_MSVC_DEBUGVIEW_CODE;
}

inline mpreal::mpreal(const unsigned int u, mp_prec_t prec, mp_rnd_t mode) {
    mpfr_init2(mpfr_ptr(), prec);
    mpfr_set_ui(mpfr_ptr(), u, mode);

    MPREAL_MSVC_DEBUGVIEW_CODE;
}

inline mpreal::mpreal(const long int u, mp_prec_t prec, mp_rnd_t mode) {
    mpfr_init2(mpfr_ptr(), prec);
    mpfr_set_si(mpfr_ptr(), u, mode);

    MPREAL_MSVC_DEBUGVIEW_CODE;
}

inline mpreal::mpreal(const int u, mp_prec_t prec, mp_rnd_t mode) {
    mpfr_init2(mpfr_ptr(), prec);
    mpfr_set_si(mpfr_ptr(), u, mode);

    MPREAL_MSVC_DEBUGVIEW_CODE;
}

inline mpreal::mpreal(const char *s, mp_prec_t prec, int base, mp_rnd_t mode) {
    mpfr_init2(mpfr_ptr(), prec);
    mpfr_set_str(mpfr_ptr(), s, base, mode);

    MPREAL_MSVC_DEBUGVIEW_CODE;
}

inline mpreal::mpreal(const std::string &s, mp_prec_t prec, int base, mp_rnd_t mode) {
    mpfr_init2(mpfr_ptr(), prec);
    mpfr_set_str(mpfr_ptr(), s.c_str(), base, mode);

    MPREAL_MSVC_DEBUGVIEW_CODE;
}

inline void
mpreal::clear(::mpfr_ptr x) {
#ifdef MPREAL_HAVE_MOVE_SUPPORT
    if (mpfr_is_initialized(x))
#endif
        mpfr_clear(x);
}

inline mpreal::~mpreal() { clear(mpfr_ptr()); }

// internal namespace needed for template magic
namespace internal {

// Use SFINAE to restrict arithmetic operations instantiation only for numeric types
// This is needed for smooth integration with libraries based on expression templates, like Eigen.
// TODO: Do the same for boolean operators.
template<typename ArgumentType>
struct result_type {};

template<>
struct result_type<mpreal> {
    typedef mpreal type;
};
template<>
struct result_type<mpz_t> {
    typedef mpreal type;
};
template<>
struct result_type<mpq_t> {
    typedef mpreal type;
};
template<>
struct result_type<long double> {
    typedef mpreal type;
};
template<>
struct result_type<double> {
    typedef mpreal type;
};
template<>
struct result_type<unsigned long int> {
    typedef mpreal type;
};
template<>
struct result_type<unsigned int> {
    typedef mpreal type;
};
template<>
struct result_type<long int> {
    typedef mpreal type;
};
template<>
struct result_type<int> {
    typedef mpreal type;
};
template<>
struct result_type<long long> {
    typedef mpreal type;
};
template<>
struct result_type<unsigned long long> {
    typedef mpreal type;
};
}

// + Addition
template<typename Rhs>
inline const typename internal::result_type<Rhs>::type
operator+(const mpreal &lhs, const Rhs &rhs) {
    return mpreal(lhs) += rhs;
}

template<typename Lhs>
inline const typename internal::result_type<Lhs>::type
operator+(const Lhs &lhs, const mpreal &rhs) {
    return mpreal(rhs) += lhs;
}

// - Subtraction
template<typename Rhs>
inline const typename internal::result_type<Rhs>::type
operator-(const mpreal &lhs, const Rhs &rhs) {
    return mpreal(lhs) -= rhs;
}

template<typename Lhs>
inline const typename internal::result_type<Lhs>::type
operator-(const Lhs &lhs, const mpreal &rhs) {
    return mpreal(lhs) -= rhs;
}

// * Multiplication
template<typename Rhs>
inline const typename internal::result_type<Rhs>::type
operator*(const mpreal &lhs, const Rhs &rhs) {
    return mpreal(lhs) *= rhs;
}

template<typename Lhs>
inline const typename internal::result_type<Lhs>::type
operator*(const Lhs &lhs, const mpreal &rhs) {
    return mpreal(rhs) *= lhs;
}

// / Division
template<typename Rhs>
inline const typename internal::result_type<Rhs>::type
operator/(const mpreal &lhs, const Rhs &rhs) {
    return mpreal(lhs) /= rhs;
}

template<typename Lhs>
inline const typename internal::result_type<Lhs>::type
operator/(const Lhs &lhs, const mpreal &rhs) {
    return mpreal(lhs) /= rhs;
}

//////////////////////////////////////////////////////////////////////////
// sqrt
const mpreal
sqrt(const unsigned int v, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
sqrt(const long int v, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
sqrt(const int v, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
sqrt(const long double v, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
sqrt(const double v, mp_rnd_t rnd_mode = mpreal::get_default_rnd());

// abs
inline const mpreal
abs(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd());

//////////////////////////////////////////////////////////////////////////
// pow
const mpreal
pow(const mpreal &a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const mpreal &a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const mpreal &a, const long double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const mpreal &a, const double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());

const mpreal
pow(const unsigned int a, const mpreal &b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const long int a, const mpreal &b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const int a, const mpreal &b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const long double a, const mpreal &b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const double a, const mpreal &b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());

const mpreal
pow(const unsigned long int a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const unsigned long int a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const unsigned long int a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const unsigned long int a, const long double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const unsigned long int a, const double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());

const mpreal
pow(const unsigned int a, const unsigned long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const unsigned int a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const unsigned int a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const unsigned int a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const unsigned int a, const long double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const unsigned int a, const double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());

const mpreal
pow(const long int a, const unsigned long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const long int a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const long int a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const long int a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const long int a, const long double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const long int a, const double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());

const mpreal
pow(const int a, const unsigned long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const int a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const int a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const int a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const int a, const long double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const int a, const double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());

const mpreal
pow(const long double a, const long double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const long double a, const unsigned long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const long double a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const long double a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const long double a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());

const mpreal
pow(const double a, const double b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const double a, const unsigned long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const double a, const unsigned int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const double a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
const mpreal
pow(const double a, const int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd());

inline const mpreal
mul_2ui(const mpreal &v, unsigned long int k, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
inline const mpreal
mul_2si(const mpreal &v, long int k, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
inline const mpreal
div_2ui(const mpreal &v, unsigned long int k, mp_rnd_t rnd_mode = mpreal::get_default_rnd());
inline const mpreal
div_2si(const mpreal &v, long int k, mp_rnd_t rnd_mode = mpreal::get_default_rnd());

//////////////////////////////////////////////////////////////////////////
// Estimate machine epsilon for the given precision
// Returns smallest eps such that 1.0 + eps != 1.0
inline mpreal
machine_epsilon(mp_prec_t prec = mpreal::get_default_prec());

// Returns smallest eps such that x + eps != x (relative machine epsilon)
inline mpreal
machine_epsilon(const mpreal &x);

// Gives max & min values for the required precision,
// minval is 'safe' meaning 1 / minval does not overflow
// maxval is 'safe' meaning 1 / maxval does not underflow
inline mpreal
minval(mp_prec_t prec = mpreal::get_default_prec());
inline mpreal
maxval(mp_prec_t prec = mpreal::get_default_prec());

// 'Dirty' equality check 1: |a-b| < min{|a|,|b|} * eps
inline bool
isEqualFuzzy(const mpreal &a, const mpreal &b, const mpreal &eps);

// 'Dirty' equality check 2: |a-b| < min{|a|,|b|} * eps( min{|a|,|b|} )
inline bool
isEqualFuzzy(const mpreal &a, const mpreal &b);

// 'Bitwise' equality check
//  maxUlps - a and b can be apart by maxUlps binary numbers.
inline bool
isEqualUlps(const mpreal &a, const mpreal &b, int maxUlps);

//////////////////////////////////////////////////////////////////////////
// Convert precision in 'bits' to decimal digits and vice versa.
//    bits   = ceil(digits*log[2](10))
//    digits = floor(bits*log[10](2))

inline mp_prec_t
digits2bits(int d);
inline int
bits2digits(mp_prec_t b);

//////////////////////////////////////////////////////////////////////////
// min, max
const mpreal(max)(const mpreal &x, const mpreal &y);
const mpreal(min)(const mpreal &x, const mpreal &y);

//////////////////////////////////////////////////////////////////////////
// Implementation
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// Operators - Assignment
inline mpreal &
mpreal::operator=(const mpreal &v) {
    if (this != &v) {
        mp_prec_t tp = mpfr_get_prec(mpfr_srcptr());
        mp_prec_t vp = mpfr_get_prec(v.mpfr_srcptr());

        if (tp != vp) {
            clear(mpfr_ptr());
            mpfr_init2(mpfr_ptr(), vp);
        }

        mpfr_set(mpfr_ptr(), v.mpfr_srcptr(), mpreal::get_default_rnd());

        MPREAL_MSVC_DEBUGVIEW_CODE;
    }
    return *this;
}

inline mpreal &
mpreal::operator=(const mpf_t v) {
    mpfr_set_f(mpfr_ptr(), v, mpreal::get_default_rnd());

    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator=(const mpz_t v) {
    mpfr_set_z(mpfr_ptr(), v, mpreal::get_default_rnd());

    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator=(const mpq_t v) {
    mpfr_set_q(mpfr_ptr(), v, mpreal::get_default_rnd());

    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator=(const long double v) {
    mpfr_set_ld(mpfr_ptr(), v, mpreal::get_default_rnd());

    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator=(const double v) {
#if (MPREAL_DOUBLE_BITS_OVERFLOW > -1)
    if (fits_in_bits(v, MPREAL_DOUBLE_BITS_OVERFLOW)) {
        mpfr_set_d(mpfr_ptr(), v, mpreal::get_default_rnd());
    } else
        throw conversion_overflow();
#else
    mpfr_set_d(mpfr_ptr(), v, mpreal::get_default_rnd());
#endif

    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator=(const unsigned long int v) {
    mpfr_set_ui(mpfr_ptr(), v, mpreal::get_default_rnd());

    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator=(const unsigned int v) {
    mpfr_set_ui(mpfr_ptr(), v, mpreal::get_default_rnd());

    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator=(const unsigned long long int v) {
    mpfr_set_uj(mpfr_ptr(), v, mpreal::get_default_rnd());

    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator=(const long long int v) {
    mpfr_set_sj(mpfr_ptr(), v, mpreal::get_default_rnd());

    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator=(const long int v) {
    mpfr_set_si(mpfr_ptr(), v, mpreal::get_default_rnd());

    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator=(const int v) {
    mpfr_set_si(mpfr_ptr(), v, mpreal::get_default_rnd());

    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator=(const char *s) {
    // Use other converters for more precise control on base & precision & rounding:
    //
    //        mpreal(const char* s,        mp_prec_t prec, int base, mp_rnd_t mode)
    //        mpreal(const std::string& s,mp_prec_t prec, int base, mp_rnd_t mode)
    //
    // Here we assume base = 10 and we use precision of target variable.

    mpfr_t t;

    mpfr_init2(t, mpfr_get_prec(mpfr_srcptr()));

    if (0 == mpfr_set_str(t, s, 10, mpreal::get_default_rnd())) {
        mpfr_set(mpfr_ptr(), t, mpreal::get_default_rnd());
        MPREAL_MSVC_DEBUGVIEW_CODE;
    }

    clear(t);
    return *this;
}

inline mpreal &
mpreal::operator=(const std::string &s) {
    // Use other converters for more precise control on base & precision & rounding:
    //
    //        mpreal(const char* s,        mp_prec_t prec, int base, mp_rnd_t mode)
    //        mpreal(const std::string& s,mp_prec_t prec, int base, mp_rnd_t mode)
    //
    // Here we assume base = 10 and we use precision of target variable.

    mpfr_t t;

    mpfr_init2(t, mpfr_get_prec(mpfr_srcptr()));

    if (0 == mpfr_set_str(t, s.c_str(), 10, mpreal::get_default_rnd())) {
        mpfr_set(mpfr_ptr(), t, mpreal::get_default_rnd());
        MPREAL_MSVC_DEBUGVIEW_CODE;
    }

    clear(t);
    return *this;
}

template<typename real_t>
inline mpreal &
mpreal::operator=(const std::complex<real_t> &z) {
    return *this = z.real();
}

//////////////////////////////////////////////////////////////////////////
// + Addition
inline mpreal &
mpreal::operator+=(const mpreal &v) {
    mpfr_add(mpfr_ptr(), mpfr_srcptr(), v.mpfr_srcptr(), mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator+=(const mpf_t u) {
    *this += mpreal(u);
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator+=(const mpz_t u) {
    mpfr_add_z(mpfr_ptr(), mpfr_srcptr(), u, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator+=(const mpq_t u) {
    mpfr_add_q(mpfr_ptr(), mpfr_srcptr(), u, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator+=(const long double u) {
    *this += mpreal(u);
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator+=(const double u) {
#if (MPFR_VERSION >= MPFR_VERSION_NUM(2, 4, 0))
    mpfr_add_d(mpfr_ptr(), mpfr_srcptr(), u, mpreal::get_default_rnd());
#else
    *this += mpreal(u);
#endif

    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator+=(const unsigned long int u) {
    mpfr_add_ui(mpfr_ptr(), mpfr_srcptr(), u, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator+=(const unsigned int u) {
    mpfr_add_ui(mpfr_ptr(), mpfr_srcptr(), u, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator+=(const long int u) {
    mpfr_add_si(mpfr_ptr(), mpfr_srcptr(), u, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator+=(const int u) {
    mpfr_add_si(mpfr_ptr(), mpfr_srcptr(), u, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator+=(const long long int u) {
    *this += mpreal(u);
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}
inline mpreal &
mpreal::operator+=(const unsigned long long int u) {
    *this += mpreal(u);
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}
inline mpreal &
mpreal::operator-=(const long long int u) {
    *this -= mpreal(u);
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}
inline mpreal &
mpreal::operator-=(const unsigned long long int u) {
    *this -= mpreal(u);
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}
inline mpreal &
mpreal::operator*=(const long long int u) {
    *this *= mpreal(u);
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}
inline mpreal &
mpreal::operator*=(const unsigned long long int u) {
    *this *= mpreal(u);
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}
inline mpreal &
mpreal::operator/=(const long long int u) {
    *this /= mpreal(u);
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}
inline mpreal &
mpreal::operator/=(const unsigned long long int u) {
    *this /= mpreal(u);
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline const mpreal
mpreal::operator+() const {
    return mpreal(*this);
}

inline const mpreal
operator+(const mpreal &a, const mpreal &b) {
    mpreal c(0, (std::max)(mpfr_get_prec(a.mpfr_ptr()), mpfr_get_prec(b.mpfr_ptr())));
    mpfr_add(c.mpfr_ptr(), a.mpfr_srcptr(), b.mpfr_srcptr(), mpreal::get_default_rnd());
    return c;
}

inline mpreal &
mpreal::operator++() {
    return *this += 1;
}

inline const mpreal
mpreal::operator++(int) {
    mpreal x(*this);
    *this += 1;
    return x;
}

inline mpreal &
mpreal::operator--() {
    return *this -= 1;
}

inline const mpreal
mpreal::operator--(int) {
    mpreal x(*this);
    *this -= 1;
    return x;
}

//////////////////////////////////////////////////////////////////////////
// - Subtraction
inline mpreal &
mpreal::operator-=(const mpreal &v) {
    mpfr_sub(mpfr_ptr(), mpfr_srcptr(), v.mpfr_srcptr(), mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator-=(const mpz_t v) {
    mpfr_sub_z(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator-=(const mpq_t v) {
    mpfr_sub_q(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator-=(const long double v) {
    *this -= mpreal(v);
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator-=(const double v) {
#if (MPFR_VERSION >= MPFR_VERSION_NUM(2, 4, 0))
    mpfr_sub_d(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
#else
    *this -= mpreal(v);
#endif

    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator-=(const unsigned long int v) {
    mpfr_sub_ui(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator-=(const unsigned int v) {
    mpfr_sub_ui(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator-=(const long int v) {
    mpfr_sub_si(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator-=(const int v) {
    mpfr_sub_si(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline const mpreal
mpreal::operator-() const {
    mpreal u(*this);
    mpfr_neg(u.mpfr_ptr(), u.mpfr_srcptr(), mpreal::get_default_rnd());
    return u;
}

inline const mpreal
operator-(const mpreal &a, const mpreal &b) {
    mpreal c(0, (std::max)(mpfr_get_prec(a.mpfr_ptr()), mpfr_get_prec(b.mpfr_ptr())));
    mpfr_sub(c.mpfr_ptr(), a.mpfr_srcptr(), b.mpfr_srcptr(), mpreal::get_default_rnd());
    return c;
}

inline const mpreal
operator-(const double b, const mpreal &a) {
#if (MPFR_VERSION >= MPFR_VERSION_NUM(2, 4, 0))
    mpreal x(0, mpfr_get_prec(a.mpfr_ptr()));
    mpfr_d_sub(x.mpfr_ptr(), b, a.mpfr_srcptr(), mpreal::get_default_rnd());
    return x;
#else
    mpreal x(b, mpfr_get_prec(a.mpfr_ptr()));
    x -= a;
    return x;
#endif
}

inline const mpreal
operator-(const unsigned long int b, const mpreal &a) {
    mpreal x(0, mpfr_get_prec(a.mpfr_ptr()));
    mpfr_ui_sub(x.mpfr_ptr(), b, a.mpfr_srcptr(), mpreal::get_default_rnd());
    return x;
}

inline const mpreal
operator-(const unsigned int b, const mpreal &a) {
    mpreal x(0, mpfr_get_prec(a.mpfr_ptr()));
    mpfr_ui_sub(x.mpfr_ptr(), b, a.mpfr_srcptr(), mpreal::get_default_rnd());
    return x;
}

inline const mpreal
operator-(const long int b, const mpreal &a) {
    mpreal x(0, mpfr_get_prec(a.mpfr_ptr()));
    mpfr_si_sub(x.mpfr_ptr(), b, a.mpfr_srcptr(), mpreal::get_default_rnd());
    return x;
}

inline const mpreal
operator-(const int b, const mpreal &a) {
    mpreal x(0, mpfr_get_prec(a.mpfr_ptr()));
    mpfr_si_sub(x.mpfr_ptr(), b, a.mpfr_srcptr(), mpreal::get_default_rnd());
    return x;
}

//////////////////////////////////////////////////////////////////////////
// * Multiplication
inline mpreal &
mpreal::operator*=(const mpreal &v) {
    mpfr_mul(mpfr_ptr(), mpfr_srcptr(), v.mpfr_srcptr(), mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator*=(const mpz_t v) {
    mpfr_mul_z(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator*=(const mpq_t v) {
    mpfr_mul_q(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator*=(const long double v) {
    *this *= mpreal(v);
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator*=(const double v) {
#if (MPFR_VERSION >= MPFR_VERSION_NUM(2, 4, 0))
    mpfr_mul_d(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
#else
    *this *= mpreal(v);
#endif
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator*=(const unsigned long int v) {
    mpfr_mul_ui(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator*=(const unsigned int v) {
    mpfr_mul_ui(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator*=(const long int v) {
    mpfr_mul_si(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator*=(const int v) {
    mpfr_mul_si(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline const mpreal
operator*(const mpreal &a, const mpreal &b) {
    mpreal c(0, (std::max)(mpfr_get_prec(a.mpfr_ptr()), mpfr_get_prec(b.mpfr_ptr())));
    mpfr_mul(c.mpfr_ptr(), a.mpfr_srcptr(), b.mpfr_srcptr(), mpreal::get_default_rnd());
    return c;
}

//////////////////////////////////////////////////////////////////////////
// / Division
inline mpreal &
mpreal::operator/=(const mpreal &v) {
    mpfr_div(mpfr_ptr(), mpfr_srcptr(), v.mpfr_srcptr(), mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator/=(const mpz_t v) {
    mpfr_div_z(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator/=(const mpq_t v) {
    mpfr_div_q(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator/=(const long double v) {
    *this /= mpreal(v);
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator/=(const double v) {
#if (MPFR_VERSION >= MPFR_VERSION_NUM(2, 4, 0))
    mpfr_div_d(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
#else
    *this /= mpreal(v);
#endif
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator/=(const unsigned long int v) {
    mpfr_div_ui(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator/=(const unsigned int v) {
    mpfr_div_ui(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator/=(const long int v) {
    mpfr_div_si(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator/=(const int v) {
    mpfr_div_si(mpfr_ptr(), mpfr_srcptr(), v, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline const mpreal
operator/(const mpreal &a, const mpreal &b) {
    mpreal c(0, (std::max)(mpfr_get_prec(a.mpfr_srcptr()), mpfr_get_prec(b.mpfr_srcptr())));
    mpfr_div(c.mpfr_ptr(), a.mpfr_srcptr(), b.mpfr_srcptr(), mpreal::get_default_rnd());
    return c;
}

inline const mpreal
operator/(const unsigned long int b, const mpreal &a) {
    mpreal x(0, mpfr_get_prec(a.mpfr_srcptr()));
    mpfr_ui_div(x.mpfr_ptr(), b, a.mpfr_srcptr(), mpreal::get_default_rnd());
    return x;
}

inline const mpreal
operator/(const unsigned int b, const mpreal &a) {
    mpreal x(0, mpfr_get_prec(a.mpfr_srcptr()));
    mpfr_ui_div(x.mpfr_ptr(), b, a.mpfr_srcptr(), mpreal::get_default_rnd());
    return x;
}

inline const mpreal
operator/(const long int b, const mpreal &a) {
    mpreal x(0, mpfr_get_prec(a.mpfr_srcptr()));
    mpfr_si_div(x.mpfr_ptr(), b, a.mpfr_srcptr(), mpreal::get_default_rnd());
    return x;
}

inline const mpreal
operator/(const int b, const mpreal &a) {
    mpreal x(0, mpfr_get_prec(a.mpfr_srcptr()));
    mpfr_si_div(x.mpfr_ptr(), b, a.mpfr_srcptr(), mpreal::get_default_rnd());
    return x;
}

inline const mpreal
operator/(const double b, const mpreal &a) {
#if (MPFR_VERSION >= MPFR_VERSION_NUM(2, 4, 0))
    mpreal x(0, mpfr_get_prec(a.mpfr_srcptr()));
    mpfr_d_div(x.mpfr_ptr(), b, a.mpfr_srcptr(), mpreal::get_default_rnd());
    return x;
#else
    mpreal x(b, mpfr_get_prec(a.mpfr_ptr()));
    x /= a;
    return x;
#endif
}

//////////////////////////////////////////////////////////////////////////
// Shifts operators - Multiplication/Division by power of 2
inline mpreal &
mpreal::operator<<=(const unsigned long int u) {
    mpfr_mul_2ui(mpfr_ptr(), mpfr_srcptr(), u, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator<<=(const unsigned int u) {
    mpfr_mul_2ui(mpfr_ptr(), mpfr_srcptr(), static_cast<unsigned long int>(u), mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator<<=(const long int u) {
    mpfr_mul_2si(mpfr_ptr(), mpfr_srcptr(), u, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator<<=(const int u) {
    mpfr_mul_2si(mpfr_ptr(), mpfr_srcptr(), static_cast<long int>(u), mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator>>=(const unsigned long int u) {
    mpfr_div_2ui(mpfr_ptr(), mpfr_srcptr(), u, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator>>=(const unsigned int u) {
    mpfr_div_2ui(mpfr_ptr(), mpfr_srcptr(), static_cast<unsigned long int>(u), mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator>>=(const long int u) {
    mpfr_div_2si(mpfr_ptr(), mpfr_srcptr(), u, mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::operator>>=(const int u) {
    mpfr_div_2si(mpfr_ptr(), mpfr_srcptr(), static_cast<long int>(u), mpreal::get_default_rnd());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline const mpreal
operator<<(const mpreal &v, const unsigned long int k) {
    return mul_2ui(v, k);
}

inline const mpreal
operator<<(const mpreal &v, const unsigned int k) {
    return mul_2ui(v, static_cast<unsigned long int>(k));
}

inline const mpreal
operator<<(const mpreal &v, const long int k) {
    return mul_2si(v, k);
}

inline const mpreal
operator<<(const mpreal &v, const int k) {
    return mul_2si(v, static_cast<long int>(k));
}

inline const mpreal
operator>>(const mpreal &v, const unsigned long int k) {
    return div_2ui(v, k);
}

inline const mpreal
operator>>(const mpreal &v, const long int k) {
    return div_2si(v, k);
}

inline const mpreal
operator>>(const mpreal &v, const unsigned int k) {
    return div_2ui(v, static_cast<unsigned long int>(k));
}

inline const mpreal
operator>>(const mpreal &v, const int k) {
    return div_2si(v, static_cast<long int>(k));
}

// mul_2ui
inline const mpreal
mul_2ui(const mpreal &v, unsigned long int k, mp_rnd_t rnd_mode) {
    mpreal x(v);
    mpfr_mul_2ui(x.mpfr_ptr(), v.mpfr_srcptr(), k, rnd_mode);
    return x;
}

// mul_2si
inline const mpreal
mul_2si(const mpreal &v, long int k, mp_rnd_t rnd_mode) {
    mpreal x(v);
    mpfr_mul_2si(x.mpfr_ptr(), v.mpfr_srcptr(), k, rnd_mode);
    return x;
}

inline const mpreal
div_2ui(const mpreal &v, unsigned long int k, mp_rnd_t rnd_mode) {
    mpreal x(v);
    mpfr_div_2ui(x.mpfr_ptr(), v.mpfr_srcptr(), k, rnd_mode);
    return x;
}

inline const mpreal
div_2si(const mpreal &v, long int k, mp_rnd_t rnd_mode) {
    mpreal x(v);
    mpfr_div_2si(x.mpfr_ptr(), v.mpfr_srcptr(), k, rnd_mode);
    return x;
}

//////////////////////////////////////////////////////////////////////////
// Relational operators

// WARNING:
//
// Please note that following checks for double-NaN are guaranteed to work only in IEEE math mode:
//
// isnan(b) =  (b != b)
// isnan(b) = !(b == b)  (we use in code below)
//
// Be cautions if you use compiler options which break strict IEEE compliance (e.g. -ffast-math in GCC).
// Use std::isnan instead (C++11).

inline bool
operator>(const mpreal &a, const mpreal &b) {
    return (mpfr_greater_p(a.mpfr_srcptr(), b.mpfr_srcptr()) != 0);
}
inline bool
operator>(const mpreal &a, const unsigned long int b) {
    return !isnan(a) && (mpfr_cmp_ui(a.mpfr_srcptr(), b) > 0);
}
inline bool
operator>(const mpreal &a, const unsigned int b) {
    return !isnan(a) && (mpfr_cmp_ui(a.mpfr_srcptr(), b) > 0);
}
inline bool
operator>(const mpreal &a, const long int b) {
    return !isnan(a) && (mpfr_cmp_si(a.mpfr_srcptr(), b) > 0);
}
inline bool
operator>(const mpreal &a, const int b) {
    return !isnan(a) && (mpfr_cmp_si(a.mpfr_srcptr(), b) > 0);
}
inline bool
operator>(const mpreal &a, const long double b) {
    return !isnan(a) && (b == b) && (mpfr_cmp_ld(a.mpfr_srcptr(), b) > 0);
}
inline bool
operator>(const mpreal &a, const double b) {
    return !isnan(a) && (b == b) && (mpfr_cmp_d(a.mpfr_srcptr(), b) > 0);
}

inline bool
operator>=(const mpreal &a, const mpreal &b) {
    return (mpfr_greaterequal_p(a.mpfr_srcptr(), b.mpfr_srcptr()) != 0);
}
inline bool
operator>=(const mpreal &a, const unsigned long int b) {
    return !isnan(a) && (mpfr_cmp_ui(a.mpfr_srcptr(), b) >= 0);
}
inline bool
operator>=(const mpreal &a, const unsigned int b) {
    return !isnan(a) && (mpfr_cmp_ui(a.mpfr_srcptr(), b) >= 0);
}
inline bool
operator>=(const mpreal &a, const long int b) {
    return !isnan(a) && (mpfr_cmp_si(a.mpfr_srcptr(), b) >= 0);
}
inline bool
operator>=(const mpreal &a, const int b) {
    return !isnan(a) && (mpfr_cmp_si(a.mpfr_srcptr(), b) >= 0);
}
inline bool
operator>=(const mpreal &a, const long double b) {
    return !isnan(a) && (b == b) && (mpfr_cmp_ld(a.mpfr_srcptr(), b) >= 0);
}
inline bool
operator>=(const mpreal &a, const double b) {
    return !isnan(a) && (b == b) && (mpfr_cmp_d(a.mpfr_srcptr(), b) >= 0);
}

inline bool
operator<(const mpreal &a, const mpreal &b) {
    return (mpfr_less_p(a.mpfr_srcptr(), b.mpfr_srcptr()) != 0);
}
inline bool
operator<(const mpreal &a, const unsigned long int b) {
    return !isnan(a) && (mpfr_cmp_ui(a.mpfr_srcptr(), b) < 0);
}
inline bool
operator<(const mpreal &a, const unsigned int b) {
    return !isnan(a) && (mpfr_cmp_ui(a.mpfr_srcptr(), b) < 0);
}
inline bool
operator<(const mpreal &a, const long int b) {
    return !isnan(a) && (mpfr_cmp_si(a.mpfr_srcptr(), b) < 0);
}
inline bool
operator<(const mpreal &a, const int b) {
    return !isnan(a) && (mpfr_cmp_si(a.mpfr_srcptr(), b) < 0);
}
inline bool
operator<(const mpreal &a, const long double b) {
    return !isnan(a) && (b == b) && (mpfr_cmp_ld(a.mpfr_srcptr(), b) < 0);
}
inline bool
operator<(const mpreal &a, const double b) {
    return !isnan(a) && (b == b) && (mpfr_cmp_d(a.mpfr_srcptr(), b) < 0);
}

inline bool
operator<=(const mpreal &a, const mpreal &b) {
    return (mpfr_lessequal_p(a.mpfr_srcptr(), b.mpfr_srcptr()) != 0);
}
inline bool
operator<=(const mpreal &a, const unsigned long int b) {
    return !isnan(a) && (mpfr_cmp_ui(a.mpfr_srcptr(), b) <= 0);
}
inline bool
operator<=(const mpreal &a, const unsigned int b) {
    return !isnan(a) && (mpfr_cmp_ui(a.mpfr_srcptr(), b) <= 0);
}
inline bool
operator<=(const mpreal &a, const long int b) {
    return !isnan(a) && (mpfr_cmp_si(a.mpfr_srcptr(), b) <= 0);
}
inline bool
operator<=(const mpreal &a, const int b) {
    return !isnan(a) && (mpfr_cmp_si(a.mpfr_srcptr(), b) <= 0);
}
inline bool
operator<=(const mpreal &a, const long double b) {
    return !isnan(a) && (b == b) && (mpfr_cmp_ld(a.mpfr_srcptr(), b) <= 0);
}
inline bool
operator<=(const mpreal &a, const double b) {
    return !isnan(a) && (b == b) && (mpfr_cmp_d(a.mpfr_srcptr(), b) <= 0);
}

inline bool
operator==(const mpreal &a, const mpreal &b) {
    return (mpfr_equal_p(a.mpfr_srcptr(), b.mpfr_srcptr()) != 0);
}
inline bool
operator==(const mpreal &a, const unsigned long int b) {
    return !isnan(a) && (mpfr_cmp_ui(a.mpfr_srcptr(), b) == 0);
}
inline bool
operator==(const mpreal &a, const unsigned int b) {
    return !isnan(a) && (mpfr_cmp_ui(a.mpfr_srcptr(), b) == 0);
}
inline bool
operator==(const mpreal &a, const long int b) {
    return !isnan(a) && (mpfr_cmp_si(a.mpfr_srcptr(), b) == 0);
}
inline bool
operator==(const mpreal &a, const int b) {
    return !isnan(a) && (mpfr_cmp_si(a.mpfr_srcptr(), b) == 0);
}
inline bool
operator==(const mpreal &a, const long double b) {
    return !isnan(a) && (b == b) && (mpfr_cmp_ld(a.mpfr_srcptr(), b) == 0);
}
inline bool
operator==(const mpreal &a, const double b) {
    return !isnan(a) && (b == b) && (mpfr_cmp_d(a.mpfr_srcptr(), b) == 0);
}

inline bool
operator!=(const mpreal &a, const mpreal &b) {
    return !(a == b);
}
inline bool
operator!=(const mpreal &a, const unsigned long int b) {
    return !(a == b);
}
inline bool
operator!=(const mpreal &a, const unsigned int b) {
    return !(a == b);
}
inline bool
operator!=(const mpreal &a, const long int b) {
    return !(a == b);
}
inline bool
operator!=(const mpreal &a, const int b) {
    return !(a == b);
}
inline bool
operator!=(const mpreal &a, const long double b) {
    return !(a == b);
}
inline bool
operator!=(const mpreal &a, const double b) {
    return !(a == b);
}

inline bool
isnan(const mpreal &op) {
    return (mpfr_nan_p(op.mpfr_srcptr()) != 0);
}
inline bool
isinf(const mpreal &op) {
    return (mpfr_inf_p(op.mpfr_srcptr()) != 0);
}
inline bool
isfinite(const mpreal &op) {
    return (mpfr_number_p(op.mpfr_srcptr()) != 0);
}
inline bool
iszero(const mpreal &op) {
    return (mpfr_zero_p(op.mpfr_srcptr()) != 0);
}
inline bool
isint(const mpreal &op) {
    return (mpfr_integer_p(op.mpfr_srcptr()) != 0);
}

#if (MPFR_VERSION >= MPFR_VERSION_NUM(3, 0, 0))
inline bool
isregular(const mpreal &op) {
    return (mpfr_regular_p(op.mpfr_srcptr()));
}
#endif

//////////////////////////////////////////////////////////////////////////
// Type Converters
inline bool
mpreal::toBool() const {
    return mpfr_zero_p(mpfr_srcptr()) == 0;
}
inline long
mpreal::toLong(mp_rnd_t mode) const {
    return mpfr_get_si(mpfr_srcptr(), mode);
}
inline unsigned long
mpreal::toULong(mp_rnd_t mode) const {
    return mpfr_get_ui(mpfr_srcptr(), mode);
}
inline float
mpreal::toFloat(mp_rnd_t mode) const {
    return mpfr_get_flt(mpfr_srcptr(), mode);
}
inline double
mpreal::toDouble(mp_rnd_t mode) const {
    return mpfr_get_d(mpfr_srcptr(), mode);
}
inline long double
mpreal::toLDouble(mp_rnd_t mode) const {
    return mpfr_get_ld(mpfr_srcptr(), mode);
}
inline long long
mpreal::toLLong(mp_rnd_t mode) const {
    return mpfr_get_sj(mpfr_srcptr(), mode);
}
inline unsigned long long
mpreal::toULLong(mp_rnd_t mode) const {
    return mpfr_get_uj(mpfr_srcptr(), mode);
}

inline ::mpfr_ptr
mpreal::mpfr_ptr() {
    return mp;
}
inline ::mpfr_srcptr
mpreal::mpfr_ptr() const {
    return mp;
}
inline ::mpfr_srcptr
mpreal::mpfr_srcptr() const {
    return mp;
}

template<class T>
inline std::string
toString(T t, std::ios_base &(*f)(std::ios_base &)) {
    std::ostringstream oss;
    oss << f << t;
    return oss.str();
}

#if (MPFR_VERSION >= MPFR_VERSION_NUM(2, 4, 0))

inline std::string
mpreal::toString(const std::string &format) const {
    char *s = NULL;
    std::string out;

    if (!format.empty()) {
        if (!(mpfr_asprintf(&s, format.c_str(), mpfr_srcptr()) < 0)) {
            out = std::string(s);

            mpfr_free_str(s);
        }
    }

    return out;
}

#endif

inline std::string
mpreal::toString(int n, int b, mp_rnd_t mode) const {
    // TODO: Add extended format specification (f, e, rounding mode) as it done in output operator
    (void)b;
    (void)mode;

#if (MPFR_VERSION >= MPFR_VERSION_NUM(2, 4, 0))

    std::ostringstream format;

    int digits = (n >= 0) ? n : 2 + bits2digits(mpfr_get_prec(mpfr_srcptr()));

    format << "%." << digits << "RNg";

    return toString(format.str());

#else

    char *s, *ns = NULL;
    size_t slen, nslen;
    mp_exp_t exp;
    std::string out;

    if (mpfr_inf_p(mp)) {
        if (mpfr_sgn(mp) > 0)
            return "+Inf";
        else
            return "-Inf";
    }

    if (mpfr_zero_p(mp)) return "0";
    if (mpfr_nan_p(mp)) return "NaN";

    s = mpfr_get_str(NULL, &exp, b, 0, mp, mode);
    ns = mpfr_get_str(NULL, &exp, b, (std::max)(0, n), mp, mode);

    if (s != NULL && ns != NULL) {
        slen = strlen(s);
        nslen = strlen(ns);
        if (nslen <= slen) {
            mpfr_free_str(s);
            s = ns;
            slen = nslen;
        } else {
            mpfr_free_str(ns);
        }

        // Make human eye-friendly formatting if possible
        if (exp > 0 && static_cast<size_t>(exp) < slen) {
            if (s[0] == '-') {
                // Remove zeros starting from right end
                char *ptr = s + slen - 1;
                while (*ptr == '0' && ptr > s + exp) ptr--;

                if (ptr == s + exp)
                    out = std::string(s, exp + 1);
                else
                    out = std::string(s, exp + 1) + '.' + std::string(s + exp + 1, ptr - (s + exp + 1) + 1);

                // out = string(s,exp+1)+'.'+string(s+exp+1);
            } else {
                // Remove zeros starting from right end
                char *ptr = s + slen - 1;
                while (*ptr == '0' && ptr > s + exp - 1) ptr--;

                if (ptr == s + exp - 1)
                    out = std::string(s, exp);
                else
                    out = std::string(s, exp) + '.' + std::string(s + exp, ptr - (s + exp) + 1);

                // out = string(s,exp)+'.'+string(s+exp);
            }

        } else { // exp<0 || exp>slen
            if (s[0] == '-') {
                // Remove zeros starting from right end
                char *ptr = s + slen - 1;
                while (*ptr == '0' && ptr > s + 1) ptr--;

                if (ptr == s + 1)
                    out = std::string(s, 2);
                else
                    out = std::string(s, 2) + '.' + std::string(s + 2, ptr - (s + 2) + 1);

                // out = string(s,2)+'.'+string(s+2);
            } else {
                // Remove zeros starting from right end
                char *ptr = s + slen - 1;
                while (*ptr == '0' && ptr > s) ptr--;

                if (ptr == s)
                    out = std::string(s, 1);
                else
                    out = std::string(s, 1) + '.' + std::string(s + 1, ptr - (s + 1) + 1);

                // out = string(s,1)+'.'+string(s+1);
            }

            // Make final string
            if (--exp) {
                if (exp > 0)
                    out += "e+" + mpfr::toString<mp_exp_t>(exp, std::dec);
                else
                    out += "e" + mpfr::toString<mp_exp_t>(exp, std::dec);
            }
        }

        mpfr_free_str(s);
        return out;
    } else {
        return "conversion error!";
    }
#endif
}


//////////////////////////////////////////////////////////////////////////
// I/O
inline std::ostream &
mpreal::output(std::ostream &os) const {
    std::ostringstream format;
    const std::ios::fmtflags flags = os.flags();

    format << ((flags & std::ios::showpos) ? "%+" : "%");
    if (os.precision() >= 0)
        format << '.' << os.precision() << "R*"
               << ((flags & std::ios::floatfield) == std::ios::fixed        ? 'f'
                   : (flags & std::ios::floatfield) == std::ios::scientific ? 'e'
                                                                            : 'g');
    else
        format << "R*e";

    char *s = NULL;
    if (!(mpfr_asprintf(&s, format.str().c_str(), mpfr::mpreal::get_default_rnd(), mpfr_srcptr()) < 0)) {
        os << std::string(s);
        mpfr_free_str(s);
    }
    return os;
}

inline std::ostream &
operator<<(std::ostream &os, const mpreal &v) {
    return v.output(os);
}

inline std::istream &
operator>>(std::istream &is, mpreal &v) {
    // TODO: use cout::hexfloat and other flags to setup base
    std::string tmp;
    is >> tmp;
    mpfr_set_str(v.mpfr_ptr(), tmp.c_str(), 10, mpreal::get_default_rnd());
    return is;
}

//////////////////////////////////////////////////////////////////////////
//     Bits - decimal digits relation
//        bits   = ceil(digits*log[2](10))
//        digits = floor(bits*log[10](2))

inline mp_prec_t
digits2bits(int d) {
    const double LOG2_10 = 3.3219280948873624;

    return mp_prec_t(std::ceil(d * LOG2_10));
}

inline int
bits2digits(mp_prec_t b) {
    const double LOG10_2 = 0.30102999566398119;

    return int(std::floor(b * LOG10_2));
}

//////////////////////////////////////////////////////////////////////////
// Set/Get number properties
inline mpreal &
mpreal::setSign(int sign, mp_rnd_t RoundingMode) {
    mpfr_setsign(mpfr_ptr(), mpfr_srcptr(), sign < 0, RoundingMode);
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline int
mpreal::getPrecision() const {
    return int(mpfr_get_prec(mpfr_srcptr()));
}

inline mpreal &
mpreal::setPrecision(int Precision, mp_rnd_t RoundingMode) {
    mpfr_prec_round(mpfr_ptr(), Precision, RoundingMode);
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::setInf(int sign) {
    mpfr_set_inf(mpfr_ptr(), sign);
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::setNan() {
    mpfr_set_nan(mpfr_ptr());
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mpreal &
mpreal::setZero(int sign) {
#if (MPFR_VERSION >= MPFR_VERSION_NUM(3, 0, 0))
    mpfr_set_zero(mpfr_ptr(), sign);
#else
    mpfr_set_si(mpfr_ptr(), 0, (mpfr_get_default_rounding_mode)());
    setSign(sign);
#endif

    MPREAL_MSVC_DEBUGVIEW_CODE;
    return *this;
}

inline mp_prec_t
mpreal::get_prec() const {
    return mpfr_get_prec(mpfr_srcptr());
}

inline void
mpreal::set_prec(mp_prec_t prec, mp_rnd_t rnd_mode) {
    mpfr_prec_round(mpfr_ptr(), prec, rnd_mode);
    MPREAL_MSVC_DEBUGVIEW_CODE;
}

inline mp_exp_t
mpreal::get_exp() const {
    return mpfr_get_exp(mpfr_srcptr());
}

inline int
mpreal::set_exp(mp_exp_t e) {
    int x = mpfr_set_exp(mpfr_ptr(), e);
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return x;
}

inline mpreal &
negate(mpreal &x) // -x in place
{
    mpfr_neg(x.mpfr_ptr(), x.mpfr_srcptr(), mpreal::get_default_rnd());
    return x;
}

inline const mpreal
frexp(const mpreal &x, mpfr_exp_t *exp, mp_rnd_t mode = mpreal::get_default_rnd()) {
    mpreal y(x);
#if (MPFR_VERSION >= MPFR_VERSION_NUM(3, 1, 0))
    mpfr_frexp(exp, y.mpfr_ptr(), x.mpfr_srcptr(), mode);
#else
    *exp = mpfr_get_exp(y.mpfr_srcptr());
    mpfr_set_exp(y.mpfr_ptr(), 0);
#endif
    return y;
}

inline const mpreal
frexp(const mpreal &x, int *exp, mp_rnd_t mode = mpreal::get_default_rnd()) {
    mpfr_exp_t e;
    mpreal y = frexp(x, &e, mode);
    *exp = int(e);
    return y;
}

inline const mpreal
ldexp(const mpreal &v, mp_exp_t exp) {
    mpreal x(v);

    // rounding is not important since we are just increasing the exponent (= exact operation)
    mpfr_mul_2si(x.mpfr_ptr(), x.mpfr_srcptr(), exp, mpreal::get_default_rnd());
    return x;
}

inline const mpreal
scalbn(const mpreal &v, mp_exp_t exp) {
    return ldexp(v, exp);
}

inline mpreal
machine_epsilon(mp_prec_t prec) {
    /* the smallest eps such that 1 + eps != 1 */
    return machine_epsilon(mpreal(1, prec));
}

inline mpreal
machine_epsilon(const mpreal &x) {
    /* the smallest eps such that x + eps != x */
    if (x < 0) {
        return nextabove(-x) + x;
    } else {
        return nextabove(x) - x;
    }
}

// minval is 'safe' meaning 1 / minval does not overflow
inline mpreal
minval(mp_prec_t prec) {
    // The smallest positive value in MPFR is 1/2 * 2^emin = 2^(emin - 1). However it gives infinity if inverted.
    // Overall safe minimum is 2^(emin + 1).
    return mpreal(1, prec) << (mpreal::get_emin() + 1);
}

// maxval is 'safe' meaning 1 / maxval does not underflow
inline mpreal
maxval(mp_prec_t prec) {
    /* max = (1 - eps) * 2^emax, eps is machine epsilon */
    return (mpreal(1, prec) - machine_epsilon(prec)) << mpreal::get_emax();
}

inline bool
isEqualUlps(const mpreal &a, const mpreal &b, int maxUlps) {
    return abs(a - b) <= machine_epsilon((max)(abs(a), abs(b))) * maxUlps;
}

inline bool
isEqualFuzzy(const mpreal &a, const mpreal &b, const mpreal &eps) {
    return abs(a - b) <= eps;
}

inline bool
isEqualFuzzy(const mpreal &a, const mpreal &b) {
    return isEqualFuzzy(a, b, machine_epsilon((max)(1, (min)(abs(a), abs(b)))));
}

//////////////////////////////////////////////////////////////////////////
// C++11 sign functions.
inline mpreal
copysign(const mpreal &x, const mpreal &y, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal rop(0, mpfr_get_prec(x.mpfr_ptr()));
    mpfr_setsign(rop.mpfr_ptr(), x.mpfr_srcptr(), mpfr_signbit(y.mpfr_srcptr()), rnd_mode);
    return rop;
}

inline bool
signbit(const mpreal &x) {
    return mpfr_signbit(x.mpfr_srcptr());
}

inline mpreal &
setsignbit(mpreal &x, bool minus, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpfr_setsign(x.mpfr_ptr(), x.mpfr_srcptr(), minus, rnd_mode);
    return x;
}

inline const mpreal
modf(const mpreal &v, mpreal &n) {
    mpreal f(v);

    // rounding is not important since we are using the same number
    mpfr_frac(f.mpfr_ptr(), f.mpfr_srcptr(), mpreal::get_default_rnd());
    mpfr_trunc(n.mpfr_ptr(), v.mpfr_srcptr());
    return f;
}

inline int
mpreal::check_range(int t, mp_rnd_t rnd_mode) {
    return mpfr_check_range(mpfr_ptr(), t, rnd_mode);
}

inline int
mpreal::subnormalize(int t, mp_rnd_t rnd_mode) {
    int r = mpfr_subnormalize(mpfr_ptr(), t, rnd_mode);
    MPREAL_MSVC_DEBUGVIEW_CODE;
    return r;
}

inline mp_exp_t
mpreal::get_emin(void) {
    return mpfr_get_emin();
}

inline int
mpreal::set_emin(mp_exp_t exp) {
    return mpfr_set_emin(exp);
}

inline mp_exp_t
mpreal::get_emax(void) {
    return mpfr_get_emax();
}

inline int
mpreal::set_emax(mp_exp_t exp) {
    return mpfr_set_emax(exp);
}

inline mp_exp_t
mpreal::get_emin_min(void) {
    return mpfr_get_emin_min();
}

inline mp_exp_t
mpreal::get_emin_max(void) {
    return mpfr_get_emin_max();
}

inline mp_exp_t
mpreal::get_emax_min(void) {
    return mpfr_get_emax_min();
}

inline mp_exp_t
mpreal::get_emax_max(void) {
    return mpfr_get_emax_max();
}

//////////////////////////////////////////////////////////////////////////
// Mathematical Functions
//////////////////////////////////////////////////////////////////////////

// Unary function template with single 'mpreal' argument
#define MPREAL_UNARY_MATH_FUNCTION_BODY(f)                                                                             \
    mpreal y(0, mpfr_get_prec(x.mpfr_srcptr()));                                                                       \
    mpfr_##f(y.mpfr_ptr(), x.mpfr_srcptr(), r);                                                                        \
    return y;

// Binary function template with 'mpreal' and 'unsigned long' arguments
#define MPREAL_BINARY_MATH_FUNCTION_UI_BODY(f, u)                                                                      \
    mpreal y(0, mpfr_get_prec(x.mpfr_srcptr()));                                                                       \
    mpfr_##f(y.mpfr_ptr(), x.mpfr_srcptr(), u, r);                                                                     \
    return y;

inline const mpreal
sqr(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(sqr);
}

inline const mpreal
sqrt(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(sqrt);
}

inline const mpreal
sqrt(const unsigned long int x, mp_rnd_t r) {
    mpreal y;
    mpfr_sqrt_ui(y.mpfr_ptr(), x, r);
    return y;
}

inline const mpreal
sqrt(const unsigned int v, mp_rnd_t rnd_mode) {
    return sqrt(static_cast<unsigned long int>(v), rnd_mode);
}

inline const mpreal
sqrt(const long int v, mp_rnd_t rnd_mode) {
    if (v >= 0)
        return sqrt(static_cast<unsigned long int>(v), rnd_mode);
    else
        return mpreal().setNan(); // NaN
}

inline const mpreal
sqrt(const int v, mp_rnd_t rnd_mode) {
    if (v >= 0)
        return sqrt(static_cast<unsigned long int>(v), rnd_mode);
    else
        return mpreal().setNan(); // NaN
}

inline const mpreal
root(const mpreal &x, unsigned long int k, mp_rnd_t r = mpreal::get_default_rnd()) {
    mpreal y(0, mpfr_get_prec(x.mpfr_srcptr()));
#if (MPFR_VERSION >= MPFR_VERSION_NUM(4, 0, 0))
    mpfr_rootn_ui(y.mpfr_ptr(), x.mpfr_srcptr(), k, r);
#else
    mpfr_root(y.mpfr_ptr(), x.mpfr_srcptr(), k, r);
#endif
    return y;
}

inline const mpreal
root(const mpreal &x, const mpreal &n, mp_rnd_t r = mpreal::get_default_rnd()) {
    if (isint(n) && mpfr_sgn(n.mpfr_ptr()) > 0)
        return root(x, n.toULong(), r);
    else {
        mpreal y(0, (std::max)(mpfr_get_prec(x.mpfr_srcptr()), mpfr_get_prec(n.mpfr_srcptr())));

        if (isnan(x) || isnan(n))
            mpfr_set_nan(y.mpfr_ptr());
        else if (isinf(n))
            mpfr_set_si(y.mpfr_ptr(), 1, r);
        else if (iszero(n))
            mpfr_set_inf(y.mpfr_ptr(), 1);
        else {
            mpreal a(0, mpfr_get_prec(x.mpfr_srcptr()));
            mpreal b(0, mpfr_get_prec(n.mpfr_srcptr()));

            mpfr_ui_div(b.mpfr_ptr(), 1, n.mpfr_srcptr(), r);
            mpfr_abs(a.mpfr_ptr(), x.mpfr_srcptr(), r);
            mpfr_pow(y.mpfr_ptr(), a.mpfr_ptr(), b.mpfr_srcptr(), r);

            mpfr_setsign(y.mpfr_ptr(), y.mpfr_srcptr(), mpfr_signbit(x.mpfr_srcptr()), r);
        }

        return y;
    }
}

inline const mpreal
dim(const mpreal &a, const mpreal &b, mp_rnd_t r = mpreal::get_default_rnd()) {
    mpreal y(0, mpfr_get_prec(a.mpfr_srcptr()));
    mpfr_dim(y.mpfr_ptr(), a.mpfr_srcptr(), b.mpfr_srcptr(), r);
    return y;
}

inline int
cmpabs(const mpreal &a, const mpreal &b) {
    return mpfr_cmpabs(a.mpfr_ptr(), b.mpfr_srcptr());
}

inline int
sin_cos(mpreal &s, mpreal &c, const mpreal &v, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    return mpfr_sin_cos(s.mpfr_ptr(), c.mpfr_ptr(), v.mpfr_srcptr(), rnd_mode);
}

inline void
sincos(const mpreal &x, mpreal *sin, mpreal *cos, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpfr_sin_cos(sin->mpfr_ptr(), cos->mpfr_ptr(), x.mpfr_srcptr(), rnd_mode);
}

inline const mpreal
sqrt(const long double v, mp_rnd_t rnd_mode) {
    return sqrt(mpreal(v), rnd_mode);
}
inline const mpreal
sqrt(const double v, mp_rnd_t rnd_mode) {
    return sqrt(mpreal(v), rnd_mode);
}

inline const mpreal
cbrt(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(cbrt);
}
inline const mpreal
fabs(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(abs);
}
inline const mpreal
abs(const mpreal &x, mp_rnd_t r) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(abs);
}
inline const mpreal
log(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(log);
}
inline const mpreal
log2(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(log2);
}
inline const mpreal
log10(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(log10);
}
inline const mpreal
exp(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(exp);
}
inline const mpreal
exp2(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(exp2);
}
inline const mpreal
exp10(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(exp10);
}
inline const mpreal
cos(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(cos);
}
inline const mpreal
sin(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(sin);
}
inline const mpreal
tan(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(tan);
}
inline const mpreal
sec(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(sec);
}
inline const mpreal
csc(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(csc);
}
inline const mpreal
cot(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(cot);
}
inline const mpreal
acos(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(acos);
}
inline const mpreal
asin(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(asin);
}
inline const mpreal
atan(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(atan);
}

inline const mpreal
logb(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    return log2(abs(x), r);
}
inline mp_exp_t
ilogb(const mpreal &x) {
    return x.get_exp();
}

inline const mpreal
acot(const mpreal &v, mp_rnd_t r = mpreal::get_default_rnd()) {
    return atan(1 / v, r);
}
inline const mpreal
asec(const mpreal &v, mp_rnd_t r = mpreal::get_default_rnd()) {
    return acos(1 / v, r);
}
inline const mpreal
acsc(const mpreal &v, mp_rnd_t r = mpreal::get_default_rnd()) {
    return asin(1 / v, r);
}
inline const mpreal
acoth(const mpreal &v, mp_rnd_t r = mpreal::get_default_rnd()) {
    return atanh(1 / v, r);
}
inline const mpreal
asech(const mpreal &v, mp_rnd_t r = mpreal::get_default_rnd()) {
    return acosh(1 / v, r);
}
inline const mpreal
acsch(const mpreal &v, mp_rnd_t r = mpreal::get_default_rnd()) {
    return asinh(1 / v, r);
}

inline const mpreal
cosh(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(cosh);
}
inline const mpreal
sinh(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(sinh);
}
inline const mpreal
tanh(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(tanh);
}
inline const mpreal
sech(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(sech);
}
inline const mpreal
csch(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(csch);
}
inline const mpreal
coth(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(coth);
}
inline const mpreal
acosh(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(acosh);
}
inline const mpreal
asinh(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(asinh);
}
inline const mpreal
atanh(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(atanh);
}

inline const mpreal
log1p(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(log1p);
}
inline const mpreal
expm1(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(expm1);
}
inline const mpreal
eint(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(eint);
}
inline const mpreal
gamma(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(gamma);
}
inline const mpreal
tgamma(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(gamma);
}
inline const mpreal
lngamma(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(lngamma);
}
inline const mpreal
zeta(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(zeta);
}
inline const mpreal
erf(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(erf);
}
inline const mpreal
erfc(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(erfc);
}
inline const mpreal
besselj0(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(j0);
}
inline const mpreal
besselj1(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(j1);
}
inline const mpreal
bessely0(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(y0);
}
inline const mpreal
bessely1(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(y1);
}

#if (MPFR_VERSION >= MPFR_VERSION_NUM(4, 0, 0))
inline const mpreal
gammainc(const mpreal &a, const mpreal &x, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    /*
       The non-normalized (upper) incomplete gamma function of a and x:
       gammainc(a,x) := Gamma(a,x) = int(t^(a-1) * exp(-t), t=x..infinity)
    */
    mpreal y(0, (std::max)(a.getPrecision(), x.getPrecision()));
    mpfr_gamma_inc(y.mpfr_ptr(), a.mpfr_srcptr(), x.mpfr_srcptr(), rnd_mode);
    return y;
}

inline const mpreal
beta(const mpreal &z, const mpreal &w, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    /*
       Beta function, uses formula (6.2.2) from Abramowitz & Stegun:
       beta(z,w) = gamma(z)*gamma(w)/gamma(z+w)
    */
    mpreal y(0, (std::max)(z.getPrecision(), w.getPrecision()));
    mpfr_beta(y.mpfr_ptr(), z.mpfr_srcptr(), w.mpfr_srcptr(), rnd_mode);
    return y;
}

inline const mpreal
log_ui(unsigned long int n,
       mp_prec_t prec = mpreal::get_default_prec(),
       mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    /* Computes natural logarithm of an unsigned long  */
    mpreal y(0, prec);
    mpfr_log_ui(y.mpfr_ptr(), n, rnd_mode);
    return y;
}
#endif

#if (MPFR_VERSION >= MPFR_VERSION_NUM(4, 2, 0))

/* f(x,u) = f(2*pi*x/u) */
inline const mpreal
cosu(const mpreal &x, unsigned long u, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_BINARY_MATH_FUNCTION_UI_BODY(cosu, u);
}
inline const mpreal
sinu(const mpreal &x, unsigned long u, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_BINARY_MATH_FUNCTION_UI_BODY(sinu, u);
}
inline const mpreal
tanu(const mpreal &x, unsigned long u, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_BINARY_MATH_FUNCTION_UI_BODY(tanu, u);
}
inline const mpreal
acosu(const mpreal &x, unsigned long u, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_BINARY_MATH_FUNCTION_UI_BODY(acosu, u);
}
inline const mpreal
asinu(const mpreal &x, unsigned long u, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_BINARY_MATH_FUNCTION_UI_BODY(asinu, u);
}
inline const mpreal
atanu(const mpreal &x, unsigned long u, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_BINARY_MATH_FUNCTION_UI_BODY(atanu, u);
}

/* f(x) = f(pi*x) */
inline const mpreal
cospi(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(cospi);
}
inline const mpreal
sinpi(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(sinpi);
}
inline const mpreal
tanpi(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(tanpi);
}
inline const mpreal
acospi(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(acospi);
}
inline const mpreal
asinpi(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(asinpi);
}
inline const mpreal
atanpi(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(atanpi);
}

inline const mpreal
log2p1(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(log2p1);
} /* log2 (1+x) */
inline const mpreal
log10p1(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(log10p1);
} /* log10(1+x) */
inline const mpreal
exp2m1(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(exp2m1);
} /* 2^x-1      */
inline const mpreal
exp10m1(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(exp10m1);
} /* 10^x-1     */

inline const mpreal
atan2u(const mpreal &y, const mpreal &x, unsigned long u, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    /*
        atan2u(y,x,u) = atan(|y/x|)*u/(2*pi)   for x > 0
        atan2u(y,x,u) = 1-atan(|y/x|)*u/(2*pi) for x < 0
    */
    mpreal a(0, (std::max)(y.getPrecision(), x.getPrecision()));
    mpfr_atan2u(a.mpfr_ptr(), y.mpfr_srcptr(), x.mpfr_srcptr(), u, rnd_mode);
    return a;
}

inline const mpreal
atan2pi(const mpreal &y, const mpreal &x, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    /* atan2pi(x) = atan2u(u=2) */
    mpreal a(0, (std::max)(y.getPrecision(), x.getPrecision()));
    mpfr_atan2pi(a.mpfr_ptr(), y.mpfr_srcptr(), x.mpfr_srcptr(), rnd_mode);
    return a;
}

inline const mpreal
powr(const mpreal &x, const mpreal &y, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    /* powr(x,y) = exp(y*log(x)) */
    mpreal a(0, (std::max)(x.getPrecision(), y.getPrecision()));
    mpfr_powr(a.mpfr_ptr(), x.mpfr_srcptr(), y.mpfr_srcptr(), rnd_mode);
    return a;
}

inline const mpreal
compound(const mpreal &x, long n, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    /* compound(x,n) = (1+x)^n */
    mpreal y(0, x.getPrecision());
    mpfr_compound_si(y.mpfr_ptr(), x.mpfr_srcptr(), n, rnd_mode);
    return y;
}

inline const mpreal
fmod(const mpreal &x, unsigned long u, mp_rnd_t r = mpreal::get_default_rnd()) {
    /* x modulo a machine integer u */
    MPREAL_BINARY_MATH_FUNCTION_UI_BODY(fmod_ui, u);
}
#endif

inline const mpreal
nextpow2(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    mpreal y(0, x.getPrecision());

    if (!iszero(x)) y = ceil(log2(abs(x, r), r));

    return y;
}

inline const mpreal
atan2(const mpreal &y, const mpreal &x, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal a(0, (std::max)(y.getPrecision(), x.getPrecision()));
    mpfr_atan2(a.mpfr_ptr(), y.mpfr_srcptr(), x.mpfr_srcptr(), rnd_mode);
    return a;
}

inline const mpreal
hypot(const mpreal &x, const mpreal &y, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal a(0, (std::max)(y.getPrecision(), x.getPrecision()));
    mpfr_hypot(a.mpfr_ptr(), x.mpfr_srcptr(), y.mpfr_srcptr(), rnd_mode);
    return a;
}

inline const mpreal
hypot(const mpreal &a, const mpreal &b, const mpreal &c) {
    if (isnan(a) || isnan(b) || isnan(c))
        return mpreal().setNan();
    else {
        mpreal absa = abs(a), absb = abs(b), absc = abs(c);
        mpreal w = (std::max)(absa, (std::max)(absb, absc));
        mpreal r;

        if (!iszero(w)) {
            mpreal iw = 1 / w;
            r = w * sqrt(sqr(absa * iw) + sqr(absb * iw) + sqr(absc * iw));
        }

        return r;
    }
}

inline const mpreal
hypot(const mpreal &a, const mpreal &b, const mpreal &c, const mpreal &d) {
    if (isnan(a) || isnan(b) || isnan(c) || isnan(d))
        return mpreal().setNan();
    else {
        mpreal absa = abs(a), absb = abs(b), absc = abs(c), absd = abs(d);
        mpreal w = (std::max)(absa, (std::max)(absb, (std::max)(absc, absd)));
        mpreal r;

        if (!iszero(w)) {
            mpreal iw = 1 / w;
            r = w * sqrt(sqr(absa * iw) + sqr(absb * iw) + sqr(absc * iw) + sqr(absd * iw));
        }

        return r;
    }
}

inline const mpreal
remainder(const mpreal &x, const mpreal &y, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal a(0, (std::max)(y.getPrecision(), x.getPrecision()));
    mpfr_remainder(a.mpfr_ptr(), x.mpfr_srcptr(), y.mpfr_srcptr(), rnd_mode);
    return a;
}

inline const mpreal
remquo(const mpreal &x, const mpreal &y, int *q, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    long lq;
    mpreal a(0, (std::max)(y.getPrecision(), x.getPrecision()));
    mpfr_remquo(a.mpfr_ptr(), &lq, x.mpfr_srcptr(), y.mpfr_srcptr(), rnd_mode);
    if (q) *q = int(lq);
    return a;
}

inline const mpreal
fac_ui(unsigned long int v,
       mp_prec_t prec = mpreal::get_default_prec(),
       mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal x(0, prec);
    mpfr_fac_ui(x.mpfr_ptr(), v, rnd_mode);
    return x;
}


inline const mpreal
lgamma(const mpreal &v, int *signp = 0, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal x(v);
    int tsignp;

    if (signp)
        mpfr_lgamma(x.mpfr_ptr(), signp, v.mpfr_srcptr(), rnd_mode);
    else
        mpfr_lgamma(x.mpfr_ptr(), &tsignp, v.mpfr_srcptr(), rnd_mode);

    return x;
}


inline const mpreal
besseljn(long n, const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    mpreal y(0, x.getPrecision());
    mpfr_jn(y.mpfr_ptr(), n, x.mpfr_srcptr(), r);
    return y;
}

inline const mpreal
besselyn(long n, const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    mpreal y(0, x.getPrecision());
    mpfr_yn(y.mpfr_ptr(), n, x.mpfr_srcptr(), r);
    return y;
}

inline const mpreal
fma(const mpreal &v1, const mpreal &v2, const mpreal &v3, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal a;
    mp_prec_t p1, p2, p3;

    p1 = v1.get_prec();
    p2 = v2.get_prec();
    p3 = v3.get_prec();

    a.set_prec(p3 > p2 ? (p3 > p1 ? p3 : p1) : (p2 > p1 ? p2 : p1));

    mpfr_fma(a.mp, v1.mp, v2.mp, v3.mp, rnd_mode);
    return a;
}

inline const mpreal
fms(const mpreal &v1, const mpreal &v2, const mpreal &v3, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal a;
    mp_prec_t p1, p2, p3;

    p1 = v1.get_prec();
    p2 = v2.get_prec();
    p3 = v3.get_prec();

    a.set_prec(p3 > p2 ? (p3 > p1 ? p3 : p1) : (p2 > p1 ? p2 : p1));

    mpfr_fms(a.mp, v1.mp, v2.mp, v3.mp, rnd_mode);
    return a;
}

inline const mpreal
agm(const mpreal &v1, const mpreal &v2, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal a;
    mp_prec_t p1, p2;

    p1 = v1.get_prec();
    p2 = v2.get_prec();

    a.set_prec(p1 > p2 ? p1 : p2);

    mpfr_agm(a.mp, v1.mp, v2.mp, rnd_mode);

    return a;
}

inline const mpreal
sum(const mpreal tab[], const unsigned long int n, int &status, mp_rnd_t mode = mpreal::get_default_rnd()) {
    mpfr_srcptr *p = new mpfr_srcptr[n];

    for (unsigned long int i = 0; i < n; i++) p[i] = tab[i].mpfr_srcptr();

    mpreal x;
    status = mpfr_sum(x.mpfr_ptr(), (mpfr_ptr *)p, n, mode);

    delete[] p;
    return x;
}

//////////////////////////////////////////////////////////////////////////
// MPFR 2.4.0 Specifics
#if (MPFR_VERSION >= MPFR_VERSION_NUM(2, 4, 0))

inline int
sinh_cosh(mpreal &s, mpreal &c, const mpreal &v, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    return mpfr_sinh_cosh(s.mp, c.mp, v.mp, rnd_mode);
}

inline const mpreal
li2(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(li2);
}

inline const mpreal
rem(const mpreal &x, const mpreal &y, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    /*  R = rem(X,Y) if Y != 0, returns X - n * Y where n = trunc(X/Y). */
    return fmod(x, y, rnd_mode);
}

inline const mpreal
mod(const mpreal &x, const mpreal &y, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    (void)rnd_mode;

    /*

    m = mod(x,y) if y != 0, returns x - n*y where n = floor(x/y)

    The following are true by convention:
    - mod(x,0) is x
    - mod(x,x) is 0
    - mod(x,y) for x != y and y != 0 has the same sign as y.

    */

    if (iszero(y)) return x;
    if (x == y) return 0;

    mpreal m = x - floor(x / y) * y;

    return copysign(abs(m), y); // make sure result has the same sign as Y
}

inline const mpreal
fmod(const mpreal &x, const mpreal &y, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal a;
    mp_prec_t yp, xp;

    yp = y.get_prec();
    xp = x.get_prec();

    a.set_prec(yp > xp ? yp : xp);

    mpfr_fmod(a.mp, x.mp, y.mp, rnd_mode);

    return a;
}

inline const mpreal
rec_sqrt(const mpreal &v, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal x(v);
    mpfr_rec_sqrt(x.mp, v.mp, rnd_mode);
    return x;
}
#endif //  MPFR 2.4.0 Specifics

//////////////////////////////////////////////////////////////////////////
// MPFR 3.0.0 Specifics
#if (MPFR_VERSION >= MPFR_VERSION_NUM(3, 0, 0))
inline const mpreal
digamma(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(digamma);
}
inline const mpreal
ai(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(ai);
}
#endif // MPFR 3.0.0 Specifics

//////////////////////////////////////////////////////////////////////////
// Constants
inline const mpreal
const_log2(mp_prec_t p = mpreal::get_default_prec(), mp_rnd_t r = mpreal::get_default_rnd()) {
    mpreal x(0, p);
    mpfr_const_log2(x.mpfr_ptr(), r);
    return x;
}

inline const mpreal
const_pi(mp_prec_t p = mpreal::get_default_prec(), mp_rnd_t r = mpreal::get_default_rnd()) {
    mpreal x(0, p);
    mpfr_const_pi(x.mpfr_ptr(), r);
    return x;
}

inline const mpreal
const_euler(mp_prec_t p = mpreal::get_default_prec(), mp_rnd_t r = mpreal::get_default_rnd()) {
    mpreal x(0, p);
    mpfr_const_euler(x.mpfr_ptr(), r);
    return x;
}

inline const mpreal
const_catalan(mp_prec_t p = mpreal::get_default_prec(), mp_rnd_t r = mpreal::get_default_rnd()) {
    mpreal x(0, p);
    mpfr_const_catalan(x.mpfr_ptr(), r);
    return x;
}

inline const mpreal
const_infinity(int sign = 1, mp_prec_t p = mpreal::get_default_prec()) {
    mpreal x(0, p);
    mpfr_set_inf(x.mpfr_ptr(), sign);
    return x;
}

//////////////////////////////////////////////////////////////////////////
// Integer Related Functions
inline const mpreal
ceil(const mpreal &v) {
    mpreal x(v);
    mpfr_ceil(x.mp, v.mp);
    return x;
}

inline const mpreal
floor(const mpreal &v) {
    mpreal x(v);
    mpfr_floor(x.mp, v.mp);
    return x;
}

inline const mpreal
round(const mpreal &v) {
    mpreal x(v);
    mpfr_round(x.mp, v.mp);
    return x;
}

inline long
lround(const mpreal &v) {
    long r = std::numeric_limits<long>::min();
    mpreal x = round(v);
    if (abs(x) < -mpreal(r)) // Assume mpreal(LONG_MIN) is exact
        r = x.toLong();
    return r;
}

inline long long
llround(const mpreal &v) {
    long long r = std::numeric_limits<long long>::min();
    mpreal x = round(v);
    if (abs(x) < -mpreal(r)) // Assume mpreal(LLONG_MIN) is exact
        r = x.toLLong();
    return r;
}

inline const mpreal
trunc(const mpreal &v) {
    mpreal x(v);
    mpfr_trunc(x.mp, v.mp);
    return x;
}

inline const mpreal
rint(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(rint);
}
inline const mpreal
rint_ceil(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(rint_ceil);
}
inline const mpreal
rint_floor(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(rint_floor);
}
inline const mpreal
rint_round(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(rint_round);
}
inline const mpreal
rint_trunc(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(rint_trunc);
}
inline const mpreal
frac(const mpreal &x, mp_rnd_t r = mpreal::get_default_rnd()) {
    MPREAL_UNARY_MATH_FUNCTION_BODY(frac);
}

//////////////////////////////////////////////////////////////////////////
// Miscellaneous Functions
inline int
sgn(const mpreal &op) {
    // Please note, this is classic signum function which ignores sign of zero.
    // Use signbit if you need sign of zero.
    return mpfr_sgn(op.mpfr_srcptr());
}

//////////////////////////////////////////////////////////////////////////
// Miscellaneous Functions
inline void
swap(mpreal &a, mpreal &b) {
    mpfr_swap(a.mpfr_ptr(), b.mpfr_ptr());
}
inline const mpreal(max)(const mpreal &x, const mpreal &y) { return (x < y ? y : x); }
inline const mpreal(min)(const mpreal &x, const mpreal &y) { return (y < x ? y : x); }

inline const mpreal
fmax(const mpreal &x, const mpreal &y, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal a;
    mpfr_max(a.mp, x.mp, y.mp, rnd_mode);
    return a;
}

inline const mpreal
fmin(const mpreal &x, const mpreal &y, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal a;
    mpfr_min(a.mp, x.mp, y.mp, rnd_mode);
    return a;
}

inline const mpreal
nexttoward(const mpreal &x, const mpreal &y) {
    mpreal a(x);
    mpfr_nexttoward(a.mp, y.mp);
    return a;
}

inline const mpreal
nextabove(const mpreal &x) {
    mpreal a(x);
    mpfr_nextabove(a.mp);
    return a;
}

inline const mpreal
nextbelow(const mpreal &x) {
    mpreal a(x);
    mpfr_nextbelow(a.mp);
    return a;
}

inline const mpreal
urandomb(gmp_randstate_t &state) {
    mpreal x;
    mpfr_urandomb(x.mpfr_ptr(), state);
    return x;
}

#if (MPFR_VERSION >= MPFR_VERSION_NUM(3, 0, 0))
inline const mpreal
urandom(gmp_randstate_t &state, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal x;
    mpfr_urandom(x.mpfr_ptr(), state, rnd_mode);
    return x;
}
#endif

#if (MPFR_VERSION <= MPFR_VERSION_NUM(2, 4, 2))
inline const mpreal
random2(mp_size_t size, mp_exp_t exp) {
    mpreal x;
    mpfr_random2(x.mpfr_ptr(), size, exp);
    return x;
}
#endif

// Uniformly distributed random number generation
// a = random(seed); <- initialization & first random number generation
// a = random();     <- next random numbers generation
// seed != 0
inline const mpreal
random(unsigned int seed = 0) {
#if (MPFR_VERSION >= MPFR_VERSION_NUM(3, 0, 0))
    static gmp_randstate_t state;
    static bool initialize = true;

    if (initialize) {
        gmp_randinit_default(state);
        gmp_randseed_ui(state, 0);
        initialize = false;
    }

    if (seed != 0) gmp_randseed_ui(state, seed);

    return mpfr::urandom(state);
#else
    if (seed != 0) std::srand(seed);
    return mpfr::mpreal(std::rand() / (double)RAND_MAX);
#endif
}

#if (MPFR_VERSION >= MPFR_VERSION_NUM(3, 1, 0))
inline const mpreal
grandom(gmp_randstate_t &state, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal x;
#if (MPFR_VERSION >= MPFR_VERSION_NUM(4, 0, 0))
    mpfr_nrandom(x.mpfr_ptr(), state, rnd_mode);
#else
    mpfr_grandom(x.mpfr_ptr(), NULL, state, rnd_mode);
#endif
    return x;
}

inline const mpreal
grandom(unsigned int seed = 0) {
    static gmp_randstate_t state;
    static bool initialize = true;

    if (initialize) {
        gmp_randinit_default(state);
        gmp_randseed_ui(state, 0);
        initialize = false;
    }

    if (seed != 0) gmp_randseed_ui(state, seed);

    return mpfr::grandom(state);
}
#endif

//////////////////////////////////////////////////////////////////////////
// Set/Get global properties
inline void
mpreal::set_default_prec(mp_prec_t prec) {
    mpfr_set_default_prec(prec);
}

inline void
mpreal::set_default_rnd(mp_rnd_t rnd_mode) {
    mpfr_set_default_rounding_mode(rnd_mode);
}

inline bool
mpreal::fits_in_bits(double x, int n) {
    int i;
    double t;
    return MPREAL_IS_INF(x) || (std::modf(std::ldexp(std::frexp(x, &i), n), &t) == 0.0);
}

inline const mpreal
pow(const mpreal &a, const mpreal &b, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal x(a);
    mpfr_pow(x.mp, x.mp, b.mp, rnd_mode);
    return x;
}

inline const mpreal
pow(const mpreal &a, const mpz_t b, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal x(a);
    mpfr_pow_z(x.mp, x.mp, b, rnd_mode);
    return x;
}

inline const mpreal
pow(const mpreal &a, const long long b, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    (void)rnd_mode;
    return pow(a, mpreal(b));
}

inline const mpreal
pow(const mpreal &a, const unsigned long long b, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    (void)rnd_mode;
    return pow(a, mpreal(b));
}

inline const mpreal
pow(const mpreal &a, const unsigned long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal x(a);
    mpfr_pow_ui(x.mp, x.mp, b, rnd_mode);
    return x;
}

inline const mpreal
pow(const mpreal &a, const unsigned int b, mp_rnd_t rnd_mode) {
    return pow(a, static_cast<unsigned long int>(b), rnd_mode);
}

inline const mpreal
pow(const mpreal &a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal x(a);
    mpfr_pow_si(x.mp, x.mp, b, rnd_mode);
    return x;
}

inline const mpreal
pow(const mpreal &a, const int b, mp_rnd_t rnd_mode) {
    return pow(a, static_cast<long int>(b), rnd_mode);
}

inline const mpreal
pow(const mpreal &a, const long double b, mp_rnd_t rnd_mode) {
    return pow(a, mpreal(b), rnd_mode);
}

inline const mpreal
pow(const mpreal &a, const double b, mp_rnd_t rnd_mode) {
    return pow(a, mpreal(b), rnd_mode);
}

inline const mpreal
pow(const unsigned long int a, const mpreal &b, mp_rnd_t rnd_mode = mpreal::get_default_rnd()) {
    mpreal x(a);
    mpfr_ui_pow(x.mp, a, b.mp, rnd_mode);
    return x;
}

inline const mpreal
pow(const unsigned int a, const mpreal &b, mp_rnd_t rnd_mode) {
    return pow(static_cast<unsigned long int>(a), b, rnd_mode);
}

inline const mpreal
pow(const long int a, const mpreal &b, mp_rnd_t rnd_mode) {
    if (a >= 0)
        return pow(static_cast<unsigned long int>(a), b, rnd_mode);
    else
        return pow(mpreal(a), b, rnd_mode);
}

inline const mpreal
pow(const int a, const mpreal &b, mp_rnd_t rnd_mode) {
    if (a >= 0)
        return pow(static_cast<unsigned long int>(a), b, rnd_mode);
    else
        return pow(mpreal(a), b, rnd_mode);
}

inline const mpreal
pow(const long double a, const mpreal &b, mp_rnd_t rnd_mode) {
    return pow(mpreal(a), b, rnd_mode);
}

inline const mpreal
pow(const double a, const mpreal &b, mp_rnd_t rnd_mode) {
    return pow(mpreal(a), b, rnd_mode);
}

// pow unsigned long int
inline const mpreal
pow(const unsigned long int a, const unsigned long int b, mp_rnd_t rnd_mode) {
    mpreal x(a);
    mpfr_ui_pow_ui(x.mp, a, b, rnd_mode);
    return x;
}

inline const mpreal
pow(const unsigned long int a, const unsigned int b, mp_rnd_t rnd_mode) {
    return pow(a, static_cast<unsigned long int>(b), rnd_mode); // mpfr_ui_pow_ui
}

inline const mpreal
pow(const unsigned long int a, const long int b, mp_rnd_t rnd_mode) {
    if (b > 0)
        return pow(a, static_cast<unsigned long int>(b), rnd_mode); // mpfr_ui_pow_ui
    else
        return pow(a, mpreal(b), rnd_mode); // mpfr_ui_pow
}

inline const mpreal
pow(const unsigned long int a, const int b, mp_rnd_t rnd_mode) {
    if (b > 0)
        return pow(a, static_cast<unsigned long int>(b), rnd_mode); // mpfr_ui_pow_ui
    else
        return pow(a, mpreal(b), rnd_mode); // mpfr_ui_pow
}

inline const mpreal
pow(const unsigned long int a, const long double b, mp_rnd_t rnd_mode) {
    return pow(a, mpreal(b), rnd_mode); // mpfr_ui_pow
}

inline const mpreal
pow(const unsigned long int a, const double b, mp_rnd_t rnd_mode) {
    return pow(a, mpreal(b), rnd_mode); // mpfr_ui_pow
}

// pow unsigned int
inline const mpreal
pow(const unsigned int a, const unsigned long int b, mp_rnd_t rnd_mode) {
    return pow(static_cast<unsigned long int>(a), b, rnd_mode); // mpfr_ui_pow_ui
}

inline const mpreal
pow(const unsigned int a, const unsigned int b, mp_rnd_t rnd_mode) {
    return pow(static_cast<unsigned long int>(a), static_cast<unsigned long int>(b), rnd_mode); // mpfr_ui_pow_ui
}

inline const mpreal
pow(const unsigned int a, const long int b, mp_rnd_t rnd_mode) {
    if (b > 0)
        return pow(static_cast<unsigned long int>(a), static_cast<unsigned long int>(b), rnd_mode); // mpfr_ui_pow_ui
    else
        return pow(static_cast<unsigned long int>(a), mpreal(b), rnd_mode); // mpfr_ui_pow
}

inline const mpreal
pow(const unsigned int a, const int b, mp_rnd_t rnd_mode) {
    if (b > 0)
        return pow(static_cast<unsigned long int>(a), static_cast<unsigned long int>(b), rnd_mode); // mpfr_ui_pow_ui
    else
        return pow(static_cast<unsigned long int>(a), mpreal(b), rnd_mode); // mpfr_ui_pow
}

inline const mpreal
pow(const unsigned int a, const long double b, mp_rnd_t rnd_mode) {
    return pow(static_cast<unsigned long int>(a), mpreal(b), rnd_mode); // mpfr_ui_pow
}

inline const mpreal
pow(const unsigned int a, const double b, mp_rnd_t rnd_mode) {
    return pow(static_cast<unsigned long int>(a), mpreal(b), rnd_mode); // mpfr_ui_pow
}

// pow long int
inline const mpreal
pow(const long int a, const unsigned long int b, mp_rnd_t rnd_mode) {
    if (a > 0)
        return pow(static_cast<unsigned long int>(a), b, rnd_mode); // mpfr_ui_pow_ui
    else
        return pow(mpreal(a), b, rnd_mode); // mpfr_pow_ui
}

inline const mpreal
pow(const long int a, const unsigned int b, mp_rnd_t rnd_mode) {
    if (a > 0)
        return pow(static_cast<unsigned long int>(a), static_cast<unsigned long int>(b), rnd_mode); // mpfr_ui_pow_ui
    else
        return pow(mpreal(a), static_cast<unsigned long int>(b), rnd_mode); // mpfr_pow_ui
}

inline const mpreal
pow(const long int a, const long int b, mp_rnd_t rnd_mode) {
    if (a > 0) {
        if (b > 0)
            return pow(static_cast<unsigned long int>(a), static_cast<unsigned long int>(b), rnd_mode); // mpfr_ui_pow_ui
        else
            return pow(static_cast<unsigned long int>(a), mpreal(b), rnd_mode); // mpfr_ui_pow
    } else {
        return pow(mpreal(a), b, rnd_mode); // mpfr_pow_si
    }
}

inline const mpreal
pow(const long int a, const int b, mp_rnd_t rnd_mode) {
    if (a > 0) {
        if (b > 0)
            return pow(static_cast<unsigned long int>(a), static_cast<unsigned long int>(b), rnd_mode); // mpfr_ui_pow_ui
        else
            return pow(static_cast<unsigned long int>(a), mpreal(b), rnd_mode); // mpfr_ui_pow
    } else {
        return pow(mpreal(a), static_cast<long int>(b), rnd_mode); // mpfr_pow_si
    }
}

inline const mpreal
pow(const long int a, const long double b, mp_rnd_t rnd_mode) {
    if (a >= 0)
        return pow(static_cast<unsigned long int>(a), mpreal(b), rnd_mode); // mpfr_ui_pow
    else
        return pow(mpreal(a), mpreal(b), rnd_mode); // mpfr_pow
}

inline const mpreal
pow(const long int a, const double b, mp_rnd_t rnd_mode) {
    if (a >= 0)
        return pow(static_cast<unsigned long int>(a), mpreal(b), rnd_mode); // mpfr_ui_pow
    else
        return pow(mpreal(a), mpreal(b), rnd_mode); // mpfr_pow
}

// pow int
inline const mpreal
pow(const int a, const unsigned long int b, mp_rnd_t rnd_mode) {
    if (a > 0)
        return pow(static_cast<unsigned long int>(a), b, rnd_mode); // mpfr_ui_pow_ui
    else
        return pow(mpreal(a), b, rnd_mode); // mpfr_pow_ui
}

inline const mpreal
pow(const int a, const unsigned int b, mp_rnd_t rnd_mode) {
    if (a > 0)
        return pow(static_cast<unsigned long int>(a), static_cast<unsigned long int>(b), rnd_mode); // mpfr_ui_pow_ui
    else
        return pow(mpreal(a), static_cast<unsigned long int>(b), rnd_mode); // mpfr_pow_ui
}

inline const mpreal
pow(const int a, const long int b, mp_rnd_t rnd_mode) {
    if (a > 0) {
        if (b > 0)
            return pow(static_cast<unsigned long int>(a), static_cast<unsigned long int>(b), rnd_mode); // mpfr_ui_pow_ui
        else
            return pow(static_cast<unsigned long int>(a), mpreal(b), rnd_mode); // mpfr_ui_pow
    } else {
        return pow(mpreal(a), b, rnd_mode); // mpfr_pow_si
    }
}

inline const mpreal
pow(const int a, const int b, mp_rnd_t rnd_mode) {
    if (a > 0) {
        if (b > 0)
            return pow(static_cast<unsigned long int>(a), static_cast<unsigned long int>(b), rnd_mode); // mpfr_ui_pow_ui
        else
            return pow(static_cast<unsigned long int>(a), mpreal(b), rnd_mode); // mpfr_ui_pow
    } else {
        return pow(mpreal(a), static_cast<long int>(b), rnd_mode); // mpfr_pow_si
    }
}

inline const mpreal
pow(const int a, const long double b, mp_rnd_t rnd_mode) {
    if (a >= 0)
        return pow(static_cast<unsigned long int>(a), mpreal(b), rnd_mode); // mpfr_ui_pow
    else
        return pow(mpreal(a), mpreal(b), rnd_mode); // mpfr_pow
}

inline const mpreal
pow(const int a, const double b, mp_rnd_t rnd_mode) {
    if (a >= 0)
        return pow(static_cast<unsigned long int>(a), mpreal(b), rnd_mode); // mpfr_ui_pow
    else
        return pow(mpreal(a), mpreal(b), rnd_mode); // mpfr_pow
}

// pow long double
inline const mpreal
pow(const long double a, const long double b, mp_rnd_t rnd_mode) {
    return pow(mpreal(a), mpreal(b), rnd_mode);
}

inline const mpreal
pow(const long double a, const unsigned long int b, mp_rnd_t rnd_mode) {
    return pow(mpreal(a), b, rnd_mode); // mpfr_pow_ui
}

inline const mpreal
pow(const long double a, const unsigned int b, mp_rnd_t rnd_mode) {
    return pow(mpreal(a), static_cast<unsigned long int>(b), rnd_mode); // mpfr_pow_ui
}

inline const mpreal
pow(const long double a, const long int b, mp_rnd_t rnd_mode) {
    return pow(mpreal(a), b, rnd_mode); // mpfr_pow_si
}

inline const mpreal
pow(const long double a, const int b, mp_rnd_t rnd_mode) {
    return pow(mpreal(a), static_cast<long int>(b), rnd_mode); // mpfr_pow_si
}

inline const mpreal
pow(const double a, const double b, mp_rnd_t rnd_mode) {
    return pow(mpreal(a), mpreal(b), rnd_mode);
}

inline const mpreal
pow(const double a, const unsigned long int b, mp_rnd_t rnd_mode) {
    return pow(mpreal(a), b, rnd_mode); // mpfr_pow_ui
}

inline const mpreal
pow(const double a, const unsigned int b, mp_rnd_t rnd_mode) {
    return pow(mpreal(a), static_cast<unsigned long int>(b), rnd_mode); // mpfr_pow_ui
}

inline const mpreal
pow(const double a, const long int b, mp_rnd_t rnd_mode) {
    return pow(mpreal(a), b, rnd_mode); // mpfr_pow_si
}

inline const mpreal
pow(const double a, const int b, mp_rnd_t rnd_mode) {
    return pow(mpreal(a), static_cast<long int>(b), rnd_mode); // mpfr_pow_si
}
} // End of mpfr namespace

// Explicit specialization of std::swap for mpreal numbers
// Thus standard algorithms will use efficient version of swap (due to Koenig lookup)
// Non-throwing swap C++ idiom: http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-throwing_swap
namespace std {
template<>
inline void
swap(mpfr::mpreal &x, mpfr::mpreal &y) {
    return mpfr::swap(x, y);
}

template<>
class numeric_limits<mpfr::mpreal> {
  public:
    static const bool is_specialized = true;
    static const bool is_signed = true;
    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;

    static const bool has_infinity = true;
    static const bool has_quiet_NaN = true;
    static const bool has_signaling_NaN = true;

    static const bool is_iec559 = true; // = IEEE 754
    static const bool is_bounded = true;
    static const bool is_modulo = false;
    static const bool traps = true;
    static const bool tinyness_before = true;

    static const float_denorm_style has_denorm = denorm_absent;

    inline static mpfr::mpreal(min)(mp_prec_t precision = mpfr::mpreal::get_default_prec()) {
        return mpfr::minval(precision);
    }
    inline static mpfr::mpreal(max)(mp_prec_t precision = mpfr::mpreal::get_default_prec()) {
        return mpfr::maxval(precision);
    }
    inline static mpfr::mpreal lowest(mp_prec_t precision = mpfr::mpreal::get_default_prec()) {
        return -mpfr::maxval(precision);
    }

    // Returns smallest eps such that 1 + eps != 1 (classic machine epsilon)
    inline static mpfr::mpreal epsilon(mp_prec_t precision = mpfr::mpreal::get_default_prec()) {
        return mpfr::machine_epsilon(precision);
    }

    // Returns smallest eps such that x + eps != x (relative machine epsilon)
    inline static mpfr::mpreal epsilon(const mpfr::mpreal &x) { return mpfr::machine_epsilon(x); }

    inline static mpfr::mpreal round_error(mp_prec_t precision = mpfr::mpreal::get_default_prec()) {
        mp_rnd_t r = mpfr::mpreal::get_default_rnd();

        if (r == GMP_RNDN)
            return mpfr::mpreal(0.5, precision);
        else
            return mpfr::mpreal(1.0, precision);
    }

    inline static const mpfr::mpreal infinity() { return mpfr::const_infinity(); }
    inline static const mpfr::mpreal quiet_NaN() { return mpfr::mpreal().setNan(); }
    inline static const mpfr::mpreal signaling_NaN() { return mpfr::mpreal().setNan(); }
    inline static const mpfr::mpreal denorm_min() { return (min)(); }

    // Please note, exponent range is not fixed in MPFR
    static const int min_exponent = MPFR_EMIN_DEFAULT;
    static const int max_exponent = MPFR_EMAX_DEFAULT;
    MPREAL_PERMISSIVE_EXPR static const int min_exponent10 = (int)(MPFR_EMIN_DEFAULT * 0.3010299956639811);
    MPREAL_PERMISSIVE_EXPR static const int max_exponent10 = (int)(MPFR_EMAX_DEFAULT * 0.3010299956639811);

#ifdef MPREAL_HAVE_DYNAMIC_STD_NUMERIC_LIMITS

    // Following members should be constant according to standard, but they can be variable in MPFR
    // So we define them as functions here.
    //
    // This is preferable way for std::numeric_limits<mpfr::mpreal> specialization.
    // But it is incompatible with standard std::numeric_limits and might not work with other libraries, e.g. boost.
    // See below for compatible implementation.
    inline static float_round_style round_style() {
        mp_rnd_t r = mpfr::mpreal::get_default_rnd();

        switch (r) {
            case GMP_RNDN:
                return round_to_nearest;
            case GMP_RNDZ:
                return round_toward_zero;
            case GMP_RNDU:
                return round_toward_infinity;
            case GMP_RNDD:
                return round_toward_neg_infinity;
            default:
                return round_indeterminate;
        }
    }

    inline static int digits() { return int(mpfr::mpreal::get_default_prec()); }
    inline static int digits(const mpfr::mpreal &x) { return x.getPrecision(); }

    inline static int digits10(mp_prec_t precision = mpfr::mpreal::get_default_prec()) {
        return mpfr::bits2digits(precision);
    }

    inline static int digits10(const mpfr::mpreal &x) { return mpfr::bits2digits(x.getPrecision()); }

    inline static int max_digits10(mp_prec_t precision = mpfr::mpreal::get_default_prec()) {
        return digits10(precision);
    }
#else
    // Digits and round_style are NOT constants when it comes to mpreal.
    // If possible, please use functions digits() and round_style() defined above.
    //
    // These (default) values are preserved for compatibility with existing libraries, e.g. boost.
    // Change them accordingly to your application.
    //
    // For example, if you use 256 bits of precision uniformly in your program, then:
    // digits       = 256
    // digits10     = 77
    // max_digits10 = 78
    //
    // Approximate formula for decimal digits is: digits10 = floor(log10(2) * digits). See bits2digits() for more
    // details.

    static const std::float_round_style round_style = round_to_nearest;
    static const int digits = 53;
    static const int digits10 = 15;
    static const int max_digits10 = 16;
#endif
};

}

#endif /* __MPREAL_H__ */

================
File: README.md
================
## Building with vcpkg

This project uses vcpkg for dependency management. To build:

1. Install vcpkg if you haven't already:
```bash
git clone https://github.com/Microsoft/vcpkg.git
./vcpkg/bootstrap-vcpkg.sh  # or bootstrap-vcpkg.bat on Windows
```

2. Build the project:
```bash
cmake -B build -S . -DCMAKE_TOOLCHAIN_FILE=[path to vcpkg]/scripts/buildsystems/vcpkg.cmake
cmake --build build
```

Replace `[path to vcpkg]` with the actual path where you installed vcpkg.

For convenience, you can set the `VCPKG_ROOT` environment variable to your vcpkg installation directory:
```bash
export VCPKG_ROOT=/path/to/vcpkg
```

Then build with:
```bash
cmake -B build -S . -DCMAKE_TOOLCHAIN_FILE=$VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake
cmake --build build
```

================
File: vcpkg.json
================
{
    "name": "hc-mc",
    "version": "1.0.0",
    "description": "A testbed for homotopy continuation methods",
    "dependencies": [
        "eigen3",
        "cppad",
        {
            "name": "doctest",
            "platform": "!windows"
        }
    ],
    "builtin-baseline": "d221c5d2cbadf35ceb266cbb95750a940b103b65"
}

This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-06T07:13:14.298Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
examples/
  AAA.cpp
  time_derivatives.cpp
project/
  HC-MC/
    include/
      AAA.hpp
      hbtaylor.hpp
      HC-MC.hpp
      integration_interface.hpp
      ODESystem.hpp
      types.hpp
    tests/
      pt_tests.cpp
    main.cpp

================================================================
Repository Files
================================================================

================
File: examples/AAA.cpp
================
#include "AAA.hpp"
#include "mpreal.h"
#include <complex>
#include <iostream>
#include <vector>

template<typename T>
T
Func(const T &x) {
    // return (T(1.0) / T(x - 0.1)) * std::abs(x - T(0.5)) * std::exp(std::sin(20.0 * x));
    return (exp(x)) * sqrt(x + 0.1) + abs(x - 0.1234567);
}

int
main() {
    using mpfr::mpreal;


    // Required precision of computations in decimal digits
    // Play with it to check different precisions
    const int digits = 50;

    // Setup default precision for all subsequent computations
    // MPFR accepts precision in bits - so we do the conversion
    mpreal::set_default_prec(mpfr::digits2bits(digits));

    mpreal r = 0;


    // Sample points (Z) and function values (F)


    using Scalar = mpreal;
    //    using Complex = std::complex<Scalar>;

    using Complex = Scalar;

    std::vector<Scalar> Z;
    std::vector<Scalar> F;

    // Example: Approximate the function f(z) = exp(z) on the interval [0, 1]
    size_t N = 203; // Reduced number of points for brevity
    for (size_t i = 0; i < N; ++i) {
        Scalar x = Scalar(i) / (N - 1); // Points between 0 and 1
        Scalar z = x;
        Z.push_back(z);
        F.push_back(Func(z));
    }

    // Create AAA approximant
    AAA<Scalar> approximant;
    approximant.fit(Z, F);

    // Evaluate at new points
    std::vector<Scalar> Z_eval;
    for (size_t i = 0; i < N; ++i) {
        Scalar x = Scalar(i) / (N - 1) + 0.001; // Shifted points
        Z_eval.push_back(x);
    }

    std::vector<Scalar> F_approx = approximant(Z_eval);

    // Compare with exact values
    for (size_t i = 0; i < Z_eval.size(); ++i) {
        Scalar f_exact = Func(Z_eval[i]);
        Scalar f_approx = F_approx[i];
        Scalar error = abs(f_exact - f_approx);
        std::cout << "z = " << Z_eval[i] << ", Exact = " << f_exact << ", Approx = " << f_approx
                  << ", Error = " << error << std::endl;
    }

    return 0;
}

================
File: examples/time_derivatives.cpp
================
#include <boost/numeric/odeint.hpp>
#include <functional>
#include <iostream>
#include <vector>

// #include "HC-MC.hpp"
#include "ODESystem.hpp"
#include "hbtaylor.hpp"
#include "types.hpp"

using namespace boost::numeric::odeint;

#include <cppad/cppad.hpp>
#include <vector>

/*// Function to compute time derivatives of an ODE system at a given point
template <typename F, typename Scalar, typename ScalarVec>
std::vector<ScalarVec> compute_time_derivatives(
    F&& ode_function,        // ODE function representing dy/dt = F(y)
    const ScalarVec& X,      // State variables at which to compute derivatives
    size_t num_derivatives)  // Number of derivatives to compute
{
  size_t n = X.size();

  // Convert Vector<Scalar> to std::vector<Scalar> for TaylorSeries
  std::vector<Scalar> x_vec(n);
  for (size_t i = 0; i < n; ++i) {
    x_vec[i] = X[i];
  }

  // Compute Taylor series coefficients using hbtaylor
  std::vector<TaylorSeries<Scalar>> taylor_coeffs =
      computeODECoefficients(x_vec, ode_function, num_derivatives);

  // Convert TaylorSeries coefficients to time derivatives
  std::vector<ScalarVec> derivatives(num_derivatives, ScalarVec(n));
  for (size_t k = 0; k < num_derivatives; ++k) {
    for (size_t i = 0; i < n; ++i) {
      // The k-th derivative is k! times the k-th coefficient
      Scalar factorial = 1;
      for (Scalar j = 1; j <= k + 1; ++j) {
        factorial *= j;
      }
      derivatives[k][i] = taylor_coeffs[i][k + 1] * factorial;
    }
  }

  return derivatives;
}*/
template <typename T>
class ode_system {
 public:
  void operator()(const std::vector<T>& y, std::vector<T>& dydt) const {
    size_t n = y.size();
    dydt.resize(n);
    dydt[0] = T(1);  // dy_0/dt = 1
    for (size_t k = 1; k < n; ++k) {
      dydt[k] = y[k - 1];  // dy_k/dt = y_{k-1}
    }
  }
};

int main() {
  using Scalar = double;  // Ensure Scalar is double
                          // using VectorType = Vector<Scalar>;

  using VectorType = std::vector<Scalar>;
  VectorType X(5, 1.0);

  // EIGEN INITIALIATION Initial state variables
  // VectorType X(5);
  // X << 0.0, 0.0, 0.0, 0.0, 0.0;

  // Number of derivatives to compute
  size_t num_derivatives = 5;

  ode_system<TaylorSeries<Scalar>> ode_function_ts;

  // Compute Taylor series coefficients
  auto taylor_coeffs =
      computeODECoefficients<ode_system<TaylorSeries<Scalar>>, Scalar>(
          X, ode_function_ts, num_derivatives);

  // Convert coefficients to derivatives
  std::vector<std::vector<Scalar>> derivatives(num_derivatives,
                                               std::vector<Scalar>(X.size()));
  for (size_t k = 0; k < num_derivatives; ++k) {
    for (size_t i = 0; i < X.size(); ++i) {
      // k-th derivative is k! times the k-th coefficient
      Scalar factorial = 1;
      for (Scalar j = 1; j <= k + 1; ++j) {
        factorial *= j;
      }
      derivatives[k][i] = taylor_coeffs[i][k + 1] * factorial;
    }
  }

  // Output the derivatives
  std::cout << "Time derivatives at X:\n";
  for (size_t k = 0; k < derivatives.size(); ++k) {
    std::cout << "Order " << k + 1 << " derivatives:\n";
    for (size_t i = 0; i < derivatives[k].size(); ++i) {
      std::cout << "  Variable " << i << ": " << derivatives[k][i] << "\n";
    }
  }

  return 0;
}

================
File: project/HC-MC/include/AAA.hpp
================
#ifndef AAA_HPP
#define AAA_HPP

#include <Eigen/Dense>
#include <algorithm>
#include <cmath>
#include <complex>
#include <iostream>  // For debug output
#include <limits>
#include <numeric>
#include <vector>

template <typename Scalar>
class AAA {
 public:
  using Complex = std::complex<Scalar>;
  using VectorX = Eigen::Matrix<Scalar, Eigen::Dynamic, 1>;

  AAA() = default;

  /**
   * Fit the AAA approximant to the data points (Z, F).
   *
   * @param Z     Vector of sample points in the Scalar plane.
   * @param F     Vector of function values at the points in Z.
   * @param tol   Relative tolerance for convergence (default: 1e-13).
   * @param mmax  Maximum number of iterations (default: 150).
   */
  void fit(const std::vector<Scalar> &Z, const std::vector<Scalar> &F,
           Scalar tol = Scalar(1e-13), size_t mmax = 150);

  /**
   * Evaluate the AAA approximant at a given point z.
   *
   * @param z  Point at which to evaluate the approximant.
   * @return   Approximated function value at z.
   */
  Scalar operator()(const Scalar &z) const;

  /**
   * Evaluate the AAA approximant at multiple points.
   *
   * @param Z_eval  Vector of points at which to evaluate the approximant.
   * @return        Vector of approximated function values.
   */
  std::vector<Scalar> operator()(const std::vector<Scalar> &Z_eval) const;

  /**
   * Get the support points used in the approximation.
   */
  const std::vector<Scalar> &support_points() const { return z_; }

  /**
   * Get the weights used in the approximation.
   */
  const std::vector<Scalar> &weights() const { return w_; }

  /**
   * Get the function values at the support points.
   */
  const std::vector<Scalar> &function_values() const { return f_; }

 private:
  std::vector<Scalar> z_;  // Support points
  std::vector<Scalar> f_;  // Function values at support points
  std::vector<Scalar> w_;  // Barycentric weights

  // Helper function to compute the barycentric weights
  void compute_weights(
      const Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic> &A,
      const std::vector<size_t> &J);

  // Helper function to evaluate the approximant at a point
  Scalar evaluate(const Scalar &z) const;

  // Helper function to remove Froissart doublets (spurious poles)
  void remove_froissart_doublets(const std::vector<Scalar> &Z,
                                 const std::vector<Scalar> &F);

  // Error vector to track convergence
  std::vector<Scalar> error_history_;
};

template <typename Scalar>
void AAA<Scalar>::fit(const std::vector<Scalar> &Z,
                      const std::vector<Scalar> &F, Scalar tol, size_t mmax) {
  size_t M = Z.size();
  if (M != F.size()) {
    throw std::invalid_argument("Z and F must be of the same length.");
  }

  // Initialize variables
  std::vector<size_t> J(M);
  std::iota(J.begin(), J.end(), 0);  // Indices of unused points

  z_.clear();
  f_.clear();
  w_.clear();
  error_history_.clear();

  // Initial approximation is the mean of F
  Scalar meanF = std::accumulate(F.begin(), F.end(), Scalar(0)) / Scalar(M);
  VectorX R = VectorX::Constant(M, meanF);

  // Compute initial error over all points
  Scalar error = 0;
  for (size_t idx : J) {
    Scalar e = abs(F[idx] - R(idx));
    if (e > error) {
      error = e;
    }
  }
  error_history_.push_back(error);

  using EMatrixType = Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic>;
  //  using EVectorType = Eigen::Matrix<Scalar, 1, Eigen::Dynamic>;

  EMatrixType C = EMatrixType::Zero(M, 0);  // Cauchy matrix
  EMatrixType A = EMatrixType::Zero(M, 0);  // Loewner matrix

  size_t m = 0;
  while (error > tol && m < mmax && !J.empty()) {
    // Find the index with maximum error
    size_t j = J[0];
    Scalar max_error = abs(F[j] - R(j));
    for (size_t idx : J) {
      Scalar e = abs(F[idx] - R(idx));
      if (e > max_error) {
        max_error = e;
        j = idx;
      }
    }

    // Add new support point
    z_.push_back(Z[j]);
    f_.push_back(F[j]);
    m++;

    // Remove index j from J
    J.erase(std::remove(J.begin(), J.end(), j), J.end());

    // Update Cauchy matrix
    C.conservativeResize(Eigen::NoChange, m);
    for (size_t i = 0; i < M; ++i) {
      C(i, m - 1) = Scalar(1) / (Z[i] - Z[j]);
    }

    // Update Loewner matrix
    A.conservativeResize(Eigen::NoChange, m);
    for (size_t i = 0; i < M; ++i) {
      A(i, m - 1) = (F[i] - F[j]) * C(i, m - 1);
    }

    // Compute weights
    compute_weights(A, J);

    // Evaluate rational approximant at unused points
    // Set R at support points to exact values
    R = Eigen::Map<const VectorX>(F.data(), M);

    for (size_t idx : J) {
      R(idx) = evaluate(Z[idx]);
    }

    // Compute error over indices J (non-support points)
    error = 0;
    for (size_t idx : J) {
      Scalar e = abs(F[idx] - R(idx));
      if (e > error) {
        error = e;
      }
    }
    error_history_.push_back(error);

    // Debug output
    std::cout << "Iteration " << m << ", error = " << error << "\n";

    if (isnan(error) || isinf(error)) {
      std::cerr << "Error became NaN or Inf. Stopping iteration." << "\n";
      break;
    }
  }

  // Remove spurious poles
  // remove_froissart_doublets(Z, F); // Not implemented yet
}

template <typename Scalar>
void AAA<Scalar>::compute_weights(
    const Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic> &A,
    const std::vector<size_t> &J) {
  size_t m = A.cols();
  size_t n = J.size();

  if (m == 0) {
    // No weights to compute
    w_.clear();
    return;
  }

  if (m == 1) {
    // Only one support point
    w_.assign(1, Scalar(1.0));
    return;
  }
  using EMatrixType = Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic>;
  using EVectorType = Eigen::Matrix<Scalar, 1, Eigen::Dynamic>;

  if (n >= m) {
    // The usual tall-skinny case
    EMatrixType A_sub(n, m);
    for (size_t i = 0; i < n; ++i) {
      A_sub.row(i) = A.row(J[i]);
    }
    Eigen::JacobiSVD<EMatrixType> svd(A_sub, Eigen::ComputeThinV);
    EVectorType w = svd.matrixV().col(svd.matrixV().cols() - 1);
    w_ = std::vector<Scalar>(w.data(), w.data() + w.size());
  } else if (n >= 1) {
    // Fewer rows than columns
    EMatrixType A_sub(n, m);
    for (size_t i = 0; i < n; ++i) {
      A_sub.row(i) = A.row(J[i]);
    }
    Eigen::FullPivLU<EMatrixType> lu_decomp(A_sub);
    EMatrixType null_space = lu_decomp.kernel();
    if (null_space.cols() > 0) {
      EMatrixType w = null_space.col(0);
      w_ = std::vector<Scalar>(w.data(), w.data() + w.size());
    } else {
      // Should not happen
      std::cerr
          << "Warning: Null space computation failed. Using default weights."
          << "n";
      w_.assign(m, Scalar(1.0));
    }
  } else {
    // No rows at all
    w_.assign(m, Scalar(1.0) / sqrt(Scalar(m)));
  }
}

template <typename Scalar>
Scalar AAA<Scalar>::operator()(const Scalar &z) const {
  return evaluate(z);
}

template <typename Scalar>
std::vector<Scalar> AAA<Scalar>::operator()(
    const std::vector<Scalar> &Z_eval) const {
  std::vector<Scalar> result;
  result.reserve(Z_eval.size());
  for (const auto &z : Z_eval) {
    result.push_back(evaluate(z));
  }
  return result;
}
template <typename Scalar>
Scalar AAA<Scalar>::evaluate(const Scalar &z) const {
  if (z_.empty()) {
    std::cerr << "Error: No support points available for evaluation." << "n";
    return Scalar(std::numeric_limits<Scalar>::quiet_NaN());
  }

  if (z_.size() == 1) {
    return f_[0];
  }

  Scalar tol = Scalar(1e-13);
  Scalar tol_quarter = pow(tol, Scalar(0.25));

  Scalar numerator = 0;
  Scalar denominator = 0;

  bool breakflag = false;
  size_t breakindex = std::numeric_limits<size_t>::max();

  for (size_t j = 0; j < z_.size(); ++j) {
    Scalar diff = z - z_[j];
    Scalar abs_diff = abs(diff);
    if (abs_diff < tol_quarter) {
      breakflag = true;
      breakindex = j;
      break;
    }
    Scalar term = w_[j] / diff;
    numerator += term * f_[j];
    denominator += term;
  }

  if (breakflag) {
    numerator = 0;
    denominator = 0;
    for (size_t j = 0; j < z_.size(); ++j) {
      if (j == breakindex) {
        continue;
      }
      Scalar diff = z - z_[j];
      Scalar term = w_[j] / diff;
      numerator += term * f_[j];
      denominator += term;
    }
    Scalar m = z - z_[breakindex];
    Scalar fz = (w_[breakindex] * f_[breakindex] + m * numerator) /
                (w_[breakindex] + m * denominator);
    return fz;
  } else {
    if (denominator == Scalar(0)) {
      std::cerr << "Warning: Denominator is zero at z = " << z << std::endl;
      return Scalar(std::numeric_limits<Scalar>::quiet_NaN());
    }
    return numerator / denominator;
  }
}

#endif  // AAA_HPP

================
File: project/HC-MC/include/hbtaylor.hpp
================
#pragma once

#include <algorithm>
#include <array>
#include <cmath>
#include <cstddef>
#include <iostream>
#include <vector>

template <typename T>
class TaylorSeries {
 private:
  int degree;                   // Degree of the Taylor series
  std::vector<T> coefficients;  // coefficients[i] represents the i-th
                                // derivative divided by i!
  static constexpr T epsilon = std::numeric_limits<T>::epsilon();

 public:
  // Constructor initializes all coefficients to zero
  explicit TaylorSeries(const T &constant, int degree_in = 0)
      : degree(degree_in), coefficients(degree_in + 1, T(0)) {
    coefficients[0] = constant;
  }

  TaylorSeries()
      : TaylorSeries(T(0), 0) {
  }  // Default constructor delegates to existing constructor

  // Access operators
  T &operator[](int idx) { return coefficients[idx]; }
  const T &operator[](int idx) const { return coefficients[idx]; }

  // Basic arithmetic operators
  TaylorSeries operator+(const TaylorSeries &other) const {
    int max_degree = std::max(degree, other.degree);
    TaylorSeries result(T(0), max_degree);
    for (int i = 0; i <= max_degree; ++i) {
      result[i] = (i <= degree ? coefficients[i] : T(0)) +
                  (i <= other.degree ? other[i] : T(0));
    }
    return result;
  }

  TaylorSeries operator-(const TaylorSeries &other) const {
    int max_degree = std::max(degree, other.degree);
    TaylorSeries result(T(0), max_degree);
    for (int i = 0; i <= max_degree; ++i) {
      result[i] = (i <= degree ? coefficients[i] : T(0)) -
                  (i <= other.degree ? other[i] : T(0));
    }
    return result;
  }

  TaylorSeries operator*(const TaylorSeries &other) const {
    int result_degree = degree + other.degree;
    TaylorSeries result(T(0), result_degree);
    for (int n = 0; n <= result_degree; ++n) {
      for (int k = 0; k <= n; ++k) {
        if (k <= degree && (n - k) <= other.degree) {
          result[n] += coefficients[k] * other[n - k];
        }
      }
    }
    return result;
  }

  TaylorSeries operator/(const TaylorSeries &other) const {
    if (std::abs(other[0]) < epsilon) {
      throw std::runtime_error("Division by near-zero in Taylor series");
    }

    int result_degree = degree;
    TaylorSeries result(T(0), result_degree);
    result[0] = coefficients[0] / other[0];

    for (int n = 1; n <= result_degree; ++n) {
      T sum = coefficients[n];
      for (int k = 1; k <= n; ++k) {
        if (k <= other.degree) {
          sum -= other[k] * result[n - k];
        }
      }
      result[n] = sum / other[0];
    }
    return result;
  }

  // Scalar multiplication
  TaylorSeries operator*(const T &scalar) const {
    TaylorSeries result(T(0), degree);
    for (int i = 0; i <= degree; ++i) {
      result[i] = coefficients[i] * scalar;
    }
    return result;
  }

  // Scalar division
  TaylorSeries operator/(const T &scalar) const {
    if (std::abs(scalar) < epsilon) {
      throw std::runtime_error("Division by near-zero scalar in Taylor series");
    }
    TaylorSeries result(T(0), degree);
    for (int i = 0; i <= degree; ++i) {
      result[i] = coefficients[i] / scalar;
    }
    return result;
  }

  TaylorSeries &operator*=(const T &scalar) {
    for (int i = 0; i <= degree; ++i) {
      coefficients[i] *= scalar;
    }
    return *this;
  }

  TaylorSeries &operator/=(const T &scalar) {
    if (std::abs(scalar) < epsilon) {
      throw std::runtime_error("Division by near-zero scalar in Taylor series");
    }
    for (int i = 0; i <= degree; ++i) {
      coefficients[i] /= scalar;
    }
    return *this;
  }

  // Compound assignment operators
  TaylorSeries &operator+=(const TaylorSeries &other) {
    *this = *this + other;
    return *this;
  }

  TaylorSeries &operator-=(const TaylorSeries &other) {
    *this = *this - other;
    return *this;
  }

  // Evaluate series at a point
  // Evaluate series at a point x
  T evaluate(T x_value) const {
    T x0 = coefficients[0];  // Center of the series
    T h = x_value - x0;      // Deviation from the center
    T result = coefficients[degree];
    for (int i = degree - 1; i >= 0; --i) {
      result = result * h + coefficients[i];
    }
    return result;
  }

  // Get derivative
  TaylorSeries derivative() const {
    if (degree == 0) {
      throw std::runtime_error(
          "Cannot take derivative of degree 0 Taylor series");
    }
    TaylorSeries result(T(0), degree - 1);
    for (int i = 0; i < degree; ++i) {
      result[i] = coefficients[i + 1] * T(i + 1);
    }
    return result;
  }

  // Friend functions for commutative operations
  friend TaylorSeries operator*(T scalar, const TaylorSeries &ts) {
    return ts * scalar;
  }

  // Stream output
  friend std::ostream &operator<<(std::ostream &os, const TaylorSeries &ts) {
    os << ts[0];
    for (int i = 1; i <= ts.degree; ++i) {
      if (ts[i] != T(0)) {
        os << " + " << ts[i] << "x^" << i;
      }
    }
    return os;
  }

  // Unary minus operator
  TaylorSeries operator-() const {
    TaylorSeries result(T(0), degree);
    for (int i = 0; i <= degree; ++i) {
      result[i] = -coefficients[i];
    }
    return result;
  }

  // Updated transcendental functions using recursive formulas
  static TaylorSeries exp(const TaylorSeries &x) {
    TaylorSeries result(std::exp(x[0]), x.degree);
    for (int n = 1; n <= x.degree; ++n) {
      T sum = T(0);
      for (int k = 1; k <= n; ++k) {
        sum += T(k) * x[k] * result[n - k];
      }
      result[n] = sum / T(n);
    }
    return result;
  }

  static TaylorSeries log(const TaylorSeries &x) {
    if (x[0] <= T(0)) {
      throw std::runtime_error("Log of non-positive number");
    }

    TaylorSeries result(std::log(x[0]), x.degree);

    for (int n = 1; n <= x.degree; ++n) {
      T sum = x[n];
      for (int k = 1; k <= n - 1; ++k) {
        sum -= (T(k) * x[n - k] * result[k]) / T(n);
      }
      result[n] = sum / x[0];
    }
    return result;
  }

  static void sincos(const TaylorSeries &x, TaylorSeries &s, TaylorSeries &c) {
    s = TaylorSeries(std::sin(x[0]), x.degree);
    c = TaylorSeries(std::cos(x[0]), x.degree);
    for (int n = 1; n <= x.degree; ++n) {
      T sum_s = T(0);
      T sum_c = T(0);
      for (int k = 1; k <= n; ++k) {
        sum_s += T(k) * x[k] * c[n - k];
        sum_c -= T(k) * x[k] * s[n - k];
      }
      s[n] = sum_s / T(n);
      c[n] = sum_c / T(n);
    }
  }

  static TaylorSeries sin(const TaylorSeries &x) {
    TaylorSeries s(T(0), x.degree);
    TaylorSeries c(T(0), x.degree);
    sincos(x, s, c);
    return s;
  }

  static TaylorSeries cos(const TaylorSeries &x) {
    TaylorSeries s(T(0), x.degree);
    TaylorSeries c(T(0), x.degree);
    sincos(x, s, c);
    return c;
  }

  static TaylorSeries sqrt(const TaylorSeries &x) {
    if (x[0] <= T(0)) {
      throw std::runtime_error("Sqrt of non-positive number");
    }

    TaylorSeries result(std::sqrt(x[0]), x.degree);

    for (int n = 1; n <= x.degree; ++n) {
      T sum = T(0);
      for (int k = 1; k <= n - 1; ++k) {
        sum += result[k] * result[n - k];
      }
      result[n] = (x[n] - sum / T(2)) / (T(2) * result[0]);
    }
    return result;
  }
  template <typename S>
  static TaylorSeries pow(const TaylorSeries &x, S exponent) {
    // Using the identity pow(x, a) = exp(a * log(x)) for non-integer exponents
    if (std::is_floating_point<S>::value || exponent < 0) {
      return exp(log(x) * exponent);
    }

    // For non-negative integer exponents, use repeated squaring
    if (exponent == 0) {
      return TaylorSeries(T(1), x.degree);
    }
    if (exponent == 1) {
      return x;
    }

    // Handle even vs odd exponents
    TaylorSeries half = pow(x, exponent / 2);
    TaylorSeries result = half * half;
    // For odd exponents, multiply by x one additional time
    if (exponent % 2 == 1) {
      result = result * x;
    }  // Use bitwise AND to check if odd
    return result;
  }

  static TaylorSeries tan(const TaylorSeries &x) { return sin(x) / cos(x); }
};

// Global overloads for transcendental functions
template <typename T>
TaylorSeries<T> sin(const TaylorSeries<T> &x) {
  return TaylorSeries<T>::sin(x);
}

template <typename T>
TaylorSeries<T> cos(const TaylorSeries<T> &x) {
  return TaylorSeries<T>::cos(x);
}

template <typename T>
TaylorSeries<T> exp(const TaylorSeries<T> &x) {
  return TaylorSeries<T>::exp(x);
}

template <typename T>
TaylorSeries<T> log(const TaylorSeries<T> &x) {
  return TaylorSeries<T>::log(x);
}

template <typename T>
TaylorSeries<T> tan(const TaylorSeries<T> &x) {
  return TaylorSeries<T>::tan(x);
}

template <typename T>
TaylorSeries<T> sqrt(const TaylorSeries<T> &x) {
  return TaylorSeries<T>::sqrt(x);
}

template <typename T, typename S>
TaylorSeries<T> pow(const TaylorSeries<T> &x, S exponent) {
  return TaylorSeries<T>::pow(x, exponent);
}

template <typename T>
std::ostream &operator<<(std::ostream &os,
                         const std::vector<TaylorSeries<T>> &v) {
  os << "[";
  for (int i = 0; i < v.size(); ++i) {
    os << v[i];
    if (i < v.size() - 1) {
      os << ",\n ";
    }
  }
  os << "]";
  return os;
}

template <typename ODESystemType, typename T>

std::vector<TaylorSeries<T>> computeODECoefficients(const std::vector<T> &X,
                                                    const ODESystemType &O,
                                                    int degree) {
  int n = X.size();
  std::vector<TaylorSeries<T>> coefficients;
  coefficients.reserve(X.size());

  // Initialize each TaylorSeries with the given degree
  for (int i = 0; i < X.size(); i++) {
    TaylorSeries<T> ts(X[i], degree + 7);
    ts[0] = X[i];  // Set constant term to initial value
    coefficients.push_back(ts);
  }
  auto Y = coefficients;
  for (int i = 1; i < degree + 1; i++) {
    O(coefficients, Y);
    // std::cout << Y << coefficients << "\n";
    for (int j = 0; j < n; j++) {
      coefficients[j][i] = Y[j][i - 1] / T(i);
    }
  }
  return coefficients;
}

================
File: project/HC-MC/include/HC-MC.hpp
================
#pragma once

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Weverything"
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wall"
#pragma GCC diagnostic ignored "-Wextra"
#pragma GCC diagnostic ignored "-Wold-style-cast"
#pragma GCC diagnostic ignored "-Wsign-conversion"
#pragma GCC diagnostic ignored "-Wundef"
#pragma GCC diagnostic ignored "-Wuseless-cast"
#pragma GCC diagnostic ignored "-Wunused-parameter"

// Add more GCC-specific warnings you want to ignore here
#endif

#include <Eigen/Dense>
#include <cppad/cppad.hpp>
#include <cppad/example/cppad_eigen.hpp>  // Add this line

#ifdef __clang__
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#endif

#include <iomanip>
#include <iostream>
#include <optional>
#include <random>
#include <string>

#include "types.hpp"

// Configuration and result structures
struct SolveOptions {
  bool debug = false;
  double tolerance = 1e-10;
  int maxIterations = 100;
  int maxSteps = 1000;
  double initialStepSize = 0.001;
  bool verifyDerivatives = false;
};

struct SolveResult {
  ADVector solution;
  double residualNorm;
  int iterations;
  bool success;
  std::string message;
};

inline Eigen::VectorXd toDoubleVector(const ADVector& ad_vec) {
  Eigen::VectorXd vec(ad_vec.size());
  for (auto i = 0; i < ad_vec.size(); ++i) {
    vec(i) = CppAD::Value(ad_vec(i));
  }
  return vec;
}

namespace detail {
// Helper function to convert any type to double
template <typename T>
double toDouble(const T& x) {
  if constexpr (std::is_same_v<T, ADDouble>) {
    return CppAD::Value(x);
  } else {
    return x;
  }
}

// Random vector generator in [0,2]
template <typename T>
Vector<T> randomVector(int size) {
  static std::random_device rd;
  static std::mt19937 gen(rd());
  static std::uniform_real_distribution<double> dis(-1.0, 1.0);

  Vector<T> result(size);
  for (auto i = 0; i < size; ++i) {
    result(i) = T(dis(gen)) + T(1.0);
  }
  return result;
}

// Helper to evaluate vector function and get sizes
template <typename Func>
std::pair<int, int> getFunctionDimensions(const Func& F,
                                          const ADVector& x_test) {
  // Use the provided test vector to evaluate F
  auto y = F(x_test);
  return {x_test.size(), y.size()};
}

// Compute finite difference Jacobian for verification
template <typename F>
Matrix<double> finiteDiffJacobian(const F& func, const ADVector& x,
                                  double eps = 1e-8) {
  auto n = x.size();
  ADVector x_plus = x;
  auto f0 = func(x);
  auto m = f0.size();
  Matrix<double> jac(m, n);

  for (int j = 0; j < n; ++j) {
    x_plus = x;
    x_plus(j) += eps;
    auto f1 = func(x_plus);

    for (int i = 0; i < m; ++i) {
      jac(i, j) = (toDouble(f1(i)) - toDouble(f0(i))) / eps;
    }
  }
  return jac;
}

// Compare Jacobians with detailed output
inline bool compareJacobians(const Matrix<double>& J1, const Matrix<double>& J2,
                             const std::string& context, double tol = 1e-6) {
  double max_diff = 0.0;
  int max_i = 0;
  int max_j = 0;

  for (int i = 0; i < J1.rows(); ++i) {
    for (int j = 0; j < J1.cols(); ++j) {
      const double diff = std::abs(J1(i, j) - J2(i, j));
      if (diff > max_diff) {
        max_diff = diff;
        max_i = i;
        max_j = j;
      }
      if (diff > tol) {
        std::cout << context << ": Large difference at (" << i << "," << j
                  << "):\n"
                  << "AD: " << J1(i, j) << "\n"
                  << "FD: " << J2(i, j) << "\n"
                  << "Diff: " << diff << "\n";
        return false;
      }
    }
  }

  if (max_diff > 0) {
    std::cout << context << ": Maximum difference: " << max_diff << " at ("
              << max_i << "," << max_j << ")\n";
  }
  return true;
}
}  // namespace detail

template <typename FuncF, typename FuncG>
class HFunction {
 public:
  HFunction(const FuncF& F_in, const FuncG& G_in) : F(F_in), G(G_in) {}

  template <typename T>
  Vector<T> operator()(const Vector<T>& X, const T& t) const {
    auto f_val = F(X);
    auto g_val = G(X);
    return (T(1.0) - t) * g_val + t * f_val;
  }

  template <typename T>
  [[nodiscard]] Vector<T> dH_dt(const Vector<T>& X) const {
    return F(X) - G(X);
  }

 private:
  const FuncF& F;
  const FuncG& G;
};

template <typename FuncF, typename FuncG>
class PathTracker {
 public:
  PathTracker(const FuncF& f, const FuncG& g, const SolveOptions& options_pack)
      : F(f), G(g), H_func(F, G), options(options_pack) {}

  std::optional<SolveResult> track(const ADVector& X_in,
                                   const ADDouble& t_start,
                                   const ADDouble& t_end,
                                   const ADDouble& dt_init) {
    ADVector X = X_in;
    ADDouble t = t_start;
    ADDouble dt = dt_init;
    const double min_dt = detail::toDouble(dt_init) * 1e-8;  // TODO (orebas)
                                                             // magic number
    int total_iterations = 0;

    while (detail::toDouble(t) < detail::toDouble(t_end) &&
           total_iterations < options.maxSteps) {
      // Adjust step size if we're close to the end
      ADDouble dt_current = dt;
      if (detail::toDouble(t + dt) > detail::toDouble(t_end)) {
        dt_current = t_end - t;
      }

      const ADDouble t_new = t + dt_current;
      // Predictor step: Compute dX/dt
      const ADVector H_t = H_func.dH_dt(X);
      const Eigen::MatrixXd JH = computeJacobian(X, t);

      // Convert H_t to Eigen::VectorXd
      const Eigen::VectorXd H_t_double = toDoubleVector(H_t);

      // Solve for dX_dt
      const Eigen::VectorXd dX_dt = -JH.fullPivLu().solve(H_t_double);

      // Predictor: X_pred = X + dt_current * dX_dt
      const ADVector X_pred = X + (dt_current * dX_dt).cast<ADDouble>();

      // Corrector step: Refine X_pred at t_new
      auto X_corrected_opt = correctPrediction(X_pred, t_new);
      if (!X_corrected_opt.has_value()) {
        // Reduce step size and retry
        dt *= 0.5;
        if (detail::toDouble(dt) < min_dt) {
          if (options.debug) {
            std::cerr << "Step size too small. Terminating.\n";
          }
          break;
        }
        continue;
      }

      // Update X and t
      X = X_corrected_opt.value();
      t = t_new;
      total_iterations++;

      // Increase step size for next iteration
      dt = std::min(dt * 1.2, ADDouble(options.initialStepSize));

      if (options.debug) {
        std::cout << "Step " << total_iterations << ": t = " << t
                  << ", Residual norm = "
                  << detail::toDouble(H_func(X, t).norm()) << "\n";
      }
    }

    // Check if we reached the end
    if (detail::toDouble(t) < detail::toDouble(t_end)) {
      return std::nullopt;
    }

    SolveResult result;
    result.solution = X;
    result.residualNorm = detail::toDouble(F(X).norm());
    result.iterations = total_iterations;
    result.success = true;
    result.message = "Solution found";

    return result;
  }

 private:
  const FuncF& F;
  const FuncG& G;
  HFunction<FuncF, FuncG> H_func;
  SolveOptions options;

  Eigen::MatrixXd computeJacobian(const ADVector& X, const ADDouble& t) {
    using namespace CppAD;
    const long n = X.size();

    ADVector X_ad = X;  // Eigen::Matrix<ADDouble>

    // Declare independent variables
    Independent(X_ad);

    const ADVector H_X = H_func(X_ad, t);

    // Create the function object
    ADFun<double> func(X_ad, H_X);

    // Evaluate Jacobian at the current point
    std::vector<double> x_vec(n);
    for (long i = 0; i < n; ++i) {
      x_vec[i] = Value(X[i]);  // Use CppAD::Value to extract double
    }

    std::vector<double> jac_vec = func.Jacobian(x_vec);

    // Fill the EigenMatrix with the Jacobian values
    Eigen::MatrixXd jac(H_X.size(), n);
    for (long i = 0; i < H_X.size(); ++i) {
      for (long j = 0; j < n; ++j) {
        jac(i, j) = jac_vec[i * n + j];
      }
    }

    // Optional: Verify derivatives
    if (options.verifyDerivatives) {
      // Create a lambda that captures the current t value
      auto H_at_t = [this, t](const ADVector& X_) {
        return this->H_func(X_, t);
      };

      auto fd_jac = detail::finiteDiffJacobian(H_at_t, X);

      // Convert AD Jacobian to double for comparison
      const Eigen::MatrixXd jac_double = jac;

      std::stringstream context;
      context << "Jacobian verification at t=" << Value(t);
      detail::compareJacobians(jac_double, fd_jac, context.str());
    }

    return jac;
  }
  std::optional<ADVector> correctPrediction(const ADVector& X_pred,
                                            const ADDouble& t_new) {
    ADVector X = X_pred;
    for (int iter = 0; iter < options.maxIterations; ++iter) {
      const ADVector H_X = H_func(X, t_new);
      const double residual = detail::toDouble(H_X.norm());

      if (residual < options.tolerance) {
        return X;
      }

      // Compute Jacobian
      const Eigen::MatrixXd JH = computeJacobian(X, t_new);

      // Convert H_X to Eigen::VectorXd
      const Eigen::VectorXd H_X_double = toDoubleVector(H_X);

      // Solve for update
      const Eigen::VectorXd delta_X = -JH.fullPivLu().solve(H_X_double);

      // Update X
      X = X + delta_X.cast<ADDouble>();

      if (options.debug) {
        std::cout << "Corrector Iter " << iter << ": Residual = " << residual
                  << "\n";
      }

      if (delta_X.norm() < options.tolerance) {
        return X;
      }
    }

    // Did not converge
    return std::nullopt;
  }
};
// Main solve function
template <typename Func>
std::optional<SolveResult> solve(const Func& F,
                                 int input_dim,  // New parameter
                                 const SolveOptions& options = SolveOptions{}) {
  // Generate random starting point with correct dimension
  const ADVector X0 = detail::randomVector<ADDouble>(input_dim);

  // Get output dimension
  auto [n_in, n_out] = detail::getFunctionDimensions(F, X0);

  // Verify dimensions match
  if (n_in != input_dim) {
    throw std::invalid_argument("Function input dimension mismatch");
  }

  // Create G(x) = F(x) - F(X0)
  auto F_X0 = F(X0);
  auto G = [&F, &F_X0](const ADVector& x) -> ADVector { return F(x) - F_X0; };

  // Create the path tracker
  PathTracker<Func, decltype(G)> tracker(F, G, options);

  // Track from t=0 (G) to t=1 (F)
  return tracker.track(X0, ADDouble(0.0), ADDouble(1.0),
                       ADDouble(options.initialStepSize));
}

// Overload without explicit dimension - try to deduce from a test evaluation
/*template <typename Func>
std::optional<SolveResult> solve(const Func& F,
                                 const SolveOptions& options = SolveOptions{}) {
  // Try with dimension 1 first
  try {
    const ADVector x_test = detail::randomVector<ADDouble>(1);
    auto y = F(x_test);
    return solve(F, 1, options);
  } catch (...) {
    // Try with dimension 2 if that fails
    try {
      const ADVector x_test = detail::randomVector<ADDouble>(2);
      auto y = F(x_test);
      return solve(F, 2, options);
    } catch (...) {
      // If both fail, require explicit dimension
      throw std::invalid_argument(
          "Could not automatically determine function dimension. "
          "Please provide input dimension explicitly using solve(F, dimension, "
          "options).");
    }
  }
}*/

template <typename Func>
std::optional<SolveResult> solve_newton(
    const Func& F, int input_dim,
    const SolveOptions& options = SolveOptions{}) {
  // Generate random starting point with correct dimension
  const ADVector X0 = detail::randomVector<ADDouble>(input_dim);

  // Get output dimension
  auto [n_in, n_out] = detail::getFunctionDimensions(F, X0);

  // Verify dimensions match
  if (n_in != input_dim) {
    throw std::invalid_argument("Function input dimension mismatch");
  }

  ADVector X = X0;
  int iterations = 0;

  while (iterations < options.maxIterations) {
    // Evaluate function at current point
    const ADVector F_X = F(X);
    const double residual_norm = detail::toDouble(F_X.norm());

    if (residual_norm < options.tolerance) {
      SolveResult result;
      result.solution = X;
      result.residualNorm = residual_norm;
      result.iterations = iterations;
      result.success = true;
      result.message = "Converged successfully";
      return result;
    }

    // Compute Jacobian using CppAD
    using namespace CppAD;
    const long n = X.size();

    ADVector X_ad = X;
    Independent(X_ad);
    const ADVector F_X_ad = F(X_ad);
    ADFun<double> func(X_ad, F_X_ad);

    // Convert current point to std::vector<double>
    std::vector<double> x_vec(n);
    for (long i = 0; i < n; ++i) {
      x_vec[i] = Value(X[i]);
    }

    // Evaluate Jacobian
    std::vector<double> jac_vec = func.Jacobian(x_vec);

    // Convert Jacobian to Eigen matrix
    Eigen::MatrixXd J(F_X.size(), n);
    for (long i = 0; i < F_X.size(); ++i) {
      for (long j = 0; j < n; ++j) {
        J(i, j) = jac_vec[i * n + j];
      }
    }

    // Optional derivative verification
    if (options.verifyDerivatives) {
      auto fd_jac = detail::finiteDiffJacobian(F, X);
      std::stringstream context;
      context << "Newton iteration " << iterations;
      detail::compareJacobians(J, fd_jac, context.str());
    }

    // Solve linear system for Newton step
    const Eigen::VectorXd F_X_double = toDoubleVector(F_X);
    const Eigen::VectorXd delta = -J.fullPivLu().solve(F_X_double);

    // Update X
    X = X + delta.cast<ADDouble>();

    if (options.debug) {
      std::cout << "Newton iteration " << iterations
                << ": Residual = " << residual_norm << "\n";
    }

    // Check if step size is small enough to declare convergence
    if (delta.norm() < options.tolerance) {
      SolveResult result;
      result.solution = X;
      result.residualNorm = residual_norm;
      result.iterations = iterations;
      result.success = true;
      result.message = "Converged via small step size";
      return result;
    }

    ++iterations;
  }

  // Failed to converge
  SolveResult result;
  result.solution = X;
  result.residualNorm = detail::toDouble(F(X).norm());
  result.iterations = iterations;
  result.success = false;
  result.message = "Failed to converge within maximum iterations";
  return result;
}

// Overload without explicit dimension - try to deduce from a test evaluation
template <typename Func>
std::optional<SolveResult> solve_newton(
    const Func& F, const SolveOptions& options = SolveOptions{}) {
  // Try with dimension 1 first
  try {
    const ADVector x_test = detail::randomVector<ADDouble>(1);
    auto y = F(x_test);
    return solve_newton(F, 1, options);
  } catch (...) {
    // Try with dimension 2 if that fails
    try {
      const ADVector x_test = detail::randomVector<ADDouble>(2);
      auto y = F(x_test);
      return solve_newton(F, 2, options);
    } catch (...) {
      // If both fail, require explicit dimension
      throw std::invalid_argument(
          "Could not automatically determine function dimension. "
          "Please provide input dimension explicitly using solve_newton(F, "
          "dimension, options).");
    }
  }
}

================
File: project/HC-MC/include/integration_interface.hpp
================
#pragma once

#include <boost/numeric/odeint.hpp>

// Function to integrate and observe
template <typename T, typename System>
std::vector<observable_vector<T>> integrate_and_observe(
    const System& system, const std::vector<T>& time_values) {
  using namespace boost::numeric::odeint;

  state_vector<T> state = system.getInitialState();
  std::vector<observable_vector<T>> observables;

  auto observer = [&](const state_vector<T>& x, const T& /* t */) {
    observable_vector<T> y;
    system.observe(x, y);
    observables.push_back(y);
  };

  typedef runge_kutta4<state_vector<T>, T, state_vector<T>, T> stepper_type;
  integrate_times(stepper_type(), system, state, time_values.begin(),
                  time_values.end(), T(0.01), observer);
  return observables;
}

================
File: project/HC-MC/include/ODESystem.hpp
================
#pragma once

#include <algorithm>
#include <boost/numeric/odeint.hpp>
#include <functional>
#include <stdexcept>
#include <vector>

#include "hbtaylor.hpp"
#include "types.hpp"

// ODE system class
// Requirements:
//  - F and G should be templated functors, i.e. they should work with T or
//  TaylorSeries<T>.
//  - The user provides something like:
//    struct F {
//      template <typename RealType>
//      void operator()(const std::vector<RealType>& x,
//                      std::vector<RealType>& dxdt,
//                      const std::vector<RealType>& p,
//                      const RealType& t);
//    };
//    struct G {
//      template <typename RealType>
//      void operator()(const std::vector<RealType>& x,
//                      std::vector<RealType>& obs);
//    };
//
// This ensures we can handle both normal floats/doubles and TaylorSeries
// expansions.

template <typename T, template <typename> class StateFunctionTemplate,
          template <typename> class ObservationFunctionTemplate>
class ODESystem {
 public:
  using RealType = T;
  using StateType = std::vector<T>;
  using ParamType = std::vector<T>;
  using ObsType = std::vector<T>;

  // The state and observation functions are template templates
  // We instantiate them with T:
  StateFunctionTemplate<T> state_equations;
  ObservationFunctionTemplate<T> observation_function;

  ODESystem(const ParamType& params, const StateFunctionTemplate<T>& state_func,
            const ObservationFunctionTemplate<T>& obs_func)
      : state_equations(state_func),
        observation_function(obs_func),
        parameters(params),
        parameter_size(params.size()),
        state_size(0),
        observable_size(0) {}

  // Accessors
  const ParamType& getParameters() const { return parameters; }
  size_t getParameterSize() const { return parameter_size; }
  size_t getStateSize() const { return state_size; }
  size_t getObservableSize() const { return observable_size; }

  // Setters
  void setInitialState(const StateType& initial_state_param) {
    this->initial_state = initial_state_param;
    state_size = initial_state_param.size();
  }

  const StateType& getInitialState() const { return initial_state; }

  // Combine parameters and initial conditions into one vector
  std::vector<T> getFullParameterVector() const {
    std::vector<T> full(parameter_size + state_size);
    std::copy(parameters.begin(), parameters.end(), full.begin());
    std::copy(initial_state.begin(), initial_state.end(),
              full.begin() + parameter_size);
    return full;
  }

  // Set parameters and initial conditions from a single vector
  void setFullParameterVector(const std::vector<T>& full) {
    if (full.size() != parameter_size + state_size) {
      throw std::runtime_error(
          "Full vector size does not match parameter+state size.");
    }
    std::copy(full.begin(), full.begin() + parameter_size, parameters.begin());
    std::copy(full.begin() + parameter_size, full.end(), initial_state.begin());
  }

  // ODE function operator
  // For time stepping with fixed parameters
  void operator()(const StateType& x, StateType& dxdt, const T& t) const {
    state_equations(x, dxdt, parameters, t);
  }

  // ODE function operator if we provide parameters explicitly
  void operator()(const StateType& x, StateType& dxdt, const ParamType& p,
                  const T& t) const {
    state_equations(x, dxdt, p, t);
  }

  // Observation function
  void observe(const StateType& x, ObsType& y) const {
    observation_function(x, y);
    if (observable_size == 0) {
      observable_size = y.size();  // Set on first call
    }
  }

  // Shrinking the ODE system by fixing parameters:
  // This returns a new ODESystem with certain parameters fixed.
  // fixedIndices: which parameters to fix
  // fixedValues: values of those parameters
  // The resulting system will have fewer parameters.
  ODESystem<T, StateFunctionTemplate, ObservationFunctionTemplate>
  shrinkParameters(const std::vector<size_t>& fixedIndices,
                   const std::vector<T>& fixedValues) const {
    if (fixedIndices.size() != fixedValues.size()) {
      throw std::runtime_error(
          "Mismatched fixedIndices and fixedValues sizes.");
    }

    // Create a new parameter vector with those indices removed
    std::vector<bool> isFixed(parameter_size, false);
    for (auto idx : fixedIndices) {
      if (idx >= parameter_size) {
        throw std::runtime_error("Parameter index out of range");
      }
      isFixed[idx] = true;
    }

    ParamType newParams;
    newParams.reserve(parameter_size - fixedIndices.size());
    for (size_t i = 0; i < parameter_size; ++i) {
      if (!isFixed[i]) {
        newParams.push_back(parameters[i]);
      }
    }

    // Capture the fixed parameters in a wrapper for state_equations
    // We'll create a lambda that takes (x, dxdt, reducedParams, t),
    // reconstructs the full parameter set, and calls the original
    // state_equations.
    auto original_equations = state_equations;
    ParamType fixedParams = fixedValues;  // copy for lambda capture
    auto new_state_equations = [original_equations, isFixed, fixedParams](
                                   const std::vector<T>& x,
                                   std::vector<T>& dxdt,
                                   const std::vector<T>& reducedP, const T& t) {
      // Rebuild full parameter vector
      size_t reduced_idx = 0;
      std::vector<T> fullP;
      fullP.reserve(isFixed.size());
      for (size_t i = 0; i < isFixed.size(); ++i) {
        if (isFixed[i]) {
          fullP.push_back(fixedParams[std::distance(
              isFixed.begin(),
              std::find(isFixed.begin(), isFixed.end(), true))]);
        } else {
          fullP.push_back(reducedP[reduced_idx++]);
        }
      }
      original_equations(x, dxdt, fullP, t);
    };

    // Observation function does not change because it does not depend on
    // parameters explicitly (assuming linear in x).
    auto new_obs = observation_function;  // same observation function

    ODESystem<T, StateFunctionTemplate, ObservationFunctionTemplate>
        reducedSystem(newParams, new_state_equations, new_obs);
    reducedSystem.setInitialState(this->initial_state);
    return reducedSystem;
  }

  // Similarly, shrink initial conditions by fixing some of them:
  ODESystem<T, StateFunctionTemplate, ObservationFunctionTemplate>
  shrinkInitialConditions(const std::vector<size_t>& fixedStateIndices,
                          const std::vector<T>& fixedValues) const {
    if (fixedStateIndices.size() != fixedValues.size()) {
      throw std::runtime_error("Mismatched fixedStateIndices and fixedValues.");
    }

    std::vector<bool> isFixedState(state_size, false);
    for (auto idx : fixedStateIndices) {
      if (idx >= state_size) {
        throw std::runtime_error("State index out of range");
      }
      isFixedState[idx] = true;
    }

    // Create a reduced initial state
    StateType newInit;
    newInit.reserve(state_size - fixedStateIndices.size());
    for (size_t i = 0; i < state_size; ++i) {
      if (!isFixedState[i]) {
        newInit.push_back(initial_state[i]);
      }
    }

    // Create a wrapper around the state_equations that inserts the fixed state
    // variables
    auto original_equations = state_equations;
    StateType fixedStates = fixedValues;
    auto new_state_equations = [original_equations, isFixedState, fixedStates](
                                   const std::vector<T>& x,
                                   std::vector<T>& dxdt,
                                   const std::vector<T>& p, const T& t) {
      // Rebuild full state vector
      std::vector<T> fullX;
      fullX.reserve(isFixedState.size());
      size_t reduced_idx = 0;
      size_t fixed_count = 0;
      for (size_t i = 0; i < isFixedState.size(); ++i) {
        if (isFixedState[i]) {
          fullX.push_back(fixedStates[fixed_count++]);
        } else {
          fullX.push_back(x[reduced_idx++]);
        }
      }

      std::vector<T> fullDxdt(fullX.size(), T(0));
      original_equations(fullX, fullDxdt, p, t);

      // Now extract the reduced dxdt
      dxdt.resize(x.size());
      reduced_idx = 0;
      for (size_t i = 0; i < isFixedState.size(); ++i) {
        if (!isFixedState[i]) {
          dxdt[reduced_idx++] = fullDxdt[i];
        }
      }
    };

    auto new_obs = [this, isFixedState](const std::vector<T>& x,
                                        std::vector<T>& y) {
      // Rebuild full state vector for observation
      std::vector<T> fullX;
      fullX.reserve(isFixedState.size());
      size_t reduced_idx = 0;
      for (size_t i = 0; i < isFixedState.size(); ++i) {
        if (isFixedState[i]) {
          // For observation, use the fixed initial state value
          // (assuming it doesn't change - this might need refinement)
          fullX.push_back(
              T(0));  // or store the fixed states from initial condition?
        } else {
          fullX.push_back(x[reduced_idx++]);
        }
      }
      std::vector<T> fullObs;
      this->observation_function(fullX, fullObs);

      // The observation might still be full dimension since G is linear in x.
      // If G expects original dimension, we must return that dimension.
      // If we truly shrank the system dimension, G would need adjusting.
      // Here we assume G matches original dimension. If needed,
      // we could store a reduced G. For now, we just return fullObs.
      y = fullObs;
    };

    ODESystem<T, StateFunctionTemplate, ObservationFunctionTemplate>
        reducedSystem(this->parameters, new_state_equations, new_obs);
    reducedSystem.setInitialState(newInit);
    return reducedSystem;
  }

  // Compute Taylor series expansion of the state around time t0
  // The idea:
  //  X(t) = X(t0) + (t - t0)*X'(t0) + (t - t0)^2/2!*X''(t0) + ...
  // We use the provided TaylorSeries class to store coefficients.
  // This requires that state_equations can operate on TaylorSeries<T> as input.
  std::vector<TaylorSeries<T>> computeTaylorSeriesOfState(const T& t0,
                                                          int degree) const {
    // Initialize TaylorSeries for each state variable
    std::vector<TaylorSeries<T>> series;
    series.reserve(state_size);
    for (size_t i = 0; i < state_size; ++i) {
      TaylorSeries<T> ts(initial_state[i], degree);
      ts[0] = initial_state[i];  // constant term
      series.push_back(ts);
    }

    // We'll do a recursive approach:
    // For i=1 to degree:
    //   Evaluate F at t0 with the current expansions.
    //   The linear terms in t give first derivative, etc.
    //
    // However, a direct approach:
    // If we let the input be TaylorSeries(t0 + h), we can call F with x
    // represented as expansions. Then we solve for coefficients by matching
    // terms of equal powers of h.
    //
    // A simpler (though less general) approach:
    //   For the first derivative: dxdt at t0 is just F(X(t0), p, t0).
    //   For the second derivative: we differentiate again by applying chain
    //   rule, etc.
    // But we haven't implemented a general chain rule here. We assume that
    // `state_equations` can handle TaylorSeries to produce all higher
    // derivatives automatically.
    //
    // Let's represent time as a TaylorSeries around t0: T(t) = t0 + h, with h
    // as the variable. We'll create a TaylorSeries<T> for time: t_series = t0 +
    // h where h is the expansion variable.
    TaylorSeries<T> t_series(t0, degree);
    // h = t - t0, so t_series[0] = t0, and t_series[1] = 1, and others 0
    // Actually, since evaluate methods rely on expansions:
    // Let's set up: t_series[0] = t0, t_series[1] = 1.0;
    t_series[0] = t0;
    if (degree > 0) {
      t_series[1] = T(1);
    }

    // At each step i, we will compute dx/dt = F(X, p, t_series)
    // X is currently known as a TaylorSeries expansion to order i-1.
    // We can call state_equations with these series. It should produce dxdt as
    // a series. Then we match coefficients to fill in series[*][i].

    // Convert parameters to TaylorSeries as well (constant expansions)
    std::vector<TaylorSeries<T>> p_series(parameters.size(),
                                          TaylorSeries<T>(T(0), degree));
    for (size_t i = 0; i < parameters.size(); ++i) {
      p_series[i][0] = parameters[i];  // parameter is constant w.r.t time
    }

    for (int i = 1; i <= degree; ++i) {
      // Prepare x_series for input
      std::vector<TaylorSeries<T>> x_series =
          series;  // copy current expansions
      std::vector<TaylorSeries<T>> dxdt_series(state_size,
                                               TaylorSeries<T>(T(0), degree));

      // Call state_equations but templated on TaylorSeries<T>
      // We'll create a small adapter that calls the template:
      {
        // Wrap parameters in a lambda that uses TaylorSeries:
        auto eq = [this](const std::vector<TaylorSeries<T>>& x,
                         std::vector<TaylorSeries<T>>& dxdt,
                         const std::vector<TaylorSeries<T>>& p,
                         const TaylorSeries<T>& tt) {
          // Extract plain arrays for calling original functor:
          // Here we rely on the fact that `state_equations` is already
          // templated. state_equations(x, dxdt, p, t)
          this->state_equations(x, dxdt, p, tt);
        };

        eq(x_series, dxdt_series, p_series, t_series);
      }

      // Now, dxdt_series[j][n] corresponds to nth derivative terms. By
      // definition:
      //   series[j][i] = dxdt[j][i-1] / i   (to get ith coefficient)
      // Because coefficient for order i in Taylor series = f^(i)(t0)/i!
      // dxdt_series gives the derivative expansions. The linear term in
      // dxdt_series is dx/dt at t0, etc. We must ensure that we properly
      // extract the i-th coefficient from dxdt_series. dxdt_series[j][i-1]
      // should give us the i-th derivative * i!. But we've constructed
      // dxdt_series so that [k] is the k-th coefficient i.e.,
      // dxdt_series[j][i-1] is actually the (i-1)-th derivative / (i-1)! ? For
      // simplicity, assume dxdt_series is computed similarly so that:
      //   series[j][i] = dxdt_series[j][i-1] / i
      // This matches the pattern in the provided `computeODECoefficients`
      // snippet.

      for (size_t j = 0; j < state_size; ++j) {
        series[j][i] = dxdt_series[j][i - 1] / T(i);
      }
    }

    return series;
  }

  // Compute Taylor series of the observables:
  std::vector<TaylorSeries<T>> computeTaylorSeriesOfObservables(
      const std::vector<TaylorSeries<T>>& x_series) const {
    // We assume G is linear, so G(X(t)) = A * X(t) for some matrix A.
    // If G is truly linear, applying it to a TaylorSeries vector is
    // straightforward: Just apply G to each coefficient independently.

    // We'll just call observation_function with the TaylorSeries expansions and
    // let it handle them. If G is linear: G(ax + b) = aG(x) + G(b), linear
    // means: G(x) = Mx for some matrix M. We'll call observation_function once
    // with TaylorSeries input.
    std::vector<TaylorSeries<T>> y_series(
        observable_size, TaylorSeries<T>(T(0), x_series[0].getDegree()));

    observation_function(x_series, y_series);
    return y_series;
  }

 private:
  ParamType parameters;
  StateType initial_state;
  size_t parameter_size;
  size_t state_size;
  mutable size_t observable_size;
};

================
File: project/HC-MC/include/types.hpp
================
#pragma once

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Weverything"
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wall"
#pragma GCC diagnostic ignored "-Wextra"
#pragma GCC diagnostic ignored "-Wold-style-cast"
#pragma GCC diagnostic ignored "-Wsign-conversion"
#pragma GCC diagnostic ignored "-Wundef"
#pragma GCC diagnostic ignored "-Wuseless-cast"
#pragma GCC diagnostic ignored "-Wunused-parameter"

// Add more GCC-specific warnings you want to ignore here
#endif

#include <Eigen/Dense>
#include <cppad/cppad.hpp>
#include <cppad/example/cppad_eigen.hpp>  // Add this line

#ifdef __clang__
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#endif

template <typename T>
using Vector = Eigen::Matrix<T, Eigen::Dynamic, 1>;

// Define AD types as used in HC-MC.hpp
using ADDouble = CppAD::AD<double>;
using ADVector = Vector<ADDouble>;

// Template the state type and system for AD compatibility
template <typename T>
using state_vector = std::vector<T>;
template <typename T>
using parameter_vector = std::vector<T>;
template <typename T>
using observable_vector = std::vector<T>;

// Type aliases to improve readability
template <typename Base>
using AD = CppAD::AD<Base>;
using ADDouble = AD<double>;

template <typename T>
using Vector = Eigen::Matrix<T, Eigen::Dynamic, 1>;
template <typename T>
using Matrix = Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>;

using DoubleVector = Vector<double>;

// Helper type trait to get base type
template <typename T>
struct BaseType {
  using type = T;
};

template <typename Base>
struct BaseType<AD<Base>> {
  using type = Base;
};

================
File: project/HC-MC/tests/pt_tests.cpp
================
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include <doctest/doctest.h>

#include <Eigen/Dense>
#include <cmath>
#include <iostream>
#include <string>

#include "HC-MC.hpp"

// Helper function to print vectors nicely
void print_vector(const ADVector& v, const std::string& name) {
  std::cout << name << " = [";
  for (int i = 0; i < v.size(); ++i) {
    std::cout << std::setprecision(15) << CppAD::Value(v(i));
    if (i < v.size() - 1) {
      std::cout << ", ";
    }
  }
  std::cout << "]" << "\n";
}

TEST_CASE("Circle-Line Intersection") {
  auto F = [](const ADVector& X) {
    ADVector result(2);
    result(0) = X(0) * X(0) + X(1) * X(1) - 4.0;  // Circle of radius 2
    result(1) = X(0) + X(1) - 1.0;                // Line x + y = 1
    return result;
  };

  SolveOptions options;
  options.debug = true;
  options.tolerance = 1e-10;

  auto result = solve(F, 2, options);
  REQUIRE(result.has_value());

  const auto& solve_result = *result;
  REQUIRE(solve_result.success);
  REQUIRE(solve_result.residualNorm < 1e-8);

  // Verify the solution satisfies the system
  const auto& X = solve_result.solution;
  auto F_X = F(X);
  print_vector(X, "Solution");
  print_vector(F_X, "F(solution)");

  // Check both equations are satisfied
  REQUIRE(std::abs(CppAD::Value(F_X(0))) < 1e-8);  // Circle equation
  REQUIRE(std::abs(CppAD::Value(F_X(1))) < 1e-8);  // Line equation

  // Verify solution matches one of the two expected points
  double x = CppAD::Value(X(0));
  double y = CppAD::Value(X(1));
  bool matches_solution =
      (std::abs(x + y - 1.0) < 1e-8) &&        // Line equation
      (std::abs(x * x + y * y - 4.0) < 1e-8);  // Circle equation

  REQUIRE(matches_solution);
}

TEST_CASE("Parabola-Line Intersection") {
  auto F = [](const ADVector& X) {
    ADVector result(2);
    result(0) = X(0) * X(0) - X(1);  // Parabola y = x^2
    result(1) = X(1) - 4.0;          // Line y = 4
    return result;
  };

  SolveOptions options;
  options.debug = false;

  auto result = solve(F, 2);
  REQUIRE(result.has_value());

  const auto& solve_result = *result;
  REQUIRE(solve_result.success);
  REQUIRE(solve_result.residualNorm < 1e-8);

  // Verify solution satisfies both equations
  const auto& X = solve_result.solution;
  double x = CppAD::Value(X(0));
  double y = CppAD::Value(X(1));

  REQUIRE(std::abs(x * x - y) < 1e-8);  // Parabola equation
  REQUIRE(std::abs(y - 4.0) < 1e-8);    // Line equation

  // The solution should be either (2,4) or (-2,4)
  bool is_valid_solution =
      (std::abs(std::abs(x) - 2.0) < 1e-8) && (std::abs(y - 4.0) < 1e-8);
  REQUIRE(is_valid_solution);
}

TEST_CASE("3D Sphere-Plane-Line Intersection") {
  auto F = [](const ADVector& X) {
    ADVector result(3);
    result(0) =
        X(0) * X(0) + X(1) * X(1) + X(2) * X(2) - 4.0;  // Sphere radius 2
    result(1) = X(0) + X(1) + X(2) - 1.0;               // Plane x+y+z=1
    result(2) = X(0) - X(1);                            // Line x=y
    return result;
  };

  SolveOptions options;
  options.debug = false;
  options.tolerance = 1e-10;

  auto result = solve(F, 3, options);
  REQUIRE(result.has_value());

  const auto& solve_result = *result;
  REQUIRE(solve_result.success);
  REQUIRE(solve_result.residualNorm < 1e-8);

  // Verify solution satisfies all equations
  const auto& X = solve_result.solution;
  const double x = CppAD::Value(X(0));
  const double y = CppAD::Value(X(1));
  const double z = CppAD::Value(X(2));

  REQUIRE(std::abs(x * x + y * y + z * z - 4.0) < 1e-8);  // Sphere
  REQUIRE(std::abs(x + y + z - 1.0) < 1e-8);              // Plane
  REQUIRE(std::abs(x - y) < 1e-8);                        // Line
}

TEST_CASE("System with Transcendental Functions") {
  auto F = [](const ADVector& X) {
    ADVector result(2);
    result(0) = CppAD::cos(X(0)) - X(1);  // cos(x) = y
    result(1) = X(0) * X(1) - 0.5;        // xy = 0.5
    return result;
  };

  SolveOptions options;
  options.debug = false;
  options.verifyDerivatives = true;  // Test derivative computation

  auto result = solve(F, 2, options);
  REQUIRE(result.has_value());

  const auto& solve_result = *result;
  REQUIRE(solve_result.success);
  REQUIRE(solve_result.residualNorm < 1e-8);

  // Verify solution satisfies both equations
  const auto& X = solve_result.solution;
  const double x = CppAD::Value(X(0));
  const double y = CppAD::Value(X(1));

  REQUIRE(std::abs(std::cos(x) - y) < 1e-8);
  REQUIRE(std::abs(x * y - 0.5) < 1e-8);
}

TEST_CASE("Higher Dimensional System") {
  auto F = [](const ADVector& X) {
    ADVector result(4);
    result(0) = X(0) * X(0) * X(0) + CppAD::sin(X(1)) - 1.0;
    result(1) = X(0) * X(0) + X(1) * X(1) + X(2) * X(2) + X(3) * X(3) - 5.0;
    result(2) = X(0) + X(1) + X(2) + CppAD::pow(X(3), 5) + 2.5;
    result(3) = CppAD::sin(X(0)) + CppAD::exp(X(1)) +
                CppAD::cos(X(1)) * X(2) * X(2) * X(2) + 2.0;
    return result;
  };

  SolveOptions options;
  options.debug = true;
  options.maxIterations = 300;  // This system might need more iterations

  auto result = solve(F, 4, options);
  REQUIRE(result.has_value());

  const auto& solve_result = *result;
  REQUIRE(solve_result.success);
  REQUIRE(solve_result.residualNorm < 1e-8);

  // Verify each equation is satisfied
  const auto& X = solve_result.solution;
  auto F_X = F(X);
  for (int i = 0; i < F_X.size(); ++i) {
    REQUIRE(std::abs(CppAD::Value(F_X(i))) < 1e-8);
  }
}

int unused_main(int argc, char** argv) {
  doctest::Context context;
  context.applyCommandLine(argc, argv);

  const int result = context.run();

  if (context.shouldExit()) {
    return result;
  }

  return result;
}

================
File: project/HC-MC/main.cpp
================
#include <boost/numeric/odeint.hpp>
#include <functional>
#include <iostream>
#include <vector>

#include "HC-MC.hpp"
#include "ODESystem.hpp"
#include "integration_interface.hpp"
#include "types.hpp"

using namespace boost::numeric::odeint;

#include <cppad/cppad.hpp>
#include <vector>

template <typename T>
struct SystemConfig {
  std::vector<T> time_values;
  std::vector<T> true_params;
  std::vector<T> true_initial_state;
};

template <typename T>
struct SolverConfig {
  SolveOptions options;
  Vector<T> initial_guess;
};

SolverConfig<double> create_solver_config() {
  SolverConfig<double> config;
  config.options.debug = true;
  config.options.tolerance = 1e-6;
  config.options.maxIterations = 50;
  config.options.initialStepSize = 0.1;
  config.options.verifyDerivatives = true;

  config.initial_guess.resize(4);
  config.initial_guess[0] = 1.0;  // Guess for parameter p[0]
  config.initial_guess[1] = 1.0;  // Guess for parameter p[1]
  config.initial_guess[2] = 1.0;  // Guess for initial_state[0]
  config.initial_guess[3] = 0.5;  // Guess for initial_state[1]

  return config;
}

// Helper functions
SystemConfig<double> create_system_config() {
  return {
      {0.0, 0.5, 1.0, 1.5, 2.0},  // time_values
      {1.3, 1.8},                 // true_params
      {1.0, 0.5}                  // true_initial_state
  };
}

// State equation template
template <typename T>
struct MyStateEquations {
  void operator()(const state_vector<T>& x, state_vector<T>& dxdt,
                  const parameter_vector<T>& p, const T& /* t */) const {
    dxdt.resize(2);
    dxdt[0] = p[0] * x[0];
    dxdt[1] = p[1] * x[1];
  }
};

// Observation function template
template <typename T>
struct MyObservationFunction {
  void operator()(const state_vector<T>& x, observable_vector<T>& y) const {
    y.resize(2);
    y[0] = x[0];
    y[1] = x[1];
  }
};

// Create the true system with state equations and observation functions
auto create_true_system(const SystemConfig<double>& config) {
  /*  auto state_equations =
        [](const state_vector<double>& x, state_vector<double>& dxdt,
           const parameter_vector<double>& p, const double&  t ) {
          dxdt.resize(2);
          dxdt[0] = p[0] * x[0];
          dxdt[1] = p[1] * x[1];
        };

    auto observation_function = [](const state_vector<double>& x,
                                   observable_vector<double>& y) {
      y.resize(2);
      y[0] = x[0];
      y[1] = x[1];
    };*/

  ODESystem<double, MyStateEquations, MyObservationFunction> system(
      config.true_params, MyStateEquations<double>{},
      MyObservationFunction<double>{});
  system.setInitialState(config.true_initial_state);
  return system;
}

// Function to print results
void print_solution_results(const std::string& method_name,
                            const std::optional<SolveResult>& result) {
  if (result) {
    std::cout << "\nSolution found!\n";
    std::cout << "Estimated parameters: ";
    for (size_t i = 0; i < 2; ++i) {
      std::cout << (result->solution[i]) << " ";
    }
    std::cout << "\nEstimated initial state: ";
    for (size_t i = 2; i < 4; ++i) {
      std::cout << (result->solution[i]) << " ";
    }
    std::cout << "\nResidual norm: " << result->residualNorm << "\n";
    std::cout << "Iterations: " << result->iterations << "\n";
  } else {
    std::cout << "Failed to find solution with " << method_name << "\n";
  }
}

// Run both solvers and print results
void run_solvers(const auto& objective, const SolverConfig<double>& config) {
  std::cout << "\n=== Solving with original method ===\n";
  auto result = solve(objective, 4, config.options);
  print_solution_results("original method", result);

  std::cout << "\n=== Solving with Newton method ===\n";
  auto newton_result = solve_newton(objective, 4, config.options);
  print_solution_results("Newton method", newton_result);
}

template <typename VectorType>
VectorType ode_system(const VectorType& y) {
  size_t n = y.size();
  VectorType dy_dt(n);
  dy_dt[0] = 1;  // Example: dy_0/dt = 1
  for (size_t k = 1; k < n; ++k) {
    dy_dt[k] = y[k - 1];  // dy_k/dt = y_{k-1}
  }
  return dy_dt;
}

// Generate ground truth data from the system
template <typename System>
std::vector<observable_vector<double>> generate_ground_truth(
    const System& system, const std::vector<double>& time_values) {
  return integrate_and_observe(system, time_values);
}

// Create the parameter estimation objective function
template <typename T>
auto create_parameter_objective(
    const SystemConfig<double>& config, const std::vector<double>& time_values,
    const std::vector<observable_vector<double>>& ground_truth) {
  return [config, time_values,
          ground_truth](const ADVector& params) -> ADVector {
    /*std::cout << "\n=== Parameter Objective Called ===\n";*/

    // Debug input parameters
    /*std::cout << "Input params: ";
    for (const auto& p : params) {
      std::cout << (p) << " ";
    }
    std::cout << "\n";*/

    // Extract parameters and initial state
    size_t param_size = 2;
    size_t state_size = 2;
    parameter_vector<AD<T>> p(params.data(), params.data() + param_size);
    state_vector<AD<T>> initial_state(params.data() + param_size,
                                      params.data() + param_size + state_size);

    /*std::cout << "Creating system with:\n";
    std::cout << "Parameters: " << (p[0]) << ", " << (p[1]) << "\n";
    std::cout << "Initial state: " << (initial_state[0]) << ", "
              << (initial_state[1]) << "\n";*/

    // Create the ODESystem instance directly with AD types
    ODESystem<AD<T>, MyStateEquations, MyObservationFunction> system(
        p, MyStateEquations<AD<T>>{}, MyObservationFunction<AD<T>>{});
    system.setInitialState(initial_state);

    // Simulate the system
    std::vector<AD<T>> ad_time_values(time_values.begin(), time_values.end());
    auto simulated_observables = integrate_and_observe(system, ad_time_values);

    // Debug simulated results
    /*std::cout << "\nSimulated observables:\n";
    for (size_t i = 0; i < simulated_observables.size(); ++i) {
      std::cout << "t = " << time_values[i] << ": ";
      for (const auto& val : simulated_observables[i]) {
        std::cout << (val) << " ";
      }
      std::cout << "\n";
    }*/

    // Calculate residuals
    auto observable_length = simulated_observables[0].size();
    ADVector residuals(observable_length * 2);

    size_t observable_count = simulated_observables.size();
    size_t midpoint = observable_count / 2;

    // Only use first and middle point for residuals
    size_t idx = 0;
    size_t i = 0;
    for (size_t j = 0; j < simulated_observables[i].size(); ++j) {
      residuals[idx] = simulated_observables[i][j] - T(ground_truth[i][j]);
      // std::cout << "Residual " << idx << ": " << (residuals[idx]) << " = "
      //           << (simulated_observables[i][j]) << " - " <<
      //           ground_truth[i][j]
      //           << "\n";
      idx++;
    }
    i = midpoint;
    for (size_t j = 0; j < simulated_observables[i].size(); ++j) {
      residuals[idx] = simulated_observables[i][j] - T(ground_truth[i][j]);
      // std::cout << "Residual " << idx << ": " << (residuals[idx]) << " = "
      //           << (simulated_observables[i][j]) << " - " <<
      //           ground_truth[i][j]
      //           << "\n";
      idx++;
    }

    return residuals;
  };
}

// Break down the main function into smaller pieces
void example_parameter_estimation() {
  // Setup configuration
  auto config = create_system_config();
  auto solver_config = create_solver_config();

  // Generate ground truth data
  auto true_system = create_true_system(config);
  auto ground_truth = generate_ground_truth(true_system, config.time_values);

  // Display ground truth data
  std::cout << "\nGround truth data:\n";
  for (size_t i = 0; i < config.time_values.size(); ++i) {
    std::cout << "t = " << config.time_values[i] << ", Observables: ";
    for (const auto& val : ground_truth[i]) {
      std::cout << val << " ";
    }
    std::cout << "\n";
  }

  // Create and run solvers
  auto objective = create_parameter_objective<double>(
      config, config.time_values, ground_truth);
  run_solvers(objective, solver_config);
}

int main() {
  example_parameter_estimation();

  return 0;
}

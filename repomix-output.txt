This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-16T07:19:14.311Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.dev/
  Dockerfile
cmake/
  clang_format.cmake
  clang_tidy.cmake
  compiler_options.cmake
  cpack.cmake
  cppcheck.cmake
  dependencies.cmake
discard_files/
  old-build.sh
examples/
  AAA.cpp
  time_derivatives.cpp
project/
  HC-MC/
    include/
      AAA.hpp
      hbtaylor.hpp
      HC-MC.hpp
      integration_interface.hpp
      observability.hpp
      ODESystem.hpp
      prob1.hpp
      types.hpp
    tests/
      pt_tests.cpp
    CMakeLists.txt
    main.cpp
    oldermaincpp.txt
  CMakeLists.txt
.clang-format
.clang-tidy
.dockerignore
.gitignore
.gitmodules
.repomixignore
build.sh
CMakeLists.txt
cppcheck_suppressions.txt
README.md
vcpkg.json

================================================================
Repository Files
================================================================

================
File: .dev/Dockerfile
================
FROM ubuntu:24.04

# Define Conan and CMake versions
ARG CONAN_VERSION=2.6.0
ARG CMAKE_VERSION=3.30.1

# Define User ID and Group ID
ARG USER_ID=1000
ARG GROUP_ID=1000

WORKDIR /project

# Define Labels
LABEL maintainer="Michele Adduci <adduci@tutanota.com>" \
      description="Docker image for C++ development with Conan and CMake" \
      cmake.version="${CMAKE_VERSION}" \
      conan.version="${CONAN_VERSION}" 

# Install basic tooling
RUN apt-get update && \
    apt-get install -y \
        build-essential \
        curl \
        gcc \
        cppcheck \
        clang-format && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Install Conan and CMake from GitHub Releases
RUN curl -fsSL https://github.com/conan-io/conan/releases/download/${CONAN_VERSION}/conan-${CONAN_VERSION}-amd64.deb -o /tmp/conan.deb && \
    dpkg -i /tmp/conan.deb && \
    curl -fsSL https://github.com/Kitware/CMake/releases/download/v${CMAKE_VERSION}/cmake-${CMAKE_VERSION}-linux-x86_64.tar.gz -o /tmp/cmake.tar.gz && \
    mkdir -p /opt/cmake && \
    tar -xzf /tmp/cmake.tar.gz -C /opt/cmake/ --strip-components=1 && \
    chmod +x /opt/cmake/bin/* && \
    ln -sf /opt/cmake/bin/cmake /usr/bin/cmake && \
    ln -sf /opt/cmake/bin/ctest /usr/bin/ctest && \
    ln -sf /opt/cmake/bin/cpack /usr/bin/cpack && \
    ln -sf /opt/cmake/bin/ccmake /usr/bin/ccmake && \
    rm -rf /tmp/*

# Create non-root user to run container with less privileges
USER ${USER_ID}

# Run Conan profile detection as non-root user
RUN conan profile detect

================
File: cmake/clang_format.cmake
================
# MIT License 
# Copyright (c) 2018-Today Michele Adduci <adduci@tutanota.com>
#
# Clang-Format instructions

find_program(CLANG_FORMAT_BIN NAMES clang-format)

if(CLANG_FORMAT_BIN)
  message(STATUS "Found: clang-format")
  
  file(GLOB_RECURSE ALL_SOURCE_FILES 
    ${PROJECT_SOURCE_DIR}/project/*.cpp
    ${PROJECT_SOURCE_DIR}/project/*.h
    ${PROJECT_SOURCE_DIR}/project/*.hpp
  )

  add_custom_target(
    format
    COMMAND ${CLANG_FORMAT_BIN}
    -i
    --style=file
    ${ALL_SOURCE_FILES}
  )

  add_custom_target(
    format-check
    COMMAND ${CLANG_FORMAT_BIN}
    --style=file
    --dry-run
    --Werror
    ${ALL_SOURCE_FILE}
  )

  add_custom_target(
    format-all
    COMMAND ${CMAKE_COMMAND} --build ${CMAKE_BINARY_DIR} --target format
    COMMENT "Running clang-format on all source files"
  )
else()
  message(STATUS "clang-format not found. Formatting targets will not be available.")
endif()

================
File: cmake/clang_tidy.cmake
================
# Find clang-tidy executable
find_program(CLANG_TIDY_BIN NAMES clang-tidy)

if(CLANG_TIDY_BIN)
    message(STATUS "Found: clang-tidy")
    
    # Get all source files
    file(GLOB_RECURSE ALL_SOURCE_FILES 
        ${PROJECT_SOURCE_DIR}/project/*.cpp
        ${PROJECT_SOURCE_DIR}/project/*.h
        ${PROJECT_SOURCE_DIR}/project/*.hpp
    )

    # Remove mpreal.h from the list
    list(FILTER ALL_SOURCE_FILES EXCLUDE REGEX ".*mpreal\\.h$")

    # Create a custom target for running clang-tidy
    add_custom_target(
        tidy
        COMMAND ${CLANG_TIDY_BIN}
            -p=${CMAKE_BINARY_DIR}
            ${ALL_SOURCE_FILES}
            > ${CMAKE_BINARY_DIR}/clang-tidy-report.txt
        COMMENT "Running clang-tidy and generating report..."
        VERBATIM
    )

    # Add a target to show the report
    add_custom_target(
        tidy-report
        COMMAND ${CMAKE_COMMAND} -E cat ${CMAKE_BINARY_DIR}/clang-tidy-report.txt
        DEPENDS tidy
        COMMENT "Showing clang-tidy report..."
    )
else()
    message(STATUS "clang-tidy not found. Tidy targets will not be available.")
endif()

================
File: cmake/compiler_options.cmake
================
# MIT License 
# Copyright (c) 2018-Today Michele Adduci <adduci@tutanota.com>
#
# Compiler options with hardening flags

#consider reverting -Wnosign-conversion

if(MSVC)
    list(APPEND compiler_options 
        /W4
        /WX
        /permissive-
        $<$<CONFIG:RELEASE>:/O2 /Ob2 >
        $<$<CONFIG:MINSIZEREL>:/O1 /Ob1>
        $<$<CONFIG:RELWITHDEBINFO>:/Zi /O2 /Ob1>
        $<$<CONFIG:DEBUG>:/Zi /Ob0 /Od /RTC1>)

    list(APPEND compiler_definitions
        _UNICODE
        WINDOWS
        $<$<OR:$<CONFIG:RELEASE>,$<CONFIG:RELWITHDEBINFO>,$<CONFIG:MINSIZEREL>>:NDEBUG>
        $<$<CONFIG:DEBUG>:_DEBUG>)

    list(APPEND linker_flags
        $<$<BOOL:${BUILD_SHARED_LIBS}>:/LTCG>
    )

    set(MSVC_RUNTIME_TYPE $<IF:$<BOOL:${BUILD_WITH_MT}>,MultiThreaded$<$<CONFIG:Debug>:Debug>,MultiThreaded$<$<CONFIG:Debug>:Debug>>DLL)

else(MSVC)
    # Enhanced warning flags for GCC/Clang
    list(APPEND compiler_options 
        -Wall
        -Wextra
        -Wpedantic
        -Werror=return-type
        -Werror=uninitialized
        -Werror=maybe-uninitialized
        -Wconversion
        -Wno-sign-conversion
        -Wcast-align
        -Wcast-qual
        -Wdisabled-optimization
        -Wformat=2
        -Winit-self
        -Wlogical-op
        -Wmissing-include-dirs
        -Wnoexcept
        -Wold-style-cast
        -Woverloaded-virtual
        -Wredundant-decls
        -Wshadow
        -Wsign-promo
        -Wstrict-null-sentinel
        -Wstrict-overflow=5
        -Wswitch-default
        -Wundef
        $<$<CXX_COMPILER_ID:GNU>:-Wuseless-cast>
        -Wno-unknown-pragmas
        $<$<CONFIG:DEBUG>:-fno-omit-frame-pointer>
        $<$<CONFIG:DEBUG>:-O0 -g3>
        $<$<CONFIG:RELEASE>:-O3>
    )

    # Enhanced security flags
    list(APPEND compiler_definitions
        $<$<OR:$<CONFIG:RELEASE>,$<CONFIG:MINSIZEREL>>:_FORTIFY_SOURCE=2>
    )
 
    list(APPEND linker_flags
        $<$<NOT:$<CXX_COMPILER_ID:AppleClang>>:-Wl,-z,defs>
        $<$<NOT:$<CXX_COMPILER_ID:AppleClang>>:-Wl,-z,now>
        $<$<NOT:$<CXX_COMPILER_ID:AppleClang>>:-Wl,-z,relro>
        $<$<AND:$<NOT:$<CXX_COMPILER_ID:AppleClang>>,$<NOT:$<CXX_COMPILER_ID:Clang>>,$<NOT:$<BOOL:${BUILD_SHARED_LIBS}>>>:-Wl,-pie>
        $<$<AND:$<NOT:$<CXX_COMPILER_ID:AppleClang>>,$<NOT:$<CXX_COMPILER_ID:Clang>>,$<NOT:$<BOOL:${BUILD_SHARED_LIBS}>>>:-fpie>
        $<$<AND:$<NOT:$<CXX_COMPILER_ID:AppleClang>>,$<NOT:$<CXX_COMPILER_ID:Clang>>,$<NOT:$<BOOL:${BUILD_SHARED_LIBS}>>>:-pipe>
        $<$<AND:$<NOT:$<CXX_COMPILER_ID:AppleClang>>,$<NOT:$<CXX_COMPILER_ID:Clang>>,$<NOT:$<BOOL:${BUILD_SHARED_LIBS}>>>:-static-libstdc++>
        $<$<CONFIG:DEBUG>:-fno-omit-frame-pointer>
        $<$<CONFIG:DEBUG>:-fsanitize=address>
        $<$<CONFIG:DEBUG>:-fsanitize=leak>
        $<$<CONFIG:DEBUG>:-fsanitize=undefined>
        $<$<AND:$<NOT:$<CXX_COMPILER_ID:AppleClang>>,$<NOT:$<CXX_COMPILER_ID:Clang>>>:-fstack-clash-protection>
        $<$<AND:$<NOT:$<CXX_COMPILER_ID:AppleClang>>,$<NOT:$<CXX_COMPILER_ID:Clang>>>:-fbounds-check>
        -fstack-protector
        -fPIC
    )

endif()

# Make sure the options are actually applied to targets
function(target_enable_warnings target_name)
    if(MSVC)
        target_compile_options(${target_name} PRIVATE ${compiler_options})
    else()
        target_compile_options(${target_name} PRIVATE ${compiler_options})
    endif()
endfunction()

================
File: cmake/cpack.cmake
================
# MIT License 
# Copyright (c) 2018-Today Michele Adduci <adduci@tutanota.com>
#
# Packaging instructios

set(CPACK_PACKAGE_VENDOR "Michele Adduci <adduci@tutanota.com>")
set(CPACK_PACKAGE_VERSION_MAJOR "${CMAKE_PROJECT_VERSION_MAJOR}")
set(CPACK_PACKAGE_VERSION_MINOR "${CMAKE_PROJECT_VERSION_MINOR}")
set(CPACK_PACKAGE_VERSION_PATCH "${CMAKE_PROJECT_VERSION_PATCH}")
set(CPACK_GENERATOR "ZIP;TGZ")
set(CPACK_STRIP_FILES "TRUE")

include(CPack)

================
File: cmake/cppcheck.cmake
================
# Find clang-tidy executable
find_program(CPPCHECK_BIN NAMES cppcheck)

if(CPPCHECK_BIN)
    message(STATUS "Found: cppcheck")
    
    # Existing configuration for build-time checks
    list(
        APPEND CMAKE_CXX_CPPCHECK 
            "${CPPCHECK_BIN}"
            "--enable=all"
            "--enable=warning,performance,portability,information,missingInclude"
            "--inconclusive"
            "--check-config"
            "--force" 
            "--inline-suppr"
            "--suppressions-list=${CMAKE_SOURCE_DIR}/cppcheck_suppressions.txt"
            "--xml"
            "--output-file=${CMAKE_BINARY_DIR}/cppcheck.xml"
    )

    # Add custom target for explicit cppcheck runs
    add_custom_target(
        cppcheck-analysis
        COMMAND ${CPPCHECK_BIN}
            --enable=all
            --enable=missingInclude
            --std=c++17
            --error-exitcode=1
            --suppress=missingInclude
            -i${CMAKE_SOURCE_DIR}/build
            ${PROJECT_SOURCE_DIR}/project
        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
        COMMENT "Running cppcheck analysis"
    )

else()
    message(STATUS "cppcheck not found. Analysis targets will not be available.")
endif()

================
File: cmake/dependencies.cmake
================
# MIT License 
# Copyright (c) 2018-Today Michele Adduci <adduci@tutanota.com>
#
# Dependencies

# Required for Testing
if(BUILD_TESTING)
  find_package(doctest REQUIRED)
endif()

# Optional Dependency, doesn't trigger error if missing
find_package(OpenSSL)

================
File: discard_files/old-build.sh
================
#!/bin/bash
set -e  # Exit on any error

# Parse command line arguments
BUILD_TYPE="Debug"  # Default to Debug
COMPILER="gcc"      # Default to gcc
COMPILER_VERSION="" # Optional version specifier

print_usage() {
    echo "Usage: $0 [options]"
    echo "Options:"
    echo "  --debug                Build with debug symbols (default)"
    echo "  --release              Build with optimizations"
    echo "  --compiler=<name>      Use specific compiler (gcc|clang)"
    echo "  --compiler-version=<v> Use specific compiler version (e.g., 13, 15)"
    echo "  --help                 Show this help message"
    echo
    echo "Examples:"
    echo "  $0 --compiler=clang --compiler-version=15 --release"
    echo "  $0 --compiler=gcc --compiler-version=13"
}

while [[ $# -gt 0 ]]; do
    case $1 in
        --release)
            BUILD_TYPE="Release"
            shift
            ;;
        --debug)
            BUILD_TYPE="Debug"
            shift
            ;;
        --compiler=*)
            COMPILER="${1#*=}"
            shift
            ;;
        --compiler-version=*)
            COMPILER_VERSION="${1#*=}"
            shift
            ;;
        --help)
            print_usage
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            print_usage
            exit 1
            ;;
    esac
done

# Set up compiler environment variables
setup_compiler() {
    local compiler_name="$1"
    local version="$2"
    
    # Clear any existing compiler variables
    unset CC CXX
    
    case $compiler_name in
        gcc)
            if [ -n "$version" ]; then
                export CC="gcc-${version}"
                export CXX="g++-${version}"
            else
                export CC="gcc"
                export CXX="g++"
            fi
            ;;
            
        clang)
            if [ -n "$version" ]; then
                export CC="clang-${version}"
                export CXX="clang++-${version}"
            else
                export CC="clang"
                export CXX="clang++"
            fi
            ;;
            
        *)
            echo "Unsupported compiler: $compiler_name"
            exit 1
            ;;
    esac
    
    # Verify compiler exists
    if ! command -v "$CC" >/dev/null 2>&1; then
        echo "Error: Compiler $CC not found"
        exit 1
    fi
    
    if ! command -v "$CXX" >/dev/null 2>&1; then
        echo "Error: Compiler $CXX not found"
        exit 1
    fi
    
    echo "Using C compiler: $CC ($(command -v "$CC"))"
    echo "Using C++ compiler: $CXX ($(command -v "$CXX"))"
}

# Set up the compiler
setup_compiler "$COMPILER" "$COMPILER_VERSION"

# Clone vcpkg if it doesn't exist
if [ ! -d "external/vcpkg" ]; then
    echo "Cloning vcpkg..."
    git clone https://github.com/Microsoft/vcpkg.git external/vcpkg
    external/vcpkg/bootstrap-vcpkg.sh
fi

# Set VCPKG_ROOT to the submodule path
export VCPKG_ROOT=$(pwd)/external/vcpkg

# Clean build directory
rm -rf build

echo "Configuring for ${BUILD_TYPE} build using ${CXX}..."

# Configure the project with CMake and vcpkg
cmake -B build -S . \
    -DCMAKE_TOOLCHAIN_FILE="$VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake" \
    -DVCPKG_TARGET_TRIPLET=x64-linux \
    -DBUILD_TESTING=ON \
    -DCMAKE_BUILD_TYPE=${BUILD_TYPE} \
    -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
    -DCMAKE_C_COMPILER="$CC" \
    -DCMAKE_CXX_COMPILER="$CXX"

# Build the project
echo "Building..."
cmake --build build

# Optional: Run tests after building
echo "Running tests..."
ctest --test-dir build --output-on-failure

echo "Build complete. Type: ${BUILD_TYPE}"
if [ "$BUILD_TYPE" = "Debug" ]; then
    echo "Debug symbols are enabled. You can use gdb/lldb for debugging."
fi

# Print compiler version information
$CXX --version

================
File: examples/AAA.cpp
================
#include "AAA.hpp"
#include "mpreal.h"
#include <complex>
#include <iostream>
#include <vector>

template<typename T>
T
Func(const T &x) {
    // return (T(1.0) / T(x - 0.1)) * std::abs(x - T(0.5)) * std::exp(std::sin(20.0 * x));
    return (exp(x)) * sqrt(x + 0.1) + abs(x - 0.1234567);
}

int
main() {
    using mpfr::mpreal;


    // Required precision of computations in decimal digits
    // Play with it to check different precisions
    const int digits = 50;

    // Setup default precision for all subsequent computations
    // MPFR accepts precision in bits - so we do the conversion
    mpreal::set_default_prec(mpfr::digits2bits(digits));

    mpreal r = 0;


    // Sample points (Z) and function values (F)


    using Scalar = mpreal;
    //    using Complex = std::complex<Scalar>;

    using Complex = Scalar;

    std::vector<Scalar> Z;
    std::vector<Scalar> F;

    // Example: Approximate the function f(z) = exp(z) on the interval [0, 1]
    size_t N = 203; // Reduced number of points for brevity
    for (size_t i = 0; i < N; ++i) {
        Scalar x = Scalar(i) / (N - 1); // Points between 0 and 1
        Scalar z = x;
        Z.push_back(z);
        F.push_back(Func(z));
    }

    // Create AAA approximant
    AAA<Scalar> approximant;
    approximant.fit(Z, F);

    // Evaluate at new points
    std::vector<Scalar> Z_eval;
    for (size_t i = 0; i < N; ++i) {
        Scalar x = Scalar(i) / (N - 1) + 0.001; // Shifted points
        Z_eval.push_back(x);
    }

    std::vector<Scalar> F_approx = approximant(Z_eval);

    // Compare with exact values
    for (size_t i = 0; i < Z_eval.size(); ++i) {
        Scalar f_exact = Func(Z_eval[i]);
        Scalar f_approx = F_approx[i];
        Scalar error = abs(f_exact - f_approx);
        std::cout << "z = " << Z_eval[i] << ", Exact = " << f_exact << ", Approx = " << f_approx
                  << ", Error = " << error << std::endl;
    }

    return 0;
}

================
File: examples/time_derivatives.cpp
================
#include <boost/numeric/odeint.hpp>
#include <functional>
#include <iostream>
#include <vector>

// #include "HC-MC.hpp"
#include "ODESystem.hpp"
#include "hbtaylor.hpp"
#include "types.hpp"

using namespace boost::numeric::odeint;

#include <cppad/cppad.hpp>
#include <vector>

/*// Function to compute time derivatives of an ODE system at a given point
template <typename F, typename Scalar, typename ScalarVec>
std::vector<ScalarVec> compute_time_derivatives(
    F&& ode_function,        // ODE function representing dy/dt = F(y)
    const ScalarVec& X,      // State variables at which to compute derivatives
    size_t num_derivatives)  // Number of derivatives to compute
{
  size_t n = X.size();

  // Convert Vector<Scalar> to std::vector<Scalar> for TaylorSeries
  std::vector<Scalar> x_vec(n);
  for (size_t i = 0; i < n; ++i) {
    x_vec[i] = X[i];
  }

  // Compute Taylor series coefficients using hbtaylor
  std::vector<TaylorSeries<Scalar>> taylor_coeffs =
      computeODECoefficients(x_vec, ode_function, num_derivatives);

  // Convert TaylorSeries coefficients to time derivatives
  std::vector<ScalarVec> derivatives(num_derivatives, ScalarVec(n));
  for (size_t k = 0; k < num_derivatives; ++k) {
    for (size_t i = 0; i < n; ++i) {
      // The k-th derivative is k! times the k-th coefficient
      Scalar factorial = 1;
      for (Scalar j = 1; j <= k + 1; ++j) {
        factorial *= j;
      }
      derivatives[k][i] = taylor_coeffs[i][k + 1] * factorial;
    }
  }

  return derivatives;
}*/
template <typename T>
class ode_system {
 public:
  void operator()(const std::vector<T>& y, std::vector<T>& dydt) const {
    size_t n = y.size();
    dydt.resize(n);
    dydt[0] = T(1);  // dy_0/dt = 1
    for (size_t k = 1; k < n; ++k) {
      dydt[k] = y[k - 1];  // dy_k/dt = y_{k-1}
    }
  }
};

int main() {
  using Scalar = double;  // Ensure Scalar is double
                          // using VectorType = Vector<Scalar>;

  using VectorType = std::vector<Scalar>;
  VectorType X(5, 1.0);

  // EIGEN INITIALIATION Initial state variables
  // VectorType X(5);
  // X << 0.0, 0.0, 0.0, 0.0, 0.0;

  // Number of derivatives to compute
  size_t num_derivatives = 5;

  ode_system<TaylorSeries<Scalar>> ode_function_ts;

  // Compute Taylor series coefficients
  auto taylor_coeffs =
      computeODECoefficients<ode_system<TaylorSeries<Scalar>>, Scalar>(
          X, ode_function_ts, num_derivatives);

  // Convert coefficients to derivatives
  std::vector<std::vector<Scalar>> derivatives(num_derivatives,
                                               std::vector<Scalar>(X.size()));
  for (size_t k = 0; k < num_derivatives; ++k) {
    for (size_t i = 0; i < X.size(); ++i) {
      // k-th derivative is k! times the k-th coefficient
      Scalar factorial = 1;
      for (Scalar j = 1; j <= k + 1; ++j) {
        factorial *= j;
      }
      derivatives[k][i] = taylor_coeffs[i][k + 1] * factorial;
    }
  }

  // Output the derivatives
  std::cout << "Time derivatives at X:\n";
  for (size_t k = 0; k < derivatives.size(); ++k) {
    std::cout << "Order " << k + 1 << " derivatives:\n";
    for (size_t i = 0; i < derivatives[k].size(); ++i) {
      std::cout << "  Variable " << i << ": " << derivatives[k][i] << "\n";
    }
  }

  return 0;
}

================
File: project/HC-MC/include/AAA.hpp
================
#ifndef AAA_HPP
#define AAA_HPP

#include <Eigen/Dense>
#include <algorithm>
#include <cmath>
#include <complex>
#include <iostream>  // For debug output
#include <limits>
#include <numeric>
#include <vector>

template <typename Scalar>
class AAA {
 public:
  using Complex = std::complex<Scalar>;
  using VectorX = Eigen::Matrix<Scalar, Eigen::Dynamic, 1>;

  AAA() = default;

  /**
   * Fit the AAA approximant to the data points (Z, F).
   *
   * @param Z     Vector of sample points in the Scalar plane.
   * @param F     Vector of function values at the points in Z.
   * @param tol   Relative tolerance for convergence (default: 1e-13).
   * @param mmax  Maximum number of iterations (default: 150).
   */
  void fit(const std::vector<Scalar> &Z, const std::vector<Scalar> &F,
           Scalar tol = Scalar(1e-13), size_t mmax = 150);

  /**
   * Evaluate the AAA approximant at a given point z.
   *
   * @param z  Point at which to evaluate the approximant.
   * @return   Approximated function value at z.
   */
  Scalar operator()(const Scalar &z) const;

  /**
   * Evaluate the AAA approximant at multiple points.
   *
   * @param Z_eval  Vector of points at which to evaluate the approximant.
   * @return        Vector of approximated function values.
   */
  std::vector<Scalar> operator()(const std::vector<Scalar> &Z_eval) const;

  /**
   * Get the support points used in the approximation.
   */
  const std::vector<Scalar> &support_points() const { return z_; }

  /**
   * Get the weights used in the approximation.
   */
  const std::vector<Scalar> &weights() const { return w_; }

  /**
   * Get the function values at the support points.
   */
  const std::vector<Scalar> &function_values() const { return f_; }

 private:
  std::vector<Scalar> z_;  // Support points
  std::vector<Scalar> f_;  // Function values at support points
  std::vector<Scalar> w_;  // Barycentric weights

  // Helper function to compute the barycentric weights
  void compute_weights(
      const Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic> &A,
      const std::vector<size_t> &J);

  // Helper function to evaluate the approximant at a point
  Scalar evaluate(const Scalar &z) const;

  // Helper function to remove Froissart doublets (spurious poles)
  void remove_froissart_doublets(const std::vector<Scalar> &Z,
                                 const std::vector<Scalar> &F);

  // Error vector to track convergence
  std::vector<Scalar> error_history_;
};

template <typename Scalar>
void AAA<Scalar>::fit(const std::vector<Scalar> &Z,
                      const std::vector<Scalar> &F, Scalar tol, size_t mmax) {
  size_t M = Z.size();
  if (M != F.size()) {
    throw std::invalid_argument("Z and F must be of the same length.");
  }

  // Initialize variables
  std::vector<size_t> J(M);
  std::iota(J.begin(), J.end(), 0);  // Indices of unused points

  z_.clear();
  f_.clear();
  w_.clear();
  error_history_.clear();

  // Initial approximation is the mean of F
  Scalar meanF = std::accumulate(F.begin(), F.end(), Scalar(0)) / Scalar(M);
  VectorX R = VectorX::Constant(M, meanF);

  // Compute initial error over all points
  Scalar error = 0;
  for (size_t idx : J) {
    Scalar e = abs(F[idx] - R(idx));
    if (e > error) {
      error = e;
    }
  }
  error_history_.push_back(error);

  using EMatrixType = Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic>;
  //  using EVectorType = Eigen::Matrix<Scalar, 1, Eigen::Dynamic>;

  EMatrixType C = EMatrixType::Zero(M, 0);  // Cauchy matrix
  EMatrixType A = EMatrixType::Zero(M, 0);  // Loewner matrix

  size_t m = 0;
  while (error > tol && m < mmax && !J.empty()) {
    // Find the index with maximum error
    size_t j = J[0];
    Scalar max_error = abs(F[j] - R(j));
    for (size_t idx : J) {
      Scalar e = abs(F[idx] - R(idx));
      if (e > max_error) {
        max_error = e;
        j = idx;
      }
    }

    // Add new support point
    z_.push_back(Z[j]);
    f_.push_back(F[j]);
    m++;

    // Remove index j from J
    J.erase(std::remove(J.begin(), J.end(), j), J.end());

    // Update Cauchy matrix
    C.conservativeResize(Eigen::NoChange, m);
    for (size_t i = 0; i < M; ++i) {
      C(i, m - 1) = Scalar(1) / (Z[i] - Z[j]);
    }

    // Update Loewner matrix
    A.conservativeResize(Eigen::NoChange, m);
    for (size_t i = 0; i < M; ++i) {
      A(i, m - 1) = (F[i] - F[j]) * C(i, m - 1);
    }

    // Compute weights
    compute_weights(A, J);

    // Evaluate rational approximant at unused points
    // Set R at support points to exact values
    R = Eigen::Map<const VectorX>(F.data(), M);

    for (size_t idx : J) {
      R(idx) = evaluate(Z[idx]);
    }

    // Compute error over indices J (non-support points)
    error = 0;
    for (size_t idx : J) {
      Scalar e = abs(F[idx] - R(idx));
      if (e > error) {
        error = e;
      }
    }
    error_history_.push_back(error);

    // Debug output
    std::cout << "Iteration " << m << ", error = " << error << "\n";

    if (isnan(error) || isinf(error)) {
      std::cerr << "Error became NaN or Inf. Stopping iteration." << "\n";
      break;
    }
  }

  // Remove spurious poles
  // remove_froissart_doublets(Z, F); // Not implemented yet
}

template <typename Scalar>
void AAA<Scalar>::compute_weights(
    const Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic> &A,
    const std::vector<size_t> &J) {
  size_t m = A.cols();
  size_t n = J.size();

  if (m == 0) {
    // No weights to compute
    w_.clear();
    return;
  }

  if (m == 1) {
    // Only one support point
    w_.assign(1, Scalar(1.0));
    return;
  }
  using EMatrixType = Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic>;
  using EVectorType = Eigen::Matrix<Scalar, 1, Eigen::Dynamic>;

  if (n >= m) {
    // The usual tall-skinny case
    EMatrixType A_sub(n, m);
    for (size_t i = 0; i < n; ++i) {
      A_sub.row(i) = A.row(J[i]);
    }
    Eigen::JacobiSVD<EMatrixType> svd(A_sub, Eigen::ComputeThinV);
    EVectorType w = svd.matrixV().col(svd.matrixV().cols() - 1);
    w_ = std::vector<Scalar>(w.data(), w.data() + w.size());
  } else if (n >= 1) {
    // Fewer rows than columns
    EMatrixType A_sub(n, m);
    for (size_t i = 0; i < n; ++i) {
      A_sub.row(i) = A.row(J[i]);
    }
    Eigen::FullPivLU<EMatrixType> lu_decomp(A_sub);
    EMatrixType null_space = lu_decomp.kernel();
    if (null_space.cols() > 0) {
      EMatrixType w = null_space.col(0);
      w_ = std::vector<Scalar>(w.data(), w.data() + w.size());
    } else {
      // Should not happen
      std::cerr
          << "Warning: Null space computation failed. Using default weights."
          << "n";
      w_.assign(m, Scalar(1.0));
    }
  } else {
    // No rows at all
    w_.assign(m, Scalar(1.0) / sqrt(Scalar(m)));
  }
}

template <typename Scalar>
Scalar AAA<Scalar>::operator()(const Scalar &z) const {
  return evaluate(z);
}

template <typename Scalar>
std::vector<Scalar> AAA<Scalar>::operator()(
    const std::vector<Scalar> &Z_eval) const {
  std::vector<Scalar> result;
  result.reserve(Z_eval.size());
  for (const auto &z : Z_eval) {
    result.push_back(evaluate(z));
  }
  return result;
}
template <typename Scalar>
Scalar AAA<Scalar>::evaluate(const Scalar &z) const {
  if (z_.empty()) {
    std::cerr << "Error: No support points available for evaluation." << "n";
    return Scalar(std::numeric_limits<Scalar>::quiet_NaN());
  }

  if (z_.size() == 1) {
    return f_[0];
  }

  Scalar tol = Scalar(1e-13);
  Scalar tol_quarter = pow(tol, Scalar(0.25));

  Scalar numerator = 0;
  Scalar denominator = 0;

  bool breakflag = false;
  size_t breakindex = std::numeric_limits<size_t>::max();

  for (size_t j = 0; j < z_.size(); ++j) {
    Scalar diff = z - z_[j];
    Scalar abs_diff = abs(diff);
    if (abs_diff < tol_quarter) {
      breakflag = true;
      breakindex = j;
      break;
    }
    Scalar term = w_[j] / diff;
    numerator += term * f_[j];
    denominator += term;
  }

  if (breakflag) {
    numerator = 0;
    denominator = 0;
    for (size_t j = 0; j < z_.size(); ++j) {
      if (j == breakindex) {
        continue;
      }
      Scalar diff = z - z_[j];
      Scalar term = w_[j] / diff;
      numerator += term * f_[j];
      denominator += term;
    }
    Scalar m = z - z_[breakindex];
    Scalar fz = (w_[breakindex] * f_[breakindex] + m * numerator) /
                (w_[breakindex] + m * denominator);
    return fz;
  } else {
    if (denominator == Scalar(0)) {
      std::cerr << "Warning: Denominator is zero at z = " << z << std::endl;
      return Scalar(std::numeric_limits<Scalar>::quiet_NaN());
    }
    return numerator / denominator;
  }
}

#endif  // AAA_HPP

================
File: project/HC-MC/include/hbtaylor.hpp
================
#pragma once

#include <algorithm>
#include <array>
#include <cmath>
#include <cstddef>
#include <iostream>
#include <vector>

template <typename T>
class TaylorSeries {
 private:
  int degree;                   // Degree of the Taylor series
  std::vector<T> coefficients;  // coefficients[i] represents the i-th
                                // derivative divided by i!
  static const T epsilon;       // Declaration only

 public:
  // Constructor for implicit conversion from base type
  template <typename U,
            typename = std::enable_if_t<std::is_convertible_v<U, T>>>
  TaylorSeries(U value) : TaylorSeries(T(value), 0) {}

  // Constructor initializes all coefficients to zero
  explicit TaylorSeries(const T &constant, int degree_in = 0)
      : degree(degree_in), coefficients(degree_in + 1, T(0)) {
    coefficients[0] = constant;
  }

  TaylorSeries()
      : TaylorSeries(T(0), 0) {
  }  // Default constructor delegates to existing constructor

  // Access operators
  T &operator[](int idx) { return coefficients[idx]; }
  const T &operator[](int idx) const { return coefficients[idx]; }

  // Get the degree of the Taylor series
  int getDegree() const { return degree; }

  // Basic arithmetic operators
  TaylorSeries operator+(const TaylorSeries &other) const {
    int max_degree = std::max(degree, other.degree);
    TaylorSeries result(T(0), max_degree);
    for (int i = 0; i <= max_degree; ++i) {
      result[i] = (i <= degree ? coefficients[i] : T(0)) +
                  (i <= other.degree ? other[i] : T(0));
    }
    return result;
  }

  TaylorSeries operator-(const TaylorSeries &other) const {
    int max_degree = std::max(degree, other.degree);
    TaylorSeries result(T(0), max_degree);
    for (int i = 0; i <= max_degree; ++i) {
      result[i] = (i <= degree ? coefficients[i] : T(0)) -
                  (i <= other.degree ? other[i] : T(0));
    }
    return result;
  }

  TaylorSeries operator*(const TaylorSeries &other) const {
    int result_degree = degree + other.degree;
    TaylorSeries result(T(0), result_degree);
    for (int n = 0; n <= result_degree; ++n) {
      for (int k = 0; k <= n; ++k) {
        if (k <= degree && (n - k) <= other.degree) {
          result[n] += coefficients[k] * other[n - k];
        }
      }
    }
    return result;
  }

  TaylorSeries operator/(const TaylorSeries &other) const {
    if (std::abs(other[0]) < epsilon) {
      throw std::runtime_error("Division by near-zero in Taylor series");
    }

    int result_degree = degree;
    TaylorSeries result(T(0), result_degree);
    result[0] = coefficients[0] / other[0];

    for (int n = 1; n <= result_degree; ++n) {
      T sum = coefficients[n];
      for (int k = 1; k <= n; ++k) {
        if (k <= other.degree) {
          sum -= other[k] * result[n - k];
        }
      }
      result[n] = sum / other[0];
    }
    return result;
  }

  // Scalar multiplication
  TaylorSeries operator*(const T &scalar) const {
    TaylorSeries result(T(0), degree);
    for (int i = 0; i <= degree; ++i) {
      result[i] = coefficients[i] * scalar;
    }
    return result;
  }

  // Scalar division
  TaylorSeries operator/(const T &scalar) const {
    if (std::abs(scalar) < epsilon) {
      throw std::runtime_error("Division by near-zero scalar in Taylor series");
    }
    TaylorSeries result(T(0), degree);
    for (int i = 0; i <= degree; ++i) {
      result[i] = coefficients[i] / scalar;
    }
    return result;
  }

  TaylorSeries &operator*=(const T &scalar) {
    for (int i = 0; i <= degree; ++i) {
      coefficients[i] *= scalar;
    }
    return *this;
  }

  TaylorSeries &operator/=(const T &scalar) {
    if (std::abs(scalar) < epsilon) {
      throw std::runtime_error("Division by near-zero scalar in Taylor series");
    }
    for (int i = 0; i <= degree; ++i) {
      coefficients[i] /= scalar;
    }
    return *this;
  }

  // Compound assignment operators
  TaylorSeries &operator+=(const TaylorSeries &other) {
    *this = *this + other;
    return *this;
  }

  TaylorSeries &operator-=(const TaylorSeries &other) {
    *this = *this - other;
    return *this;
  }

  // Evaluate series at a point
  // Evaluate series at a point x
  T evaluate(T x_value) const {
    T x0 = coefficients[0];  // Center of the series
    T h = x_value - x0;      // Deviation from the center
    T result = coefficients[degree];
    for (int i = degree - 1; i >= 0; --i) {
      result = result * h + coefficients[i];
    }
    return result;
  }

  // Get derivative
  TaylorSeries derivative() const {
    if (degree == 0) {
      throw std::runtime_error(
          "Cannot take derivative of degree 0 Taylor series");
    }
    TaylorSeries result(T(0), degree - 1);
    for (int i = 0; i < degree; ++i) {
      result[i] = coefficients[i + 1] * T(i + 1);
    }
    return result;
  }

  // Friend functions for commutative operations
  friend TaylorSeries operator*(T scalar, const TaylorSeries &ts) {
    return ts * scalar;
  }

  // Stream output
  friend std::ostream &operator<<(std::ostream &os, const TaylorSeries &ts) {
    os << ts[0];
    for (int i = 1; i <= ts.degree; ++i) {
      if (ts[i] != T(0)) {
        os << " + " << ts[i] << "x^" << i;
      }
    }
    return os;
  }

  // Unary minus operator
  TaylorSeries operator-() const {
    TaylorSeries result(T(0), degree);
    for (int i = 0; i <= degree; ++i) {
      result[i] = -coefficients[i];
    }
    return result;
  }

  // Updated transcendental functions using recursive formulas
  static TaylorSeries exp(const TaylorSeries &x) {
    TaylorSeries result(std::exp(x[0]), x.degree);
    for (int n = 1; n <= x.degree; ++n) {
      T sum = T(0);
      for (int k = 1; k <= n; ++k) {
        sum += T(k) * x[k] * result[n - k];
      }
      result[n] = sum / T(n);
    }
    return result;
  }

  static TaylorSeries log(const TaylorSeries &x) {
    if (x[0] <= T(0)) {
      throw std::runtime_error("Log of non-positive number");
    }

    TaylorSeries result(std::log(x[0]), x.degree);

    for (int n = 1; n <= x.degree; ++n) {
      T sum = x[n];
      for (int k = 1; k <= n - 1; ++k) {
        sum -= (T(k) * x[n - k] * result[k]) / T(n);
      }
      result[n] = sum / x[0];
    }
    return result;
  }

  static void sincos(const TaylorSeries &x, TaylorSeries &s, TaylorSeries &c) {
    s = TaylorSeries(std::sin(x[0]), x.degree);
    c = TaylorSeries(std::cos(x[0]), x.degree);
    for (int n = 1; n <= x.degree; ++n) {
      T sum_s = T(0);
      T sum_c = T(0);
      for (int k = 1; k <= n; ++k) {
        sum_s += T(k) * x[k] * c[n - k];
        sum_c -= T(k) * x[k] * s[n - k];
      }
      s[n] = sum_s / T(n);
      c[n] = sum_c / T(n);
    }
  }

  static TaylorSeries sin(const TaylorSeries &x) {
    TaylorSeries s(T(0), x.degree);
    TaylorSeries c(T(0), x.degree);
    sincos(x, s, c);
    return s;
  }

  static TaylorSeries cos(const TaylorSeries &x) {
    TaylorSeries s(T(0), x.degree);
    TaylorSeries c(T(0), x.degree);
    sincos(x, s, c);
    return c;
  }

  static TaylorSeries sqrt(const TaylorSeries &x) {
    if (x[0] <= T(0)) {
      throw std::runtime_error("Sqrt of non-positive number");
    }

    TaylorSeries result(std::sqrt(x[0]), x.degree);

    for (int n = 1; n <= x.degree; ++n) {
      T sum = T(0);
      for (int k = 1; k <= n - 1; ++k) {
        sum += result[k] * result[n - k];
      }
      result[n] = (x[n] - sum / T(2)) / (T(2) * result[0]);
    }
    return result;
  }
  template <typename S>
  static TaylorSeries pow(const TaylorSeries &x, S exponent) {
    // Using the identity pow(x, a) = exp(a * log(x)) for non-integer exponents
    if (std::is_floating_point<S>::value || exponent < 0) {
      return exp(log(x) * exponent);
    }

    // For non-negative integer exponents, use repeated squaring
    if (exponent == 0) {
      return TaylorSeries(T(1), x.degree);
    }
    if (exponent == 1) {
      return x;
    }

    // Handle even vs odd exponents
    TaylorSeries half = pow(x, exponent / 2);
    TaylorSeries result = half * half;
    // For odd exponents, multiply by x one additional time
    if (exponent % 2 == 1) {
      result = result * x;
    }  // Use bitwise AND to check if odd
    return result;
  }

  static TaylorSeries tan(const TaylorSeries &x) { return sin(x) / cos(x); }

  TaylorSeries &operator=(const TaylorSeries &other) {
    std::cout << "Copy assignment operator called" << std::endl;
    std::cout << "this: " << this << std::endl;
    std::cout << "other: " << &other << std::endl;
    if (this != &other) {
      degree = other.degree;
      coefficients = other.coefficients;
    }
    return *this;
  }
};

// Global overloads for transcendental functions
template <typename T>
TaylorSeries<T> sin(const TaylorSeries<T> &x) {
  return TaylorSeries<T>::sin(x);
}

template <typename T>
TaylorSeries<T> cos(const TaylorSeries<T> &x) {
  return TaylorSeries<T>::cos(x);
}

template <typename T>
TaylorSeries<T> exp(const TaylorSeries<T> &x) {
  return TaylorSeries<T>::exp(x);
}

template <typename T>
TaylorSeries<T> log(const TaylorSeries<T> &x) {
  return TaylorSeries<T>::log(x);
}

template <typename T>
TaylorSeries<T> tan(const TaylorSeries<T> &x) {
  return TaylorSeries<T>::tan(x);
}

template <typename T>
TaylorSeries<T> sqrt(const TaylorSeries<T> &x) {
  return TaylorSeries<T>::sqrt(x);
}

template <typename T, typename S>
TaylorSeries<T> pow(const TaylorSeries<T> &x, S exponent) {
  return TaylorSeries<T>::pow(x, exponent);
}

template <typename T>
std::ostream &operator<<(std::ostream &os,
                         const std::vector<TaylorSeries<T>> &v) {
  os << "[";
  for (int i = 0; i < v.size(); ++i) {
    os << v[i];
    if (i < v.size() - 1) {
      os << ",\n ";
    }
  }
  os << "]";
  return os;
}

template <typename ODESystemType, typename T>
std::vector<TaylorSeries<T>> computeODECoefficients(const std::vector<T> &X,
                                                    const ODESystemType &O,
                                                    int degree) {
  int n = X.size();
  std::vector<TaylorSeries<T>> coefficients;
  coefficients.reserve(X.size());

  // Initialize each TaylorSeries with degree + 1 terms
  // (degree terms we want plus one for intermediate calculations)
  for (int i = 0; i < X.size(); i++) {
    TaylorSeries<T> ts(X[i], degree + 1);
    ts[0] = X[i];  // Set constant term to initial value
    coefficients.push_back(ts);
  }

  auto Y = coefficients;
  for (int i = 1; i <= degree; i++) {
    O(coefficients, Y);
    for (int j = 0; j < n; j++) {
      coefficients[j][i] = Y[j][i - 1] / T(i);
    }
  }

  return coefficients;
}

template <typename T>
const T TaylorSeries<T>::epsilon = std::numeric_limits<T>::epsilon();

================
File: project/HC-MC/include/HC-MC.hpp
================
#pragma once

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Weverything"
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wall"
#pragma GCC diagnostic ignored "-Wextra"
#pragma GCC diagnostic ignored "-Wold-style-cast"
#pragma GCC diagnostic ignored "-Wsign-conversion"
#pragma GCC diagnostic ignored "-Wundef"
#pragma GCC diagnostic ignored "-Wuseless-cast"
#pragma GCC diagnostic ignored "-Wunused-parameter"

// Add more GCC-specific warnings you want to ignore here
#endif

#include <Eigen/Dense>
#include <cppad/cppad.hpp>
#include <cppad/example/cppad_eigen.hpp>  // Add this line

#ifdef __clang__
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#endif

#include <iomanip>
#include <iostream>
#include <optional>
#include <random>
#include <string>

#include "types.hpp"

// Configuration and result structures
struct SolveOptions {
  bool debug = false;
  double tolerance = 1e-10;
  int maxIterations = 100;
  int maxSteps = 1000;
  double initialStepSize = 0.001;
  bool verifyDerivatives = false;
};

struct SolveResult {
  ADVector solution;
  double residualNorm;
  int iterations;
  bool success;
  std::string message;
};

inline Eigen::VectorXd toDoubleVector(const ADVector& ad_vec) {
  Eigen::VectorXd vec(ad_vec.size());
  for (auto i = 0; i < ad_vec.size(); ++i) {
    vec(i) = CppAD::Value(ad_vec(i));
  }
  return vec;
}

namespace detail {
// Helper function to convert any type to double
template <typename T>
double toDouble(const T& x) {
  if constexpr (std::is_same_v<T, ADDouble>) {
    return CppAD::Value(x);
  } else {
    return x;
  }
}

// Random vector generator in [0,2]
template <typename T>
Vector<T> randomVector(int size) {
  static std::random_device rd;
  static std::mt19937 gen(rd());
  static std::uniform_real_distribution<double> dis(-1.0, 1.0);

  Vector<T> result(size);
  for (auto i = 0; i < size; ++i) {
    result(i) = T(dis(gen)) + T(1.0);
  }
  return result;
}

// Helper to evaluate vector function and get sizes
template <typename Func>
std::pair<int, int> getFunctionDimensions(const Func& F,
                                          const ADVector& x_test) {
  // Use the provided test vector to evaluate F
  auto y = F(x_test);
  return {x_test.size(), y.size()};
}

// Compute finite difference Jacobian for verification
template <typename F>
Matrix<double> finiteDiffJacobian(const F& func, const ADVector& x,
                                  double eps = 1e-8) {
  auto n = x.size();
  ADVector x_plus = x;
  auto f0 = func(x);
  auto m = f0.size();
  Matrix<double> jac(m, n);

  for (int j = 0; j < n; ++j) {
    x_plus = x;
    x_plus(j) += eps;
    auto f1 = func(x_plus);

    for (int i = 0; i < m; ++i) {
      jac(i, j) = (toDouble(f1(i)) - toDouble(f0(i))) / eps;
    }
  }
  return jac;
}

// Compare Jacobians with detailed output
inline bool compareJacobians(const Matrix<double>& J1, const Matrix<double>& J2,
                             const std::string& context, double tol = 1e-6) {
  double max_diff = 0.0;
  int max_i = 0;
  int max_j = 0;

  for (int i = 0; i < J1.rows(); ++i) {
    for (int j = 0; j < J1.cols(); ++j) {
      const double diff = std::abs(J1(i, j) - J2(i, j));
      if (diff > max_diff) {
        max_diff = diff;
        max_i = i;
        max_j = j;
      }
      if (diff > tol) {
        std::cout << context << ": Large difference at (" << i << "," << j
                  << "):\n"
                  << "AD: " << J1(i, j) << "\n"
                  << "FD: " << J2(i, j) << "\n"
                  << "Diff: " << diff << "\n";
        return false;
      }
    }
  }

  if (max_diff > 0) {
    std::cout << context << ": Maximum difference: " << max_diff << " at ("
              << max_i << "," << max_j << ")\n";
  }
  return true;
}
}  // namespace detail

template <typename FuncF, typename FuncG>
class HFunction {
 public:
  HFunction(const FuncF& F_in, const FuncG& G_in) : F(F_in), G(G_in) {}

  template <typename T>
  Vector<T> operator()(const Vector<T>& X, const T& t) const {
    auto f_val = F(X);
    auto g_val = G(X);
    return (T(1.0) - t) * g_val + t * f_val;
  }

  template <typename T>
  [[nodiscard]] Vector<T> dH_dt(const Vector<T>& X) const {
    return F(X) - G(X);
  }

 private:
  const FuncF& F;
  const FuncG& G;
};

template <typename FuncF, typename FuncG>
class PathTracker {
 public:
  PathTracker(const FuncF& f, const FuncG& g, const SolveOptions& options_pack)
      : F(f), G(g), H_func(F, G), options(options_pack) {}

  std::optional<SolveResult> track(const ADVector& X_in,
                                   const ADDouble& t_start,
                                   const ADDouble& t_end,
                                   const ADDouble& dt_init) {
    ADVector X = X_in;
    ADDouble t = t_start;
    ADDouble dt = dt_init;
    const double min_dt = detail::toDouble(dt_init) * 1e-8;  // TODO (orebas)
                                                             // magic number
    int total_iterations = 0;

    while (detail::toDouble(t) < detail::toDouble(t_end) &&
           total_iterations < options.maxSteps) {
      // Adjust step size if we're close to the end
      ADDouble dt_current = dt;
      if (detail::toDouble(t + dt) > detail::toDouble(t_end)) {
        dt_current = t_end - t;
      }

      const ADDouble t_new = t + dt_current;
      // Predictor step: Compute dX/dt
      const ADVector H_t = H_func.dH_dt(X);
      const Eigen::MatrixXd JH = computeJacobian(X, t);

      // Convert H_t to Eigen::VectorXd
      const Eigen::VectorXd H_t_double = toDoubleVector(H_t);

      // Solve for dX_dt
      const Eigen::VectorXd dX_dt = -JH.fullPivLu().solve(H_t_double);

      // Predictor: X_pred = X + dt_current * dX_dt
      const ADVector X_pred = X + (dt_current * dX_dt).cast<ADDouble>();

      // Corrector step: Refine X_pred at t_new
      auto X_corrected_opt = correctPrediction(X_pred, t_new);
      if (!X_corrected_opt.has_value()) {
        // Reduce step size and retry
        dt *= 0.5;
        if (detail::toDouble(dt) < min_dt) {
          if (options.debug) {
            std::cerr << "Step size too small. Terminating.\n";
          }
          break;
        }
        continue;
      }

      // Update X and t
      X = X_corrected_opt.value();
      t = t_new;
      total_iterations++;

      // Increase step size for next iteration
      dt = std::min(dt * 1.2, ADDouble(options.initialStepSize));

      if (options.debug) {
        std::cout << "Step " << total_iterations << ": t = " << t
                  << ", Residual norm = "
                  << detail::toDouble(H_func(X, t).norm()) << "\n";
      }
    }

    // Check if we reached the end
    if (detail::toDouble(t) < detail::toDouble(t_end)) {
      return std::nullopt;
    }

    SolveResult result;
    result.solution = X;
    result.residualNorm = detail::toDouble(F(X).norm());
    result.iterations = total_iterations;
    result.success = true;
    result.message = "Solution found";

    return result;
  }

 private:
  const FuncF& F;
  const FuncG& G;
  HFunction<FuncF, FuncG> H_func;
  SolveOptions options;

  Eigen::MatrixXd computeJacobian(const ADVector& X, const ADDouble& t) {
    using namespace CppAD;
    const long n = X.size();

    ADVector X_ad = X;  // Eigen::Matrix<ADDouble>

    // Declare independent variables
    Independent(X_ad);

    const ADVector H_X = H_func(X_ad, t);

    // Create the function object
    ADFun<double> func(X_ad, H_X);

    // Evaluate Jacobian at the current point
    std::vector<double> x_vec(n);
    for (long i = 0; i < n; ++i) {
      x_vec[i] = Value(X[i]);  // Use CppAD::Value to extract double
    }

    std::vector<double> jac_vec = func.Jacobian(x_vec);

    // Fill the EigenMatrix with the Jacobian values
    Eigen::MatrixXd jac(H_X.size(), n);
    for (long i = 0; i < H_X.size(); ++i) {
      for (long j = 0; j < n; ++j) {
        jac(i, j) = jac_vec[i * n + j];
      }
    }

    // Optional: Verify derivatives
    if (options.verifyDerivatives) {
      // Create a lambda that captures the current t value
      auto H_at_t = [this, t](const ADVector& X_) {
        return this->H_func(X_, t);
      };

      auto fd_jac = detail::finiteDiffJacobian(H_at_t, X);

      // Convert AD Jacobian to double for comparison
      const Eigen::MatrixXd jac_double = jac;

      std::stringstream context;
      context << "Jacobian verification at t=" << Value(t);
      detail::compareJacobians(jac_double, fd_jac, context.str());
    }

    return jac;
  }
  std::optional<ADVector> correctPrediction(const ADVector& X_pred,
                                            const ADDouble& t_new) {
    ADVector X = X_pred;
    for (int iter = 0; iter < options.maxIterations; ++iter) {
      const ADVector H_X = H_func(X, t_new);
      const double residual = detail::toDouble(H_X.norm());

      if (residual < options.tolerance) {
        return X;
      }

      // Compute Jacobian
      const Eigen::MatrixXd JH = computeJacobian(X, t_new);

      // Convert H_X to Eigen::VectorXd
      const Eigen::VectorXd H_X_double = toDoubleVector(H_X);

      // Solve for update
      const Eigen::VectorXd delta_X = -JH.fullPivLu().solve(H_X_double);

      // Update X
      X = X + delta_X.cast<ADDouble>();

      if (options.debug) {
        std::cout << "Corrector Iter " << iter << ": Residual = " << residual
                  << "\n";
      }

      if (delta_X.norm() < options.tolerance) {
        return X;
      }
    }

    // Did not converge
    return std::nullopt;
  }
};
// Main solve function
template <typename Func>
std::optional<SolveResult> solve(const Func& F,
                                 int input_dim,  // New parameter
                                 const SolveOptions& options = SolveOptions{}) {
  // Generate random starting point with correct dimension
  const ADVector X0 = detail::randomVector<ADDouble>(input_dim);

  // Get output dimension
  auto [n_in, n_out] = detail::getFunctionDimensions(F, X0);

  // Verify dimensions match
  if (n_in != input_dim) {
    throw std::invalid_argument("Function input dimension mismatch");
  }

  // Create G(x) = F(x) - F(X0)
  auto F_X0 = F(X0);
  auto G = [&F, &F_X0](const ADVector& x) -> ADVector { return F(x) - F_X0; };

  // Create the path tracker
  PathTracker<Func, decltype(G)> tracker(F, G, options);

  // Track from t=0 (G) to t=1 (F)
  return tracker.track(X0, ADDouble(0.0), ADDouble(1.0),
                       ADDouble(options.initialStepSize));
}

// Overload without explicit dimension - try to deduce from a test evaluation
/*template <typename Func>
std::optional<SolveResult> solve(const Func& F,
                                 const SolveOptions& options = SolveOptions{}) {
  // Try with dimension 1 first
  try {
    const ADVector x_test = detail::randomVector<ADDouble>(1);
    auto y = F(x_test);
    return solve(F, 1, options);
  } catch (...) {
    // Try with dimension 2 if that fails
    try {
      const ADVector x_test = detail::randomVector<ADDouble>(2);
      auto y = F(x_test);
      return solve(F, 2, options);
    } catch (...) {
      // If both fail, require explicit dimension
      throw std::invalid_argument(
          "Could not automatically determine function dimension. "
          "Please provide input dimension explicitly using solve(F, dimension, "
          "options).");
    }
  }
}*/

template <typename Func>
std::optional<SolveResult> solve_newton(
    const Func& F, int input_dim,
    const SolveOptions& options = SolveOptions{}) {
  // Generate random starting point with correct dimension
  const ADVector X0 = detail::randomVector<ADDouble>(input_dim);

  // Get output dimension
  auto [n_in, n_out] = detail::getFunctionDimensions(F, X0);

  // Verify dimensions match
  if (n_in != input_dim) {
    throw std::invalid_argument("Function input dimension mismatch");
  }

  ADVector X = X0;
  int iterations = 0;

  while (iterations < options.maxIterations) {
    // Evaluate function at current point
    const ADVector F_X = F(X);
    const double residual_norm = detail::toDouble(F_X.norm());

    if (residual_norm < options.tolerance) {
      SolveResult result;
      result.solution = X;
      result.residualNorm = residual_norm;
      result.iterations = iterations;
      result.success = true;
      result.message = "Converged successfully";
      return result;
    }

    // Compute Jacobian using CppAD
    using namespace CppAD;
    const long n = X.size();

    ADVector X_ad = X;
    Independent(X_ad);
    const ADVector F_X_ad = F(X_ad);
    ADFun<double> func(X_ad, F_X_ad);

    // Convert current point to std::vector<double>
    std::vector<double> x_vec(n);
    for (long i = 0; i < n; ++i) {
      x_vec[i] = Value(X[i]);
    }

    // Evaluate Jacobian
    std::vector<double> jac_vec = func.Jacobian(x_vec);

    // Convert Jacobian to Eigen matrix
    Eigen::MatrixXd J(F_X.size(), n);
    for (long i = 0; i < F_X.size(); ++i) {
      for (long j = 0; j < n; ++j) {
        J(i, j) = jac_vec[i * n + j];
      }
    }

    // Optional derivative verification
    if (options.verifyDerivatives) {
      auto fd_jac = detail::finiteDiffJacobian(F, X);
      std::stringstream context;
      context << "Newton iteration " << iterations;
      detail::compareJacobians(J, fd_jac, context.str());
    }

    // Solve linear system for Newton step
    const Eigen::VectorXd F_X_double = toDoubleVector(F_X);
    const Eigen::VectorXd delta = -J.fullPivLu().solve(F_X_double);

    // Update X
    X = X + delta.cast<ADDouble>();

    if (options.debug) {
      std::cout << "Newton iteration " << iterations
                << ": Residual = " << residual_norm << "\n";
    }

    // Check if step size is small enough to declare convergence
    if (delta.norm() < options.tolerance) {
      SolveResult result;
      result.solution = X;
      result.residualNorm = residual_norm;
      result.iterations = iterations;
      result.success = true;
      result.message = "Converged via small step size";
      return result;
    }

    ++iterations;
  }

  // Failed to converge
  SolveResult result;
  result.solution = X;
  result.residualNorm = detail::toDouble(F(X).norm());
  result.iterations = iterations;
  result.success = false;
  result.message = "Failed to converge within maximum iterations";
  return result;
}

// Overload without explicit dimension - try to deduce from a test evaluation
template <typename Func>
std::optional<SolveResult> solve_newton(
    const Func& F, const SolveOptions& options = SolveOptions{}) {
  // Try with dimension 1 first
  try {
    const ADVector x_test = detail::randomVector<ADDouble>(1);
    auto y = F(x_test);
    return solve_newton(F, 1, options);
  } catch (...) {
    // Try with dimension 2 if that fails
    try {
      const ADVector x_test = detail::randomVector<ADDouble>(2);
      auto y = F(x_test);
      return solve_newton(F, 2, options);
    } catch (...) {
      // If both fail, require explicit dimension
      throw std::invalid_argument(
          "Could not automatically determine function dimension. "
          "Please provide input dimension explicitly using solve_newton(F, "
          "dimension, options).");
    }
  }
}

================
File: project/HC-MC/include/integration_interface.hpp
================
#pragma once

#include <boost/numeric/odeint.hpp>

// Function to integrate and observe
template <typename T, typename System>
std::vector<observable_vector<T>> integrate_and_observe(
    const System& system, const std::vector<T>& time_values) {
  using namespace boost::numeric::odeint;

  state_vector<T> state = system.getInitialState();
  std::vector<observable_vector<T>> observables;

  auto observer = [&](const state_vector<T>& x, const T& /* t */) {
    observable_vector<T> y;
    system.observe(x, y);
    observables.push_back(y);
  };

  typedef runge_kutta4<state_vector<T>, T, state_vector<T>, T> stepper_type;
  integrate_times(stepper_type(), system, state, time_values.begin(),
                  time_values.end(), T(0.01), observer);
  return observables;
}

================
File: project/HC-MC/include/observability.hpp
================
// In a new header, let's say observability.hpp:
// TODO:  The below is totally untested.

#pragma once

#include <Eigen/Dense>
#include <cppad/cppad.hpp>

#include "hbtaylor.hpp"
#include "types.hpp"

template <typename T>
struct ObservabilityResult {
  // Taylor series for state and observed variables
  std::vector<TaylorSeries<T>> state_series;
  std::vector<TaylorSeries<T>> obs_series;

  // Jacobians of Taylor coefficients with respect to initial conditions and
  // parameters Each matrix has rows = (num_observed_vars * num_taylor_coeffs)
  // and cols = (num_state_vars + num_params)
  Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> observability_matrix;
};

template <typename ODESystem>
ObservabilityResult<typename ODESystem::RealType> computeObservabilityMatrix(
    const ODESystem& system, const typename ODESystem::RealType& t0,
    int degree) {
  using T = typename ODESystem::RealType;

  // Get dimensions
  const size_t num_states = system.getStateSize();
  const size_t num_params = system.getParameterSize();
  const size_t total_inputs = num_states + num_params;

  // Create vector of independent variables (initial states and parameters)
  std::vector<ADDouble> X_ad;
  X_ad.reserve(total_inputs);

  // Add initial states
  const auto& init_state = system.getInitialState();
  for (const auto& x : init_state) {
    X_ad.push_back(ADDouble(x));
  }

  // Add parameters
  const auto& params = system.getParameters();
  for (const auto& p : params) {
    X_ad.push_back(ADDouble(p));
  }

  // Start recording
  CppAD::Independent(X_ad);

  // Create AD version of system with these parameters
  auto wrapped_system = [&system, &t0](
                            const std::vector<TaylorSeries<ADDouble>>& series,
                            std::vector<TaylorSeries<ADDouble>>& result) {
    // Extract parameters from the end of X_ad
    std::vector<TaylorSeries<ADDouble>> p_series;
    p_series.reserve(series.size());
    for (size_t i = 0; i < series.size(); ++i) {
      p_series.emplace_back(ADDouble(0), series[0].getDegree());
    }

    system.state_equations(series, result, p_series, ADDouble(t0));
  };

  // Compute Taylor series using AD types
  std::vector<ADDouble> init_state_ad(X_ad.begin(), X_ad.begin() + num_states);
  auto state_series_ad =
      computeODECoefficients(init_state_ad, wrapped_system, degree);

  // Compute observable series
  std::vector<TaylorSeries<ADDouble>> obs_series_ad;
  system.observe(state_series_ad, obs_series_ad);

  // Create dependent variables vector (flattened Taylor coefficients of
  // observables)
  std::vector<ADDouble> Y;
  const size_t num_obs = obs_series_ad.size();
  Y.reserve(num_obs * (degree + 1));

  for (const auto& series : obs_series_ad) {
    for (int i = 0; i <= degree; ++i) {
      Y.push_back(series[i]);
    }
  }

  // Create ADFun object
  CppAD::ADFun<T> func(X_ad, Y);

  // Compute Jacobian
  std::vector<T> x_vec(total_inputs);
  for (size_t i = 0; i < num_states; ++i) {
    x_vec[i] = init_state[i];
  }
  for (size_t i = 0; i < num_params; ++i) {
    x_vec[num_states + i] = params[i];
  }

  std::vector<T> jac = func.Jacobian(x_vec);

  // Convert to Eigen matrix
  const size_t num_rows = Y.size();
  Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> obs_matrix(num_rows,
                                                              total_inputs);
  for (size_t i = 0; i < num_rows; ++i) {
    for (size_t j = 0; j < total_inputs; ++j) {
      obs_matrix(i, j) = jac[i * total_inputs + j];
    }
  }

  // Convert AD series back to regular series
  std::vector<TaylorSeries<T>> state_series;
  std::vector<TaylorSeries<T>> obs_series;

  for (const auto& s : state_series_ad) {
    TaylorSeries<T> ts(T(0), degree);
    for (int i = 0; i <= degree; ++i) {
      ts[i] = CppAD::Value(s[i]);
    }
    state_series.push_back(ts);
  }

  for (const auto& s : obs_series_ad) {
    TaylorSeries<T> ts(T(0), degree);
    for (int i = 0; i <= degree; ++i) {
      ts[i] = CppAD::Value(s[i]);
    }
    obs_series.push_back(ts);
  }

  return {state_series, obs_series, obs_matrix};
}

struct DerivativeLevels {
  std::unordered_map<size_t, int>
      derivative_levels;  // observable index -> number of derivatives needed
  std::vector<size_t>
      unidentifiable_params;  // indices of unidentifiable parameters
  std::vector<double>
      unidentifiable_values;  // fixed values for unidentifiable parameters
};

class ObservabilityAnalyzer {
 public:
  ObservabilityAnalyzer(double rtol = 1e-12, double atol = 1e-12)
      : rtol_(rtol), atol_(atol) {}

  DerivativeLevels analyze(const Eigen::MatrixXd& full_observability_matrix,
                           size_t num_observables, size_t max_derivatives,
                           const std::vector<std::string>& param_names =
                               std::vector<std::string>()) {
    DerivativeLevels result;

    // Copy the original matrix as we'll be modifying it
    Eigen::MatrixXd working_matrix = full_observability_matrix;

    // Get initial rank
    int max_rank = computeRank(working_matrix);

    // Find unidentifiable parameters
    auto [unident_params, unident_values] =
        findUnidentifiableParameters(working_matrix);
    result.unidentifiable_params = unident_params;
    result.unidentifiable_values = unident_values;

    if (!param_names.empty()) {
      std::cout << "Unidentifiable parameters:\n";
      for (size_t i = 0; i < unident_params.size(); ++i) {
        std::cout << param_names[unident_params[i]] << " = "
                  << unident_values[i] << "\n";
      }
    }

    // Remove columns corresponding to unidentifiable parameters
    removeUnidentifiableColumns(working_matrix, unident_params);

    // For each observable, find minimum derivatives needed
    result.derivative_levels = findMinimumDerivatives(
        working_matrix, num_observables, max_derivatives, max_rank);

    return result;
  }

 private:
  double rtol_;
  double atol_;
  std::mt19937 rng_{std::random_device{}()};

  int computeRank(const Eigen::MatrixXd& matrix) {
    Eigen::JacobiSVD<Eigen::MatrixXd> svd(matrix);
    Eigen::VectorXd singular_values = svd.singularValues();

    double threshold = atol_ + rtol_ * singular_values(0);
    int rank = 0;
    for (int i = 0; i < singular_values.size(); ++i) {
      if (singular_values(i) > threshold) {
        rank++;
      }
    }
    return rank;
  }

  std::pair<std::vector<size_t>, std::vector<double>>
  findUnidentifiableParameters(const Eigen::MatrixXd& matrix) {
    // Compute nullspace
    Eigen::JacobiSVD<Eigen::MatrixXd> svd(matrix, Eigen::ComputeFullV);
    Eigen::MatrixXd V = svd.matrixV();
    Eigen::VectorXd singular_values = svd.singularValues();

    double threshold = atol_ + rtol_ * singular_values(0);

    // Find nullspace columns
    std::vector<size_t> unident_params;
    std::vector<double> unident_values;
    std::uniform_real_distribution<double> dist(
        0.1, 1.0);  // Random values between 0.1 and 1.0

    // Check each column of V corresponding to small singular values
    for (int i = 0; i < singular_values.size(); ++i) {
      if (singular_values(i) <= threshold) {
        // Get nullspace vector
        Eigen::VectorXd null_vector = V.col(i);

        // Find largest component
        int max_idx = 0;
        double max_val = std::abs(null_vector(0));
        for (int j = 1; j < null_vector.size(); ++j) {
          if (std::abs(null_vector(j)) > max_val) {
            max_val = std::abs(null_vector(j));
            max_idx = j;
          }
        }

        if (max_val > rtol_) {
          unident_params.push_back(max_idx);
          unident_values.push_back(dist(rng_));
        }
      }
    }

    return {unident_params, unident_values};
  }

  void removeUnidentifiableColumns(Eigen::MatrixXd& matrix,
                                   const std::vector<size_t>& unident_params) {
    if (unident_params.empty()) return;

    // Create mask of columns to keep
    std::vector<bool> keep_col(matrix.cols(), true);
    for (size_t idx : unident_params) {
      keep_col[idx] = false;
    }

    // Count remaining columns
    int new_cols = std::count(keep_col.begin(), keep_col.end(), true);

    // Create new matrix with remaining columns
    Eigen::MatrixXd new_matrix(matrix.rows(), new_cols);
    int col_idx = 0;
    for (int i = 0; i < matrix.cols(); ++i) {
      if (keep_col[i]) {
        new_matrix.col(col_idx++) = matrix.col(i);
      }
    }

    matrix = new_matrix;
  }

  std::unordered_map<size_t, int> findMinimumDerivatives(
      const Eigen::MatrixXd& matrix, size_t num_observables,
      size_t max_derivatives, int target_rank) {
    std::unordered_map<size_t, int> deriv_levels;
    for (size_t i = 0; i < num_observables; ++i) {
      deriv_levels[i] = max_derivatives;
    }

    bool keep_reducing = true;
    while (keep_reducing) {
      bool found_reduction = false;

      // Try reducing each observable's derivatives
      for (size_t obs_idx = 0; obs_idx < num_observables; ++obs_idx) {
        if (deriv_levels[obs_idx] == 0) continue;

        // Try reducing this observable's derivatives by 1
        deriv_levels[obs_idx]--;

        // Construct reduced matrix
        Eigen::MatrixXd reduced_matrix = constructReducedMatrix(
            matrix, deriv_levels, num_observables, max_derivatives);

        // Check if rank is maintained
        if (computeRank(reduced_matrix) < target_rank) {
          // Reduction not possible, restore previous value
          deriv_levels[obs_idx]++;
        } else {
          found_reduction = true;
        }
      }

      keep_reducing = found_reduction;
    }

    return deriv_levels;
  }

  Eigen::MatrixXd constructReducedMatrix(
      const Eigen::MatrixXd& full_matrix,
      const std::unordered_map<size_t, int>& deriv_levels,
      size_t num_observables, size_t max_derivatives) {
    // Count rows in reduced matrix
    int total_rows = 0;
    for (size_t obs = 0; obs < num_observables; ++obs) {
      total_rows += deriv_levels.at(obs) + 1;
    }

    // Create reduced matrix
    Eigen::MatrixXd reduced(total_rows, full_matrix.cols());

    int row = 0;
    for (size_t obs = 0; obs < num_observables; ++obs) {
      for (int deriv = 0; deriv <= deriv_levels.at(obs); ++deriv) {
        int full_row = obs + deriv * num_observables;
        reduced.row(row++) = full_matrix.row(full_row);
      }
    }

    return reduced;
  }
};

================
File: project/HC-MC/include/ODESystem.hpp
================
#pragma once

#include <algorithm>
#include <boost/numeric/odeint.hpp>
#include <functional>
#include <stdexcept>
#include <vector>

#include "hbtaylor.hpp"
#include "types.hpp"

// ODE system class
// Requirements:
//  - F and G should be templated functors, i.e. they should work with T or
//  TaylorSeries<T>.
//  - The user provides something like:
//    struct F {
//      template <typename RealType>
//      void operator()(const std::vector<RealType>& x,
//                      std::vector<RealType>& dxdt,
//                      const std::vector<RealType>& p,
//                      const RealType& t);
//    };
//    struct G {
//      template <typename RealType>
//      void operator()(const std::vector<RealType>& x,
//                      std::vector<RealType>& obs);
//    };
//
// This ensures we can handle both normal floats/doubles and TaylorSeries
// expansions.

template <typename T, template <typename> class StateFunctionTemplate,
          template <typename> class ObservationFunctionTemplate>
class ODESystem {
 public:
  using RealType = T;
  using StateType = std::vector<T>;
  using ParamType = std::vector<T>;
  using ObsType = std::vector<T>;

  // The state and observation functions are template templates
  // We instantiate them with T:
  StateFunctionTemplate<T> state_equations;
  ObservationFunctionTemplate<T> observation_function;

  ODESystem(const ParamType& params, const StateFunctionTemplate<T>& state_func,
            const ObservationFunctionTemplate<T>& obs_func)
      : state_equations(state_func),
        observation_function(obs_func),
        parameters(params),
        parameter_size(params.size()),
        state_size(0),
        observable_size(0) {}

  // Accessors
  const ParamType& getParameters() const { return parameters; }
  size_t getParameterSize() const { return parameter_size; }
  size_t getStateSize() const { return state_size; }
  size_t getObservableSize() const { return observable_size; }

  // Setters
  void setInitialState(const StateType& initial_state_param) {
    this->initial_state = initial_state_param;
    state_size = initial_state_param.size();
  }

  const StateType& getInitialState() const { return initial_state; }

  // Combine parameters and initial conditions into one vector
  std::vector<T> getFullParameterVector() const {
    std::vector<T> full(parameter_size + state_size);
    std::copy(parameters.begin(), parameters.end(), full.begin());
    std::copy(initial_state.begin(), initial_state.end(),
              full.begin() + parameter_size);
    return full;
  }

  // Set parameters and initial conditions from a single vector
  void setFullParameterVector(const std::vector<T>& full) {
    if (full.size() != parameter_size + state_size) {
      throw std::runtime_error(
          "Full vector size does not match parameter+state size.");
    }
    std::copy(full.begin(), full.begin() + parameter_size, parameters.begin());
    std::copy(full.begin() + parameter_size, full.end(), initial_state.begin());
  }

  // ODE function operator
  // For time stepping with fixed parameters
  void operator()(const StateType& x, StateType& dxdt, const T& t) const {
    state_equations(x, dxdt, parameters, t);
  }

  // ODE function operator if we provide parameters explicitly
  void operator()(const StateType& x, StateType& dxdt, const ParamType& p,
                  const T& t) const {
    state_equations(x, dxdt, p, t);
  }

  // Observation function
  void observe(const StateType& x, ObsType& y) const {
    observation_function(x, y);
    if (observable_size == 0) {
      observable_size = y.size();  // Set on first call
    }
  }

  // Shrinking the ODE system by fixing parameters:
  // This returns a new ODESystem with certain parameters fixed.
  // fixedIndices: which parameters to fix
  // fixedValues: values of those parameters
  // The resulting system will have fewer parameters.
  ODESystem<T, StateFunctionTemplate, ObservationFunctionTemplate>
  shrinkParameters(const std::vector<size_t>& fixedIndices,
                   const std::vector<T>& fixedValues) const {
    if (fixedIndices.size() != fixedValues.size()) {
      throw std::runtime_error(
          "Mismatched fixedIndices and fixedValues sizes.");
    }

    // Create a new parameter vector with those indices removed
    std::vector<bool> isFixed(parameter_size, false);
    for (auto idx : fixedIndices) {
      if (idx >= parameter_size) {
        throw std::runtime_error("Parameter index out of range");
      }
      isFixed[idx] = true;
    }

    ParamType newParams;
    newParams.reserve(parameter_size - fixedIndices.size());
    for (size_t i = 0; i < parameter_size; ++i) {
      if (!isFixed[i]) {
        newParams.push_back(parameters[i]);
      }
    }

    // Capture the fixed parameters in a wrapper for state_equations
    // We'll create a lambda that takes (x, dxdt, reducedParams, t),
    // reconstructs the full parameter set, and calls the original
    // state_equations.
    auto original_equations = state_equations;
    ParamType fixedParams = fixedValues;  // copy for lambda capture
    auto new_state_equations = [original_equations, isFixed, fixedParams](
                                   const std::vector<T>& x,
                                   std::vector<T>& dxdt,
                                   const std::vector<T>& reducedP, const T& t) {
      // Rebuild full parameter vector
      size_t reduced_idx = 0;
      std::vector<T> fullP;
      fullP.reserve(isFixed.size());
      for (size_t i = 0; i < isFixed.size(); ++i) {
        if (isFixed[i]) {
          fullP.push_back(fixedParams[std::distance(
              isFixed.begin(),
              std::find(isFixed.begin(), isFixed.end(), true))]);
        } else {
          fullP.push_back(reducedP[reduced_idx++]);
        }
      }
      original_equations(x, dxdt, fullP, t);
    };

    // Observation function does not change because it does not depend on
    // parameters explicitly (assuming linear in x).
    auto new_obs = observation_function;  // same observation function

    ODESystem<T, StateFunctionTemplate, ObservationFunctionTemplate>
        reducedSystem(newParams, new_state_equations, new_obs);
    reducedSystem.setInitialState(this->initial_state);
    return reducedSystem;
  }

  // Similarly, shrink initial conditions by fixing some of them:
  ODESystem<T, StateFunctionTemplate, ObservationFunctionTemplate>
  shrinkInitialConditions(const std::vector<size_t>& fixedStateIndices,
                          const std::vector<T>& fixedValues) const {
    if (fixedStateIndices.size() != fixedValues.size()) {
      throw std::runtime_error("Mismatched fixedStateIndices and fixedValues.");
    }

    std::vector<bool> isFixedState(state_size, false);
    for (auto idx : fixedStateIndices) {
      if (idx >= state_size) {
        throw std::runtime_error("State index out of range");
      }
      isFixedState[idx] = true;
    }

    // Create a reduced initial state
    StateType newInit;
    newInit.reserve(state_size - fixedStateIndices.size());
    for (size_t i = 0; i < state_size; ++i) {
      if (!isFixedState[i]) {
        newInit.push_back(initial_state[i]);
      }
    }

    // Create a wrapper around the state_equations that inserts the fixed state
    // variables
    auto original_equations = state_equations;
    StateType fixedStates = fixedValues;
    auto new_state_equations = [original_equations, isFixedState, fixedStates](
                                   const std::vector<T>& x,
                                   std::vector<T>& dxdt,
                                   const std::vector<T>& p, const T& t) {
      // Rebuild full state vector
      std::vector<T> fullX;
      fullX.reserve(isFixedState.size());
      size_t reduced_idx = 0;
      size_t fixed_count = 0;
      for (size_t i = 0; i < isFixedState.size(); ++i) {
        if (isFixedState[i]) {
          fullX.push_back(fixedStates[fixed_count++]);
        } else {
          fullX.push_back(x[reduced_idx++]);
        }
      }

      std::vector<T> fullDxdt(fullX.size(), T(0));
      original_equations(fullX, fullDxdt, p, t);

      // Now extract the reduced dxdt
      dxdt.resize(x.size());
      reduced_idx = 0;
      for (size_t i = 0; i < isFixedState.size(); ++i) {
        if (!isFixedState[i]) {
          dxdt[reduced_idx++] = fullDxdt[i];
        }
      }
    };

    auto new_obs = [this, isFixedState](const std::vector<T>& x,
                                        std::vector<T>& y) {
      // Rebuild full state vector for observation
      std::vector<T> fullX;
      fullX.reserve(isFixedState.size());
      size_t reduced_idx = 0;
      for (size_t i = 0; i < isFixedState.size(); ++i) {
        if (isFixedState[i]) {
          // For observation, use the fixed initial state value
          // (assuming it doesn't change - this might need refinement)
          fullX.push_back(
              T(0));  // or store the fixed states from initial condition?
        } else {
          fullX.push_back(x[reduced_idx++]);
        }
      }
      std::vector<T> fullObs;
      this->observation_function(fullX, fullObs);

      // The observation might still be full dimension since G is linear in x.
      // If G expects original dimension, we must return that dimension.
      // If we truly shrank the system dimension, G would need adjusting.
      // Here we assume G matches original dimension. If needed,
      // we could store a reduced G. For now, we just return fullObs.
      y = fullObs;
    };

    ODESystem<T, StateFunctionTemplate, ObservationFunctionTemplate>
        reducedSystem(this->parameters, new_state_equations, new_obs);
    reducedSystem.setInitialState(newInit);
    return reducedSystem;
  }

  /*
    // Compute Taylor series expansion of the state around time t0
    // The idea:
    //  X(t) = X(t0) + (t - t0)*X'(t0) + (t - t0)^2/2!*X''(t0) + ...
    // We use the provided TaylorSeries class to store coefficients.
    // This requires that state_equations can operate on TaylorSeries<T> as
    input. std::vector<TaylorSeries<T>> computeTaylorSeriesOfState(const T& t0,
                                                            int degree) const {
      // Initialize TaylorSeries for each state variable
      std::vector<TaylorSeries<T>> series;
      series.reserve(state_size);
      for (size_t i = 0; i < state_size; ++i) {
        TaylorSeries<T> ts(initial_state[i], degree);
        ts[0] = initial_state[i];  // constant term
        series.push_back(ts);
      }

      // We'll do a recursive approach:
      // For i=1 to degree:
      //   Evaluate F at t0 with the current expansions.
      //   The linear terms in t give first derivative, etc.
      //
      // However, a direct approach:
      // If we let the input be TaylorSeries(t0 + h), we can call F with x
      // represented as expansions. Then we solve for coefficients by matching
      // terms of equal powers of h.
      //
      // A simpler (though less general) approach:
      //   For the first derivative: dxdt at t0 is just F(X(t0), p, t0).
      //   For the second derivative: we differentiate again by applying chain
      //   rule, etc.
      // But we haven't implemented a general chain rule here. We assume that
      // `state_equations` can handle TaylorSeries to produce all higher
      // derivatives automatically.
      //
      // Let's represent time as a TaylorSeries around t0: T(t) = t0 + h, with h
      // as the variable. We'll create a TaylorSeries<T> for time: t_series = t0
    +
      // h where h is the expansion variable.
      TaylorSeries<T> t_series(t0, degree);
      // h = t - t0, so t_series[0] = t0, and t_series[1] = 1, and others 0
      // Actually, since evaluate methods rely on expansions:
      // Let's set up: t_series[0] = t0, t_series[1] = 1.0;
      t_series[0] = t0;
      if (degree > 0) {
        t_series[1] = T(1);
      }

      // At each step i, we will compute dx/dt = F(X, p, t_series)
      // X is currently known as a TaylorSeries expansion to order i-1.
      // We can call state_equations with these series. It should produce dxdt
    as
      // a series. Then we match coefficients to fill in series[*][i].

      // Convert parameters to TaylorSeries as well (constant expansions)
      std::vector<TaylorSeries<T>> p_series(parameters.size(),
                                            TaylorSeries<T>(T(0), degree));
      for (size_t i = 0; i < parameters.size(); ++i) {
        p_series[i][0] = parameters[i];  // parameter is constant w.r.t time
      }

      for (int i = 1; i <= degree; ++i) {
        // Prepare x_series for input
        std::vector<TaylorSeries<T>> x_series =
            series;  // copy current expansions
        std::vector<TaylorSeries<T>> dxdt_series(state_size,
                                                 TaylorSeries<T>(T(0), degree));

        // Call state_equations but templated on TaylorSeries<T>
        // We'll create a small adapter that calls the template:
        {
          // Wrap parameters in a lambda that uses TaylorSeries:
          auto eq = [this](const std::vector<TaylorSeries<T>>& x,
                           std::vector<TaylorSeries<T>>& dxdt,
                           const std::vector<TaylorSeries<T>>& p,
                           const TaylorSeries<T>& tt) {
            // Extract plain arrays for calling original functor:
            // Here we rely on the fact that `state_equations` is already
            // templated. state_equations(x, dxdt, p, t)
            this->state_equations(x, dxdt, p, tt);
          };

          eq(x_series, dxdt_series, p_series, t_series);
        }

        // Now, dxdt_series[j][n] corresponds to nth derivative terms. By
        // definition:
        //   series[j][i] = dxdt[j][i-1] / i   (to get ith coefficient)
        // Because coefficient for order i in Taylor series = f^(i)(t0)/i!
        // dxdt_series gives the derivative expansions. The linear term in
        // dxdt_series is dx/dt at t0, etc. We must ensure that we properly
        // extract the i-th coefficient from dxdt_series. dxdt_series[j][i-1]
        // should give us the i-th derivative * i!. But we've constructed
        // dxdt_series so that [k] is the k-th coefficient i.e.,
        // dxdt_series[j][i-1] is actually the (i-1)-th derivative / (i-1)! ?
    For
        // simplicity, assume dxdt_series is computed similarly so that:
        //   series[j][i] = dxdt_series[j][i-1] / i
        // This matches the pattern in the provided `computeODECoefficients`
        // snippet.

        for (size_t j = 0; j < state_size; ++j) {
          series[j][i] = dxdt_series[j][i - 1] / T(i);
        }
      }

      return series;
    }*/

  std::vector<TaylorSeries<T>> computeTaylorSeriesOfState(const T& t0,
                                                          int degree) const {
    // Create a wrapper that adapts our state_equations to the interface
    // expected by computeODECoefficients
    auto wrapped_system = [this, &t0](
                              const std::vector<TaylorSeries<T>>& series,
                              std::vector<TaylorSeries<T>>& result) {
      // Convert parameters to TaylorSeries (as constants)
      std::vector<TaylorSeries<T>> p_series;
      p_series.reserve(parameters.size());
      for (const auto& p : parameters) {
        p_series.emplace_back(p, series[0].getDegree());
      }
      // Call state_equations with the wrapped parameters
      StateFunctionTemplate<TaylorSeries<T>>()(series, result, p_series, t0);
    };

    return computeODECoefficients(this->initial_state, wrapped_system, degree);
  }

  // Compute Taylor series of the observables:
  std::vector<TaylorSeries<T>> computeTaylorSeriesOfObservables(
      const std::vector<TaylorSeries<T>>& x_series) const {
    // We assume G is linear, so G(X(t)) = A * X(t) for some matrix A.
    // If G is truly linear, applying it to a TaylorSeries vector is
    // straightforward: Just apply G to each coefficient independently.

    // We'll just call observation_function with the TaylorSeries expansions and
    // let it handle them. If G is linear: G(ax + b) = aG(x) + G(b), linear
    // means: G(x) = Mx for some matrix M. We'll call observation_function once
    // with TaylorSeries input.
    std::vector<TaylorSeries<T>> y_series(
        observable_size, TaylorSeries<T>(T(0), x_series[0].getDegree()));

    ObservationFunctionTemplate<TaylorSeries<T>>()(x_series, y_series);
    return y_series;
  }

 private:
  ParamType parameters;
  StateType initial_state;
  size_t parameter_size;
  size_t state_size;
  mutable size_t observable_size;
};

================
File: project/HC-MC/include/prob1.hpp
================
#pragma once

#include <vector>

#include "ODESystem.hpp"
#include "types.hpp"

// State equation template for Problem 1
template <typename T>
struct MyStateEquations {
  void operator()(const state_vector<T>& x, state_vector<T>& dxdt,
                  const parameter_vector<T>& p, const T& t) const {
    //   dxdt.resize(2);
    dxdt[0] = p[0] * x[0];
    dxdt[1] = p[1] * x[1];
  }
};

// Observation function template for Problem 1
template <typename T>
struct MyObservationFunction {
  void operator()(const state_vector<T>& x, observable_vector<T>& y) const {
    //    y.resize(2);
    y[0] = x[0];
    y[1] = x[1];
  }
};

// Problem-specific configuration
template <typename T>
struct SystemConfig {
  std::vector<T> time_values;
  std::vector<T> true_params;
  std::vector<T> true_initial_state;
};

// Helper functions for Problem 1
inline SystemConfig<double> create_system_config() {
  return {
      {0.0, 0.5, 1.0, 1.5, 2.0},  // time_values
      {1.3, 1.8},                 // true_params
      {1.0, 0.5}                  // true_initial_state
  };
}

// Create the true system with state equations and observation functions
template <typename T>
auto create_true_system(const SystemConfig<T>& config) {
  ODESystem<T, MyStateEquations, MyObservationFunction> system(
      config.true_params, MyStateEquations<T>{}, MyObservationFunction<T>{});
  system.setInitialState(config.true_initial_state);
  return system;
}

================
File: project/HC-MC/include/types.hpp
================
#pragma once

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Weverything"
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wall"
#pragma GCC diagnostic ignored "-Wextra"
#pragma GCC diagnostic ignored "-Wold-style-cast"
#pragma GCC diagnostic ignored "-Wsign-conversion"
#pragma GCC diagnostic ignored "-Wundef"
#pragma GCC diagnostic ignored "-Wuseless-cast"
#pragma GCC diagnostic ignored "-Wunused-parameter"

// Add more GCC-specific warnings you want to ignore here
#endif

#include <Eigen/Dense>
#include <cppad/cppad.hpp>
#include <cppad/example/cppad_eigen.hpp>  // Add this line

#ifdef __clang__
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#endif

template <typename T>
using Vector = Eigen::Matrix<T, Eigen::Dynamic, 1>;

// Define AD types as used in HC-MC.hpp
using ADDouble = CppAD::AD<double>;
using ADVector = Vector<ADDouble>;

// Template the state type and system for AD compatibility
template <typename T>
using state_vector = std::vector<T>;
template <typename T>
using parameter_vector = std::vector<T>;
template <typename T>
using observable_vector = std::vector<T>;

// Type aliases to improve readability
template <typename Base>
using AD = CppAD::AD<Base>;
using ADDouble = AD<double>;

template <typename T>
using Vector = Eigen::Matrix<T, Eigen::Dynamic, 1>;
template <typename T>
using Matrix = Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>;

using DoubleVector = Vector<double>;

// Helper type trait to get base type
template <typename T>
struct BaseType {
  using type = T;
};

template <typename Base>
struct BaseType<AD<Base>> {
  using type = Base;
};

================
File: project/HC-MC/tests/pt_tests.cpp
================
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include <doctest/doctest.h>

#include <Eigen/Dense>
#include <cmath>
#include <iostream>
#include <string>

#include "HC-MC.hpp"

// Helper function to print vectors nicely
void print_vector(const ADVector& v, const std::string& name) {
  std::cout << name << " = [";
  for (int i = 0; i < v.size(); ++i) {
    std::cout << std::setprecision(15) << CppAD::Value(v(i));
    if (i < v.size() - 1) {
      std::cout << ", ";
    }
  }
  std::cout << "]" << "\n";
}

TEST_CASE("Circle-Line Intersection") {
  auto F = [](const ADVector& X) {
    ADVector result(2);
    result(0) = X(0) * X(0) + X(1) * X(1) - 4.0;  // Circle of radius 2
    result(1) = X(0) + X(1) - 1.0;                // Line x + y = 1
    return result;
  };

  SolveOptions options;
  options.debug = true;
  options.tolerance = 1e-10;

  auto result = solve(F, 2, options);
  REQUIRE(result.has_value());

  const auto& solve_result = *result;
  REQUIRE(solve_result.success);
  REQUIRE(solve_result.residualNorm < 1e-8);

  // Verify the solution satisfies the system
  const auto& X = solve_result.solution;
  auto F_X = F(X);
  print_vector(X, "Solution");
  print_vector(F_X, "F(solution)");

  // Check both equations are satisfied
  REQUIRE(std::abs(CppAD::Value(F_X(0))) < 1e-8);  // Circle equation
  REQUIRE(std::abs(CppAD::Value(F_X(1))) < 1e-8);  // Line equation

  // Verify solution matches one of the two expected points
  double x = CppAD::Value(X(0));
  double y = CppAD::Value(X(1));
  bool matches_solution =
      (std::abs(x + y - 1.0) < 1e-8) &&        // Line equation
      (std::abs(x * x + y * y - 4.0) < 1e-8);  // Circle equation

  REQUIRE(matches_solution);
}

TEST_CASE("Parabola-Line Intersection") {
  auto F = [](const ADVector& X) {
    ADVector result(2);
    result(0) = X(0) * X(0) - X(1);  // Parabola y = x^2
    result(1) = X(1) - 4.0;          // Line y = 4
    return result;
  };

  SolveOptions options;
  options.debug = false;

  auto result = solve(F, 2);
  REQUIRE(result.has_value());

  const auto& solve_result = *result;
  REQUIRE(solve_result.success);
  REQUIRE(solve_result.residualNorm < 1e-8);

  // Verify solution satisfies both equations
  const auto& X = solve_result.solution;
  double x = CppAD::Value(X(0));
  double y = CppAD::Value(X(1));

  REQUIRE(std::abs(x * x - y) < 1e-8);  // Parabola equation
  REQUIRE(std::abs(y - 4.0) < 1e-8);    // Line equation

  // The solution should be either (2,4) or (-2,4)
  bool is_valid_solution =
      (std::abs(std::abs(x) - 2.0) < 1e-8) && (std::abs(y - 4.0) < 1e-8);
  REQUIRE(is_valid_solution);
}

TEST_CASE("3D Sphere-Plane-Line Intersection") {
  auto F = [](const ADVector& X) {
    ADVector result(3);
    result(0) =
        X(0) * X(0) + X(1) * X(1) + X(2) * X(2) - 4.0;  // Sphere radius 2
    result(1) = X(0) + X(1) + X(2) - 1.0;               // Plane x+y+z=1
    result(2) = X(0) - X(1);                            // Line x=y
    return result;
  };

  SolveOptions options;
  options.debug = false;
  options.tolerance = 1e-10;

  auto result = solve(F, 3, options);
  REQUIRE(result.has_value());

  const auto& solve_result = *result;
  REQUIRE(solve_result.success);
  REQUIRE(solve_result.residualNorm < 1e-8);

  // Verify solution satisfies all equations
  const auto& X = solve_result.solution;
  const double x = CppAD::Value(X(0));
  const double y = CppAD::Value(X(1));
  const double z = CppAD::Value(X(2));

  REQUIRE(std::abs(x * x + y * y + z * z - 4.0) < 1e-8);  // Sphere
  REQUIRE(std::abs(x + y + z - 1.0) < 1e-8);              // Plane
  REQUIRE(std::abs(x - y) < 1e-8);                        // Line
}

TEST_CASE("System with Transcendental Functions") {
  auto F = [](const ADVector& X) {
    ADVector result(2);
    result(0) = CppAD::cos(X(0)) - X(1);  // cos(x) = y
    result(1) = X(0) * X(1) - 0.5;        // xy = 0.5
    return result;
  };

  SolveOptions options;
  options.debug = false;
  options.verifyDerivatives = true;  // Test derivative computation

  auto result = solve(F, 2, options);
  REQUIRE(result.has_value());

  const auto& solve_result = *result;
  REQUIRE(solve_result.success);
  REQUIRE(solve_result.residualNorm < 1e-8);

  // Verify solution satisfies both equations
  const auto& X = solve_result.solution;
  const double x = CppAD::Value(X(0));
  const double y = CppAD::Value(X(1));

  REQUIRE(std::abs(std::cos(x) - y) < 1e-8);
  REQUIRE(std::abs(x * y - 0.5) < 1e-8);
}

TEST_CASE("Higher Dimensional System") {
  auto F = [](const ADVector& X) {
    ADVector result(4);
    result(0) = X(0) * X(0) * X(0) + CppAD::sin(X(1)) - 1.0;
    result(1) = X(0) * X(0) + X(1) * X(1) + X(2) * X(2) + X(3) * X(3) - 5.0;
    result(2) = X(0) + X(1) + X(2) + CppAD::pow(X(3), 5) + 2.5;
    result(3) = CppAD::sin(X(0)) + CppAD::exp(X(1)) +
                CppAD::cos(X(1)) * X(2) * X(2) * X(2) + 2.0;
    return result;
  };

  SolveOptions options;
  options.debug = true;
  options.maxIterations = 300;  // This system might need more iterations

  auto result = solve(F, 4, options);
  REQUIRE(result.has_value());

  const auto& solve_result = *result;
  REQUIRE(solve_result.success);
  REQUIRE(solve_result.residualNorm < 1e-8);

  // Verify each equation is satisfied
  const auto& X = solve_result.solution;
  auto F_X = F(X);
  for (int i = 0; i < F_X.size(); ++i) {
    REQUIRE(std::abs(CppAD::Value(F_X(i))) < 1e-8);
  }
}

int unused_main(int argc, char** argv) {
  doctest::Context context;
  context.applyCommandLine(argc, argv);

  const int result = context.run();

  if (context.shouldExit()) {
    return result;
  }

  return result;
}

================
File: project/HC-MC/CMakeLists.txt
================
cmake_minimum_required(VERSION 3.15)
project(HC-MC)

#####################################
# Define Target Information
#####################################
set(TARGET_NAME HC-MC)
set(TARGET_INCLUDE_FOLDER ${CMAKE_CURRENT_SOURCE_DIR}/include)

# Find dependencies
find_package(PkgConfig REQUIRED)
find_package(doctest CONFIG REQUIRED)

# Add Boost dependency
find_package(Boost REQUIRED)
include_directories(${Boost_INCLUDE_DIRS})

# Locate CppAD using pkg-config
pkg_check_modules(CPPAD REQUIRED cppad)

# Header-only library target
add_library(${TARGET_NAME} INTERFACE)
target_include_directories(${TARGET_NAME} 
    INTERFACE 
        ${TARGET_INCLUDE_FOLDER}
        ${CPPAD_INCLUDE_DIRS}
        ${Boost_INCLUDE_DIRS}  # Add Boost include dirs
)

# Link against required dependencies
target_link_libraries(${TARGET_NAME} 
    INTERFACE 
        Eigen3::Eigen
        ${CPPAD_LIBRARIES}
        ${Boost_LIBRARIES}  # Add Boost libraries
)

#####################################
# Add Main Executable
#####################################
add_executable(${TARGET_NAME}_main
    main.cpp
)

# Rest of the file remains the same...
# Enable warnings for the executable
target_enable_warnings(${TARGET_NAME}_main)

# Link main executable with the library and required dependencies
target_link_libraries(${TARGET_NAME}_main
    PRIVATE
        ${TARGET_NAME}
        Eigen3::Eigen
        ${CPPAD_LIBRARIES}
)

#####################################
# Tests
#####################################
if(BUILD_TESTING)
    # Create test executable
    add_executable(${TARGET_NAME}_tests 
        tests/pt_tests.cpp
    )
    
    # Enable warnings for the test executable
    target_enable_warnings(${TARGET_NAME}_tests)
    
    # Link against our library and doctest
    target_link_libraries(${TARGET_NAME}_tests 
        PRIVATE 
            ${TARGET_NAME}
            doctest::doctest
    )
    
    # Add to CTest
    add_test(
        NAME ${TARGET_NAME}_tests 
        COMMAND ${TARGET_NAME}_tests
    )
endif()

================
File: project/HC-MC/main.cpp
================
#include <boost/numeric/odeint.hpp>
#include <functional>
#include <iostream>
#include <vector>

#include "HC-MC.hpp"
#include "ODESystem.hpp"
#include "hbtaylor.hpp"
#include "integration_interface.hpp"
#include "observability.hpp"
#include "prob1.hpp"
#include "types.hpp"

using namespace boost::numeric::odeint;

#include <cppad/cppad.hpp>
#include <vector>

template <typename T>
struct SolverConfig {
  SolveOptions options;
  //  Vector<T> initial_guess;
};

inline SolverConfig<double> create_solver_config() {
  SolverConfig<double> config;
  config.options.debug = true;
  config.options.tolerance = 1e-6;
  config.options.maxIterations = 50;
  config.options.initialStepSize = 0.1;
  config.options.verifyDerivatives = true;

  /*config.initial_guess.resize(4);
  config.initial_guess[0] = 1.0;  // Guess for parameter p[0]
  config.initial_guess[1] = 1.0;  // Guess for parameter p[1]
  config.initial_guess[2] = 1.0;  // Guess for initial_state[0]
  config.initial_guess[3] = 0.5;  // Guess for initial_state[1]
*/
  return config;
}

// Function to print results
void print_solution_results(const std::string& method_name,
                            const std::optional<SolveResult>& result) {
  if (result) {
    std::cout << "\nSolution found!\n";
    std::cout << "Estimated parameters: ";
    for (size_t i = 0; i < 2; ++i) {
      std::cout << (result->solution[i]) << " ";
    }
    std::cout << "\nEstimated initial state: ";
    for (size_t i = 2; i < 4; ++i) {
      std::cout << (result->solution[i]) << " ";
    }
    std::cout << "\nResidual norm: " << result->residualNorm << "\n";
    std::cout << "Iterations: " << result->iterations << "\n";
  } else {
    std::cout << "Failed to find solution with " << method_name << "\n";
  }
}

// Run both solvers and print results
void run_solvers(const auto& objective, const SolverConfig<double>& config) {
  std::cout << "\n=== Solving with original method ===\n";
  auto result = solve(objective, 4, config.options);
  print_solution_results("original method", result);

  std::cout << "\n=== Solving with Newton method ===\n";
  auto newton_result = solve_newton(objective, 4, config.options);
  print_solution_results("Newton method", newton_result);
}

// Generate ground truth data from the system
template <typename System>
std::vector<observable_vector<double>> generate_ground_truth(
    const System& system, const std::vector<double>& time_values) {
  return integrate_and_observe(system, time_values);
}

// Create the parameter estimation objective function
template <typename T>
auto create_parameter_objective(
    const SystemConfig<double>& config, const std::vector<double>& time_values,
    const std::vector<observable_vector<double>>& ground_truth) {
  return [config, time_values,
          ground_truth](const ADVector& params) -> ADVector {
    /*std::cout << "\n=== Parameter Objective Called ===\n";*/

    // Debug input parameters
    /*std::cout << "Input params: ";
    for (const auto& p : params) {
      std::cout << (p) << " ";
    }
    std::cout << "\n";*/

    // Extract parameters and initial state
    size_t param_size = 2;
    size_t state_size = 2;
    parameter_vector<AD<T>> p(params.data(), params.data() + param_size);
    state_vector<AD<T>> initial_state(params.data() + param_size,
                                      params.data() + param_size + state_size);

    /*std::cout << "Creating system with:\n";
    std::cout << "Parameters: " << (p[0]) << ", " << (p[1]) << "\n";
    std::cout << "Initial state: " << (initial_state[0]) << ", "
              << (initial_state[1]) << "\n";*/

    // Create the ODESystem instance directly with AD types
    ODESystem<AD<T>, MyStateEquations, MyObservationFunction> system(
        p, MyStateEquations<AD<T>>{}, MyObservationFunction<AD<T>>{});
    system.setInitialState(initial_state);

    // Simulate the system
    std::vector<AD<T>> ad_time_values(time_values.begin(), time_values.end());
    auto simulated_observables = integrate_and_observe(system, ad_time_values);

    // Debug simulated results
    /*std::cout << "\nSimulated observables:\n";
    for (size_t i = 0; i < simulated_observables.size(); ++i) {
      std::cout << "t = " << time_values[i] << ": ";
      for (const auto& val : simulated_observables[i]) {
        std::cout << (val) << " ";
      }
      std::cout << "\n";
    }*/

    // Calculate residuals
    auto observable_length = simulated_observables[0].size();
    ADVector residuals(observable_length * 2);

    size_t observable_count = simulated_observables.size();
    size_t midpoint = observable_count / 2;

    // Only use first and middle point for residuals
    size_t idx = 0;
    size_t i = 0;
    for (size_t j = 0; j < simulated_observables[i].size(); ++j) {
      residuals[idx] = simulated_observables[i][j] - T(ground_truth[i][j]);
      // std::cout << "Residual " << idx << ": " << (residuals[idx]) << " = "
      //           << (simulated_observables[i][j]) << " - " <<
      //           ground_truth[i][j]
      //           << "\n";
      idx++;
    }
    i = midpoint;
    for (size_t j = 0; j < simulated_observables[i].size(); ++j) {
      residuals[idx] = simulated_observables[i][j] - T(ground_truth[i][j]);
      // std::cout << "Residual " << idx << ": " << (residuals[idx]) << " = "
      //           << (simulated_observables[i][j]) << " - " <<
      //           ground_truth[i][j]
      //           << "\n";
      idx++;
    }

    return residuals;
  };
}

// Break down the main function into smaller pieces
void example_parameter_estimation() {
  // Setup configuration
  auto config = create_system_config();
  auto solver_config = create_solver_config();

  // Generate ground truth data
  auto true_system = create_true_system(config);
  auto ground_truth = generate_ground_truth(true_system, config.time_values);

  // Display ground truth data
  std::cout << "\nGround truth data:\n";
  for (size_t i = 0; i < config.time_values.size(); ++i) {
    std::cout << "t = " << config.time_values[i] << ", Observables: ";
    for (const auto& val : ground_truth[i]) {
      std::cout << val << " ";
    }
    std::cout << "\n";
  }

  // Create and run solvers
  auto objective = create_parameter_objective<double>(
      config, config.time_values, ground_truth);
  run_solvers(objective, solver_config);
}

void print_taylor_series(const std::vector<TaylorSeries<double>>& series,
                         const std::string& label) {
  std::cout << "\n" << label << " Taylor series coefficients:\n";
  for (size_t i = 0; i < series.size(); ++i) {
    std::cout << "x_" << i << "(t) = ";
    for (int j = 0; j <= series[i].getDegree(); ++j) {
      if (j > 0) std::cout << " + ";
      std::cout << series[i][j];
      if (j > 0) std::cout << "*t^" << j;
    }
    std::cout << "\n";
  }
}

void analyze_taylor_series() {
  // Create system configuration with example parameters
  auto config = create_system_config();

  // Create the ODE system with T = double
  auto system = create_true_system(config);

  // Compute Taylor series around t0 = 0 using double-based system
  double t0 = 0.0;
  const int degree = 5;  // Compute up to 5th order terms

  std::cout << "\nComputing Taylor series for the ODE system:";
  std::cout << "\nParameters: p1 = " << config.true_params[0]
            << ", p2 = " << config.true_params[1];
  std::cout << "\nInitial state: x1(0) = " << config.true_initial_state[0]
            << ", x2(0) = " << config.true_initial_state[1] << "\n";

  // Compute Taylor series of the state variables
  auto state_series = system.computeTaylorSeriesOfState(t0, degree);
  print_taylor_series(state_series, "State");

  // Compute Taylor series of the observables
  auto observable_series =
      system.computeTaylorSeriesOfObservables(state_series);
  print_taylor_series(observable_series, "Observable");
}

int obs_example() {
  // Example matrix dimensions
  const size_t num_rows = 20;   // Total rows in observability matrix
  const size_t num_cols = 5;    // Number of parameters
  const size_t num_obs = 2;     // Number of observable variables
  const size_t max_derivs = 4;  // Maximum derivatives per observable

  // Create sample observability matrix
  Eigen::MatrixXd obs_matrix = Eigen::MatrixXd::Random(num_rows, num_cols);

  // Optional: Parameter names for better output
  std::vector<std::string> param_names = {"p1", "p2", "p3", "p4", "p5"};

  // Create analyzer with default tolerances
  ObservabilityAnalyzer analyzer;

  // Analyze the matrix
  DerivativeLevels result =
      analyzer.analyze(obs_matrix, num_obs, max_derivs, param_names);

  // Print results
  std::cout << "Derivative levels needed:\n";
  for (const auto& [obs_idx, deriv_count] : result.derivative_levels) {
    std::cout << "Observable " << obs_idx << ": " << deriv_count
              << " derivatives\n";
  }

  return 0;
}

int main() {
  try {
    analyze_taylor_series();
  } catch (const std::exception& e) {
    std::cerr << "Error: " << e.what() << std::endl;
  }

  example_parameter_estimation();
  obs_example();

  return 0;
}

================
File: project/HC-MC/oldermaincpp.txt
================
#include <iomanip>
#include <iostream>

#include "HC-MC.hpp"

// Helper function to print solutions nicely
void print_solution(const SolveResult& result, const std::string& system_name) {
  std::cout << "\n=== " << system_name << " ===\n";
  std::cout << "Success: " << (result.success ? "Yes" : "No") << "\n";
  std::cout << "Residual norm: " << result.residualNorm << "\n";
  std::cout << "Iterations: " << result.iterations << "\n";
  std::cout << "Solution: [";
  for (int i = 0; i < result.solution.size(); ++i) {
    std::cout << std::setprecision(8) << CppAD::Value(result.solution(i));
    if (i < result.solution.size() - 1) std::cout << ", ";
  }
  std::cout << "]\n";
}

template <typename Func>
int run_solver(const Func& F, int dim, const std::string& system_name,
               bool newton = false) {
  // Set some solver options
  SolveOptions options;
  options.debug = false;        // Print debug information
  options.tolerance = 1e-8;     // Tight convergence tolerance
  options.maxIterations = 100;  // Maximum Newton iterations
  options.verifyDerivatives = true;

  try {
    // Solve the circle-line system with explicit dimension
    if (!newton) {
      auto result1 = solve(F, dim, options);  // 2D input
      if (result1) {
        print_solution(*result1, system_name);
      } else {
        std::cout << "No Solution!\n";
      }
    } else {
      auto result1 = solve_newton(F, dim, options);  // 2D input
      if (result1) {
        print_solution(*result1, system_name);
      } else {
        std::cout << "No Solution!\n";
      }
    }

  } catch (const std::exception& e) {
    std::cerr << "Error: " << e.what() << std::endl;
    return 1;
  }

  return 0;
}

int main() {
  std::cout << "HC-MC Example: Solving Nonlinear Systems\n";
  std::cout << "========================================\n";

  // Example 1: Circle-Line intersection
  // System: { x^2 + y^2 = 1  (unit circle)
  //        { x + y = 1     (line)
  auto circle_line = [](const ADVector& X) {
    ADVector result(2);
    result(0) = X(0) * X(0) + X(1) * X(1) - 1.0;  // Circle equation
    result(1) = X(0) + X(1) - 1.0;                // Line equation
    return result;
  };

  // Example 2: Chemical equilibrium
  // A simple chemical equilibrium problem:
  // System: { xy = K     (equilibrium constant)
  //        { x + y = 1   (mass balance)
  auto chemical_eq = [](const ADVector& X) {
    const double K = 0.1;  // equilibrium constant
    ADVector result(2);
    result(0) = X(0) * X(1) - K;    // equilibrium equation
    result(1) = X(0) + X(1) - 1.0;  // mass balance
    return result;
  };

  auto quadratic = [](const ADVector& X) {
    ADVector result(1);
    result(0) = 4.0 * X(0) * X(0) + 2 * X(0) - 1.0;
    return result;
  };

  auto quartic = [](const ADVector& X) {
    ADVector result(1);
    const auto& z = X(0);
    result(0) = 4.0 * z * z * z * z - 25.0 * z * z * z + z * z - z + 3.0;
    return result;
  };

  auto parabola_line = [](const ADVector& X) {
    ADVector result(2);
    result(0) = X(0) * X(0) - X(1);  // Parabola y = x^2
    result(1) = X(1) - 4.0;          // Line y = 4
    return result;
  };

  auto higher_dim = [](const ADVector& X) {
    ADVector result(4);
    result(0) = X(0) * X(0) * X(0) + CppAD::sin(X(1)) - 1.0;
    result(1) = X(0) * X(0) + X(1) * X(1) + X(2) * X(2) + X(3) * X(3) - 5.0;
    result(2) = X(0) + X(1) + X(2) + CppAD::pow(X(3), 5) + 2.5;
    result(3) = CppAD::sin(X(0)) + CppAD::exp(X(1)) +
                CppAD::cos(X(1)) * X(2) * X(2) * X(2) + 2.0;
    return result;
  };

  run_solver(quadratic, 1, "Quadratic", true);
  run_solver(circle_line, 2, "Circle/Line Intersection", true);
  run_solver(chemical_eq, 2, "Chemical Equilibrium,", true);
  run_solver(quartic, 1, "Quartic,", true);
  run_solver(parabola_line, 2, "Parabola/Line Intersection,", true);
  run_solver(higher_dim, 4, "Higher Dimensional System,", true);
  /*
  run_solver(quadratic, 1, "Quadratic");
  run_solver(circle_line, 2, "Circle/Line Intersection");
  run_solver(chemical_eq, 2, "Chemical Equilibrium,");
  run_solver(quartic, 1, "Quartic,");
  run_solver(parabola_line, 2, "Parabola/Line Intersection,");
  run_solver(higher_dim, 4, "Higher Dimensional System,");
  */
}

================
File: project/CMakeLists.txt
================
# MIT License 
# Copyright (c) 2018-Today Michele Adduci <adduci@tutanota.com>
#
# Project-related instructions

# Activate Testing, if given
if(BUILD_TESTING)
  enable_testing()
endif()

#####################################
# Define Targets
#####################################
#add_subdirectory(hellolib)
add_subdirectory(HC-MC)

#####################################
# Define Install Targets
#####################################
install(TARGETS
 # hellolib
  HC-MC
  RUNTIME DESTINATION bin
  LIBRARY DESTINATION lib
  ARCHIVE DESTINATION lib
  PUBLIC_HEADER DESTINATION include
)

install(
  FILES 
    ${CMAKE_SOURCE_DIR}/project/HC-MC/include/HC-MC.h 
    #${CMAKE_BINARY_DIR}/exports/hellolib_export.h
  DESTINATION 
    include/hellolib)

install(FILES  
  ${CMAKE_SOURCE_DIR}/LICENSE
DESTINATION .)

================
File: .clang-format
================
---
Language:        Cpp
BasedOnStyle:    Google
ColumnLimit:     80
IndentWidth:     2
Standard:        c++17

================
File: .clang-tidy
================
# Configure clang-tidy for modern C++ development

#Some of these exclusions might want to be added back periodically. 
Checks: '
    *,
    -abseil-*,
    -altera-*,
    -android-*,
    -fuchsia-*,
  #  -google-*,
    -llvm*,
    -modernize-use-trailing-return-type,
    -zircon-*,
    -readability-else-after-return,
    -readability-static-accessed-through-instance,
    -readability-avoid-const-params-in-decls,
    -clang-diagnostic-sign-conversion,
    -cppcoreguidelines-non-private-member-variables-in-classes,
    -misc-non-private-member-variables-in-classes,
    -cppcoreguidelines-avoid-magic-numbers,
    -readability-magic-numbers,
    -cppcoreguidelines-pro-type-vararg,
    -hicpp-vararg,
    -cppcoreguidelines-pro-bounds-pointer-arithmetic,
    -cppcoreguidelines-avoid-c-arrays,
    -modernize-avoid-c-arrays,
    -hicpp-avoid-c-arrays,
    -cppcoreguidelines-pro-bounds-array-to-pointer-decay,
    -hicpp-no-array-decay,
    -readability-identifier-length,
    -misc-include-cleaner,
    -readability-function-cognitive-complexity,
    -cppcoreguidelines-avoid-do-while,
    '
WarningsAsErrors: ''
HeaderFilterRegex: 'project/HC-MC/.*'
FormatStyle: 'file'

# Disable specific checks in specific files
CheckOptions:
  - key: readability-function-cognitive-complexity.Threshold
    value: '25'
  - key: readability-function-size.LineThreshold
    value: '100'

================
File: .dockerignore
================
*.yml
.travis/
README.md
.git
.gitignore

================
File: .gitignore
================
# vcpkg specific directories
external/vcpkg/buildtrees/
external/vcpkg/downloads/
external/vcpkg/packages/
external/vcpkg/installed/
vcpkg_installed/

# In case you have vcpkg in a different location, also include general patterns
**/vcpkg/buildtrees/
**/vcpkg/downloads/
**/vcpkg/packages/
**/vcpkg/installed/

# Specific build directories that might appear elsewhere
**/x64-linux-dbg/
**/x64-linux-rel/
.cache

# CMake build artifacts
**/CMakeFiles/
**/CMakeCache.txt
cmake-build-*/

# General build and dependency directories
build/
dist/

================
File: .gitmodules
================
[submodule "external/vcpkg"]
	path = external/vcpkg
	url = https://github.com/Microsoft/vcpkg.git

================
File: .repomixignore
================
vcpkg/
build/
LICENSE
vcpkg_installed/
external/
.github/
mpreal.h

================
File: build.sh
================
#!/usr/bin/env bash
set -eo pipefail

# Print usage information
print_usage() {
    echo "Usage: $0 [options]"
    echo "Options:"
    echo "  --debug                Build with debug symbols (default)"
    echo "  --release              Build with optimizations"
    echo "  --compiler=<name>      Use specific compiler (gcc|clang)"
    echo "  --compiler-version=<v> Use specific compiler version"
    echo "  --clean               Clean build directory before building"
    echo "  --help                Show this help message"
}

# Default values
BUILD_TYPE="Debug"
COMPILER="gcc"
COMPILER_VERSION=""
CLEAN=0

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --release)
            BUILD_TYPE="Release"
            shift
            ;;
        --debug)
            BUILD_TYPE="Debug"
            shift
            ;;
        --compiler=*)
            COMPILER="${1#*=}"
            shift
            ;;
        --compiler-version=*)
            COMPILER_VERSION="${1#*=}"
            shift
            ;;
        --clean)
            CLEAN=1
            shift
            ;;
        --help)
            print_usage
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            print_usage
            exit 1
            ;;
    esac
done


check_dependencies() {
    case "$(uname -s)" in
        Linux*)
            echo "Required packages for Linux:"
            echo "  build-essential cmake git pkg-config"
            echo "  libgmp-dev libmpfr-dev libcppad-dev libeigen3-dev"
            echo "Install using: sudo apt-get install <packages>"
            ;;
        Darwin*)
            echo "Required packages for macOS:"
            echo "  Install Xcode command line tools: xcode-select --install"
            echo "  Install Homebrew packages:"
            echo "  brew install cmake gmp mpfr cppad eigen"
            ;;
        MINGW*|MSYS*|CYGWIN*)
            echo "Required setup for Windows:"
            echo "1. Install Visual Studio Build Tools"
            echo "2. Install CMake"
            echo "Note: Most dependencies will be handled by vcpkg"
            ;;
        *)
            echo "Unsupported operating system"
            exit 1
            ;;
    esac
    
    echo -e "\nMissing dependencies? Follow platform-specific instructions above."
    read -p "Continue with build? [y/N] " response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
        exit 1
    fi
}


# Install system dependencies
install_system_dependencies() {
    echo "Checking and installing system dependencies..."
    
    # Check if we have sudo access
    if ! command -v sudo &> /dev/null; then
        echo "Error: sudo is not available. Please run as root or install sudo."
        exit 1
    fi

    # Update package list
    sudo apt-get update

    # Install required packages
    sudo apt-get install -y \
        build-essential \
        cmake \
        git \
        pkg-config \
        libgmp-dev \
        libmpfr-dev \
        libcppad-dev \
        libeigen3-dev \
        libboost-all-dev \
        libtool \
        ninja-build \

    if [ "$COMPILER" = "clang" ]; then
        if [ -n "$COMPILER_VERSION" ]; then
            sudo apt-get install -y clang-$COMPILER_VERSION
        else
            sudo apt-get install -y clang
        fi
    fi
}

# Setup compiler environment
setup_compiler() {
    echo "Setting up compiler environment..."
    
    case $COMPILER in
        gcc)
            if [ -n "$COMPILER_VERSION" ]; then
                export CC="gcc-${COMPILER_VERSION}"
                export CXX="g++-${COMPILER_VERSION}"
            else
                export CC="gcc"
                export CXX="g++"
            fi
            ;;
            
        clang)
            if [ -n "$COMPILER_VERSION" ]; then
                export CC="clang-${COMPILER_VERSION}"
                export CXX="clang++-${COMPILER_VERSION}"
            else
                export CC="clang"
                export CXX="clang++"
            fi
            ;;
            
        *)
            echo "Unsupported compiler: $COMPILER"
            exit 1
            ;;
    esac
    
    # Verify compiler exists
    if ! command -v "$CC" >/dev/null 2>&1; then
        echo "Error: Compiler $CC not found"
        exit 1
    fi
    
    if ! command -v "$CXX" >/dev/null 2>&1; then
        echo "Error: Compiler $CXX not found"
        exit 1
    fi
    
    echo "Using C compiler: $CC ($(command -v "$CC"))"
    echo "Using C++ compiler: $CXX ($(command -v "$CXX"))"
}

# Setup vcpkg
# Setup vcpkg
setup_vcpkg() {
    echo "Setting up vcpkg..."
    
    # Force use of system binaries (including CMake)
    #export CMAKE_GENERATOR="Unix Makefiles"
    export VCPKG_FORCE_SYSTEM_BINARIES=1
    
    # Only clone if directory doesn't exist
    if [ ! -d "external/vcpkg" ]; then
        echo "Cloning vcpkg..."
        mkdir -p external
        if ! git clone https://github.com/Microsoft/vcpkg.git external/vcpkg; then
            echo "Failed to clone vcpkg repository"
            exit 1
        fi
    fi

    # Verify the bootstrap script exists
    if [ ! -f "external/vcpkg/bootstrap-vcpkg.sh" ]; then
        echo "bootstrap-vcpkg.sh not found. vcpkg installation may be corrupted."
        echo "Delete the external/vcpkg directory and try again."
        exit 1
    fi

    # Make bootstrap script executable
    chmod +x external/vcpkg/bootstrap-vcpkg.sh

    # Only bootstrap if vcpkg executable doesn't exist
    if [ ! -f "external/vcpkg/vcpkg" ]; then
        echo "Bootstrapping vcpkg..."
        if ! ./external/vcpkg/bootstrap-vcpkg.sh; then
            echo "Failed to bootstrap vcpkg"
            exit 1
        fi
    fi

    # Set VCPKG_ROOT
    export VCPKG_ROOT="$(pwd)/external/vcpkg"

    # Install dependencies from manifest
    echo "Installing dependencies from vcpkg.json manifest..."
    if ! "$VCPKG_ROOT/vcpkg" install --triplet x64-linux; then
        echo "Failed to install dependencies from manifest"
        exit 1
    fi
}

# Main build process
main() {
    # Install system dependencies
    check_dependencies

    # Setup compiler
    setup_compiler

    # Setup vcpkg
    setup_vcpkg

    # Clean build directory if requested
    if [ "$CLEAN" -eq 1 ]; then
        echo "Cleaning build directory..."
        rm -rf build
    fi

    # Create build directory
    mkdir -p build

    echo "Configuring with CMake..."
    cmake -B build -S . \
        -DCMAKE_TOOLCHAIN_FILE="$VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake" \
        -DVCPKG_TARGET_TRIPLET=x64-linux \
        -DBUILD_TESTING=ON \
        -DCMAKE_BUILD_TYPE=${BUILD_TYPE} \
        -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
        -DCMAKE_C_COMPILER="$CC" \
        -DCMAKE_CXX_COMPILER="$CXX"

    echo "Building..."
    cmake --build build -j$(nproc)

    echo "Running tests..."
    ctest --test-dir build --output-on-failure

    echo "Build complete!"
    echo "Type: ${BUILD_TYPE}"
    if [ "$BUILD_TYPE" = "Debug" ]; then
        echo "Debug symbols are enabled. You can use gdb/lldb for debugging."
    fi
}

# Run main function
main

================
File: CMakeLists.txt
================
cmake_minimum_required(VERSION 3.15.0 FATAL_ERROR)
set(CMAKE_TOOLCHAIN_FILE "${CMAKE_CURRENT_SOURCE_DIR}/external/vcpkg/scripts/buildsystems/vcpkg.cmake" CACHE STRING "Vcpkg toolchain file")


project(moderncpp_project 
    VERSION 1.1.2
    LANGUAGES CXX
    DESCRIPTION "HC-MC is a testbed for homotopy continuation methods."
)

# Set required C++ Standard
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED TRUE)
set(CMAKE_EXPORT_COMPILE_COMMANDS TRUE)

# Configure the visibility of symbols in targets
set(CMAKE_CXX_VISIBILITY_PRESET hidden)
set(CMAKE_VISIBILITY_INLINES_HIDDEN 1)

#####################################
# Define Options
#####################################
option(BUILD_TESTING "Build tests" FALSE)
option(BUILD_SHARED_LIBS "Build shared libraries" FALSE)
option(BUILD_WITH_MT "Build libraries as MultiThreaded DLL (Windows Only)" FALSE)

#####################################
# Find Dependencies - vcpkg handles the heavy lifting
#####################################
find_package(Eigen3 CONFIG REQUIRED)

# Use pkg-config to locate cppad
find_package(PkgConfig REQUIRED)
pkg_check_modules(CPPAD REQUIRED cppad)

# Add the cppad include directories and libraries
include_directories(${CPPAD_INCLUDE_DIRS})
link_directories(${CPPAD_LIBRARY_DIRS})

# Add testing dependencies if enabled
if(BUILD_TESTING)
    find_package(doctest CONFIG REQUIRED)
    enable_testing()
endif()

#####################################
# Define CMake Module Imports
#####################################
include(GNUInstallDirs)
include(CMakePackageConfigHelpers)
include(GenerateExportHeader)
include(${CMAKE_SOURCE_DIR}/cmake/compiler_options.cmake)
include(${CMAKE_SOURCE_DIR}/cmake/cpack.cmake)
include(${CMAKE_SOURCE_DIR}/cmake/cppcheck.cmake)
include(${CMAKE_SOURCE_DIR}/cmake/clang_format.cmake)
include(${CMAKE_SOURCE_DIR}/cmake/clang_tidy.cmake)

#####################################
# Define Targets
#####################################
add_subdirectory(project/HC-MC)

#####################################
# Define Install Targets
#####################################
install(TARGETS
    HC-MC
    RUNTIME DESTINATION bin
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
    PUBLIC_HEADER DESTINATION include
)

install(FILES  
    ${CMAKE_SOURCE_DIR}/LICENSE
    DESTINATION .
)

================
File: cppcheck_suppressions.txt
================
missingIncludeSystem

================
File: README.md
================
## Building with vcpkg

This project uses vcpkg for dependency management. To build:

1. Install vcpkg if you haven't already:
```bash
git clone https://github.com/Microsoft/vcpkg.git
./vcpkg/bootstrap-vcpkg.sh  # or bootstrap-vcpkg.bat on Windows
```

2. Build the project:
```bash
cmake -B build -S . -DCMAKE_TOOLCHAIN_FILE=[path to vcpkg]/scripts/buildsystems/vcpkg.cmake
cmake --build build
```

Replace `[path to vcpkg]` with the actual path where you installed vcpkg.

For convenience, you can set the `VCPKG_ROOT` environment variable to your vcpkg installation directory:
```bash
export VCPKG_ROOT=/path/to/vcpkg
```

Then build with:
```bash
cmake -B build -S . -DCMAKE_TOOLCHAIN_FILE=$VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake
cmake --build build
```

================
File: vcpkg.json
================
{
    "name": "hc-mc",
    "version": "1.0.0",
    "description": "A testbed for homotopy continuation methods",
    "dependencies": [
        "eigen3",
        "cppad",
        {
            "name": "doctest",
            "platform": "!windows"
        }
    ],
    "builtin-baseline": "d221c5d2cbadf35ceb266cbb95750a940b103b65"
}
